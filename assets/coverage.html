
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>async: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/wfusion/gofusion/async/asynq.go (71.5%)</option>
				
				<option value="file1">github.com/wfusion/gofusion/async/construct.go (82.7%)</option>
				
				<option value="file2">github.com/wfusion/gofusion/async/log.go (31.8%)</option>
				
				<option value="file3">github.com/wfusion/gofusion/async/types.go (18.2%)</option>
				
				<option value="file4">github.com/wfusion/gofusion/async/utils.go (81.2%)</option>
				
				<option value="file5">github.com/wfusion/gofusion/cache/cache.go (80.4%)</option>
				
				<option value="file6">github.com/wfusion/gofusion/cache/construct.go (66.7%)</option>
				
				<option value="file7">github.com/wfusion/gofusion/cache/local.go (69.2%)</option>
				
				<option value="file8">github.com/wfusion/gofusion/cache/redis.go (70.8%)</option>
				
				<option value="file9">github.com/wfusion/gofusion/cache/types.go (100.0%)</option>
				
				<option value="file10">github.com/wfusion/gofusion/common/constant/time_format.go (0.0%)</option>
				
				<option value="file11">github.com/wfusion/gofusion/common/di/dig.go (70.0%)</option>
				
				<option value="file12">github.com/wfusion/gofusion/common/env/env.go (61.9%)</option>
				
				<option value="file13">github.com/wfusion/gofusion/common/infra/drivers/mongo/interface.go (100.0%)</option>
				
				<option value="file14">github.com/wfusion/gofusion/common/infra/drivers/mongo/logger.go (100.0%)</option>
				
				<option value="file15">github.com/wfusion/gofusion/common/infra/drivers/mongo/mongo.go (87.5%)</option>
				
				<option value="file16">github.com/wfusion/gofusion/common/infra/drivers/orm/gorm.go (74.6%)</option>
				
				<option value="file17">github.com/wfusion/gofusion/common/infra/drivers/orm/idgen/interface.go (50.0%)</option>
				
				<option value="file18">github.com/wfusion/gofusion/common/infra/drivers/orm/idgen/snowflake.go (90.9%)</option>
				
				<option value="file19">github.com/wfusion/gofusion/common/infra/drivers/orm/interface.go (75.0%)</option>
				
				<option value="file20">github.com/wfusion/gofusion/common/infra/drivers/orm/logger.go (100.0%)</option>
				
				<option value="file21">github.com/wfusion/gofusion/common/infra/drivers/redis/hook.go (100.0%)</option>
				
				<option value="file22">github.com/wfusion/gofusion/common/infra/drivers/redis/interface.go (11.1%)</option>
				
				<option value="file23">github.com/wfusion/gofusion/common/infra/drivers/redis/redis.go (50.9%)</option>
				
				<option value="file24">github.com/wfusion/gofusion/common/utils/candy.go (74.1%)</option>
				
				<option value="file25">github.com/wfusion/gofusion/common/utils/channel.go (71.4%)</option>
				
				<option value="file26">github.com/wfusion/gofusion/common/utils/cipher/aead_wrapper.go (83.9%)</option>
				
				<option value="file27">github.com/wfusion/gofusion/common/utils/cipher/algorithm_enum.go (55.6%)</option>
				
				<option value="file28">github.com/wfusion/gofusion/common/utils/cipher/block_mode_wrapper.go (93.5%)</option>
				
				<option value="file29">github.com/wfusion/gofusion/common/utils/cipher/decrypt.go (86.9%)</option>
				
				<option value="file30">github.com/wfusion/gofusion/common/utils/cipher/encrypt.go (88.1%)</option>
				
				<option value="file31">github.com/wfusion/gofusion/common/utils/cipher/mode_enum.go (66.7%)</option>
				
				<option value="file32">github.com/wfusion/gofusion/common/utils/cipher/padding.go (71.4%)</option>
				
				<option value="file33">github.com/wfusion/gofusion/common/utils/cipher/rc4_wrapper.go (87.5%)</option>
				
				<option value="file34">github.com/wfusion/gofusion/common/utils/cipher/types.go (85.7%)</option>
				
				<option value="file35">github.com/wfusion/gofusion/common/utils/clone/allocator.go (67.0%)</option>
				
				<option value="file36">github.com/wfusion/gofusion/common/utils/clone/allocatormethods.go (0.0%)</option>
				
				<option value="file37">github.com/wfusion/gofusion/common/utils/clone/api_go118.go (50.0%)</option>
				
				<option value="file38">github.com/wfusion/gofusion/common/utils/clone/base.go (11.4%)</option>
				
				<option value="file39">github.com/wfusion/gofusion/common/utils/clone/clone.go (36.8%)</option>
				
				<option value="file40">github.com/wfusion/gofusion/common/utils/clone/cloner.go (100.0%)</option>
				
				<option value="file41">github.com/wfusion/gofusion/common/utils/clone/interfacedata.go (92.9%)</option>
				
				<option value="file42">github.com/wfusion/gofusion/common/utils/clone/mapiter_go112.go (100.0%)</option>
				
				<option value="file43">github.com/wfusion/gofusion/common/utils/clone/structtype.go (46.8%)</option>
				
				<option value="file44">github.com/wfusion/gofusion/common/utils/clone/wrapper.go (0.0%)</option>
				
				<option value="file45">github.com/wfusion/gofusion/common/utils/cmp/base.go (23.1%)</option>
				
				<option value="file46">github.com/wfusion/gofusion/common/utils/compare.go (64.7%)</option>
				
				<option value="file47">github.com/wfusion/gofusion/common/utils/compress/algorithm_enum.go (88.9%)</option>
				
				<option value="file48">github.com/wfusion/gofusion/common/utils/compress/decode.go (70.2%)</option>
				
				<option value="file49">github.com/wfusion/gofusion/common/utils/compress/encode.go (63.2%)</option>
				
				<option value="file50">github.com/wfusion/gofusion/common/utils/compress/types.go (100.0%)</option>
				
				<option value="file51">github.com/wfusion/gofusion/common/utils/compress/wrapper.go (100.0%)</option>
				
				<option value="file52">github.com/wfusion/gofusion/common/utils/context.go (84.6%)</option>
				
				<option value="file53">github.com/wfusion/gofusion/common/utils/conv.go (44.6%)</option>
				
				<option value="file54">github.com/wfusion/gofusion/common/utils/encode/algorithm_enum.go (55.6%)</option>
				
				<option value="file55">github.com/wfusion/gofusion/common/utils/encode/codec.go (82.3%)</option>
				
				<option value="file56">github.com/wfusion/gofusion/common/utils/encode/encode_type_enum.go (40.0%)</option>
				
				<option value="file57">github.com/wfusion/gofusion/common/utils/encode/stream.go (93.2%)</option>
				
				<option value="file58">github.com/wfusion/gofusion/common/utils/encode/types.go (100.0%)</option>
				
				<option value="file59">github.com/wfusion/gofusion/common/utils/enum.go (83.8%)</option>
				
				<option value="file60">github.com/wfusion/gofusion/common/utils/error.go (0.0%)</option>
				
				<option value="file61">github.com/wfusion/gofusion/common/utils/func.go (54.5%)</option>
				
				<option value="file62">github.com/wfusion/gofusion/common/utils/heap.go (0.0%)</option>
				
				<option value="file63">github.com/wfusion/gofusion/common/utils/inspect/field.go (75.0%)</option>
				
				<option value="file64">github.com/wfusion/gofusion/common/utils/inspect/field_go118.go (33.3%)</option>
				
				<option value="file65">github.com/wfusion/gofusion/common/utils/inspect/init_go118.go (89.5%)</option>
				
				<option value="file66">github.com/wfusion/gofusion/common/utils/inspect/inspect.go (58.8%)</option>
				
				<option value="file67">github.com/wfusion/gofusion/common/utils/inspect/misc_go118.go (66.7%)</option>
				
				<option value="file68">github.com/wfusion/gofusion/common/utils/inspect/rtype.go (100.0%)</option>
				
				<option value="file69">github.com/wfusion/gofusion/common/utils/ip.go (80.0%)</option>
				
				<option value="file70">github.com/wfusion/gofusion/common/utils/map.go (75.0%)</option>
				
				<option value="file71">github.com/wfusion/gofusion/common/utils/marshal.go (32.6%)</option>
				
				<option value="file72">github.com/wfusion/gofusion/common/utils/number.go (0.0%)</option>
				
				<option value="file73">github.com/wfusion/gofusion/common/utils/options.go (100.0%)</option>
				
				<option value="file74">github.com/wfusion/gofusion/common/utils/pool.go (90.0%)</option>
				
				<option value="file75">github.com/wfusion/gofusion/common/utils/random.go (60.0%)</option>
				
				<option value="file76">github.com/wfusion/gofusion/common/utils/reflect.go (62.3%)</option>
				
				<option value="file77">github.com/wfusion/gofusion/common/utils/serialize/algorithm_enum.go (88.9%)</option>
				
				<option value="file78">github.com/wfusion/gofusion/common/utils/serialize/marshal.go (83.3%)</option>
				
				<option value="file79">github.com/wfusion/gofusion/common/utils/serialize/types.go (64.7%)</option>
				
				<option value="file80">github.com/wfusion/gofusion/common/utils/serialize/unmarshal.go (56.8%)</option>
				
				<option value="file81">github.com/wfusion/gofusion/common/utils/sets.go (33.8%)</option>
				
				<option value="file82">github.com/wfusion/gofusion/common/utils/slice.go (42.9%)</option>
				
				<option value="file83">github.com/wfusion/gofusion/common/utils/sort.go (0.0%)</option>
				
				<option value="file84">github.com/wfusion/gofusion/common/utils/string.go (94.7%)</option>
				
				<option value="file85">github.com/wfusion/gofusion/common/utils/tag.go (78.3%)</option>
				
				<option value="file86">github.com/wfusion/gofusion/common/utils/time.go (40.7%)</option>
				
				<option value="file87">github.com/wfusion/gofusion/config/candy.go (89.7%)</option>
				
				<option value="file88">github.com/wfusion/gofusion/config/component.go (54.9%)</option>
				
				<option value="file89">github.com/wfusion/gofusion/config/crypto.go (68.9%)</option>
				
				<option value="file90">github.com/wfusion/gofusion/config/loader.go (76.7%)</option>
				
				<option value="file91">github.com/wfusion/gofusion/config/registry.go (89.4%)</option>
				
				<option value="file92">github.com/wfusion/gofusion/config/types.go (100.0%)</option>
				
				<option value="file93">github.com/wfusion/gofusion/context/candy.go (70.0%)</option>
				
				<option value="file94">github.com/wfusion/gofusion/context/context.go (75.5%)</option>
				
				<option value="file95">github.com/wfusion/gofusion/cron/asynq.go (74.8%)</option>
				
				<option value="file96">github.com/wfusion/gofusion/cron/construct.go (87.2%)</option>
				
				<option value="file97">github.com/wfusion/gofusion/cron/log.go (86.4%)</option>
				
				<option value="file98">github.com/wfusion/gofusion/cron/types.go (25.0%)</option>
				
				<option value="file99">github.com/wfusion/gofusion/db/callbacks/auto_incr.go (0.0%)</option>
				
				<option value="file100">github.com/wfusion/gofusion/db/callbacks/build_sql.go (64.5%)</option>
				
				<option value="file101">github.com/wfusion/gofusion/db/callbacks/soft_delete.go (73.2%)</option>
				
				<option value="file102">github.com/wfusion/gofusion/db/candy.go (57.0%)</option>
				
				<option value="file103">github.com/wfusion/gofusion/db/construct.go (89.5%)</option>
				
				<option value="file104">github.com/wfusion/gofusion/db/ctx.go (100.0%)</option>
				
				<option value="file105">github.com/wfusion/gofusion/db/dal.go (43.0%)</option>
				
				<option value="file106">github.com/wfusion/gofusion/db/db.go (84.6%)</option>
				
				<option value="file107">github.com/wfusion/gofusion/db/metrics.go (76.4%)</option>
				
				<option value="file108">github.com/wfusion/gofusion/db/model.go (6.7%)</option>
				
				<option value="file109">github.com/wfusion/gofusion/db/plugins/table_sharding.go (61.0%)</option>
				
				<option value="file110">github.com/wfusion/gofusion/db/softdelete/deleted.go (60.9%)</option>
				
				<option value="file111">github.com/wfusion/gofusion/db/softdelete/deletedat.go (44.4%)</option>
				
				<option value="file112">github.com/wfusion/gofusion/db/softdelete/timestamp.go (54.2%)</option>
				
				<option value="file113">github.com/wfusion/gofusion/db/softdelete/types.go (100.0%)</option>
				
				<option value="file114">github.com/wfusion/gofusion/db/tx.go (75.0%)</option>
				
				<option value="file115">github.com/wfusion/gofusion/http/asynq.go (77.8%)</option>
				
				<option value="file116">github.com/wfusion/gofusion/http/construct.go (84.4%)</option>
				
				<option value="file117">github.com/wfusion/gofusion/http/consts/context.go (88.9%)</option>
				
				<option value="file118">github.com/wfusion/gofusion/http/error.go (5.3%)</option>
				
				<option value="file119">github.com/wfusion/gofusion/http/gracefully/endless.go (3.1%)</option>
				
				<option value="file120">github.com/wfusion/gofusion/http/gracefully/signal_darwin.go (2.3%)</option>
				
				<option value="file121">github.com/wfusion/gofusion/http/i18n.go (0.0%)</option>
				
				<option value="file122">github.com/wfusion/gofusion/http/metrics.go (69.2%)</option>
				
				<option value="file123">github.com/wfusion/gofusion/http/middleware/cors.go (65.0%)</option>
				
				<option value="file124">github.com/wfusion/gofusion/http/middleware/gateway.go (100.0%)</option>
				
				<option value="file125">github.com/wfusion/gofusion/http/middleware/logging.go (77.4%)</option>
				
				<option value="file126">github.com/wfusion/gofusion/http/middleware/recover.go (14.3%)</option>
				
				<option value="file127">github.com/wfusion/gofusion/http/middleware/trace.go (100.0%)</option>
				
				<option value="file128">github.com/wfusion/gofusion/http/middleware/xss.go (9.5%)</option>
				
				<option value="file129">github.com/wfusion/gofusion/http/parser/application_json.go (0.0%)</option>
				
				<option value="file130">github.com/wfusion/gofusion/http/parser/application_x_www_form_urlencoded.go (75.0%)</option>
				
				<option value="file131">github.com/wfusion/gofusion/http/parser/form_mapping.go (49.2%)</option>
				
				<option value="file132">github.com/wfusion/gofusion/http/parser/multipart_formdata.go (43.0%)</option>
				
				<option value="file133">github.com/wfusion/gofusion/http/parser/parser.go (50.0%)</option>
				
				<option value="file134">github.com/wfusion/gofusion/http/response.go (71.4%)</option>
				
				<option value="file135">github.com/wfusion/gofusion/http/router.go (64.7%)</option>
				
				<option value="file136">github.com/wfusion/gofusion/http/zerocopy.go (65.6%)</option>
				
				<option value="file137">github.com/wfusion/gofusion/i18n/construct.go (90.6%)</option>
				
				<option value="file138">github.com/wfusion/gofusion/i18n/i18n.go (37.0%)</option>
				
				<option value="file139">github.com/wfusion/gofusion/internal/configor/configor.go (60.9%)</option>
				
				<option value="file140">github.com/wfusion/gofusion/internal/configor/utils.go (58.7%)</option>
				
				<option value="file141">github.com/wfusion/gofusion/internal/util/payload/seal.go (69.8%)</option>
				
				<option value="file142">github.com/wfusion/gofusion/internal/util/payload/types.go (80.0%)</option>
				
				<option value="file143">github.com/wfusion/gofusion/internal/util/payload/unseal.go (55.4%)</option>
				
				<option value="file144">github.com/wfusion/gofusion/lock/candy.go (84.4%)</option>
				
				<option value="file145">github.com/wfusion/gofusion/lock/construct.go (65.6%)</option>
				
				<option value="file146">github.com/wfusion/gofusion/lock/mysql.go (78.0%)</option>
				
				<option value="file147">github.com/wfusion/gofusion/lock/redis.go (91.4%)</option>
				
				<option value="file148">github.com/wfusion/gofusion/lock/types.go (100.0%)</option>
				
				<option value="file149">github.com/wfusion/gofusion/log/candy.go (11.8%)</option>
				
				<option value="file150">github.com/wfusion/gofusion/log/construct.go (84.4%)</option>
				
				<option value="file151">github.com/wfusion/gofusion/log/customlogger/async.go (21.7%)</option>
				
				<option value="file152">github.com/wfusion/gofusion/log/customlogger/cron.go (30.9%)</option>
				
				<option value="file153">github.com/wfusion/gofusion/log/customlogger/gorm.go (51.2%)</option>
				
				<option value="file154">github.com/wfusion/gofusion/log/customlogger/metrics.go (50.7%)</option>
				
				<option value="file155">github.com/wfusion/gofusion/log/customlogger/mongo.go (48.0%)</option>
				
				<option value="file156">github.com/wfusion/gofusion/log/customlogger/mq.go (68.5%)</option>
				
				<option value="file157">github.com/wfusion/gofusion/log/customlogger/redis.go (50.0%)</option>
				
				<option value="file158">github.com/wfusion/gofusion/log/customlogger/routine.go (50.0%)</option>
				
				<option value="file159">github.com/wfusion/gofusion/log/encoder/skip_caller.go (100.0%)</option>
				
				<option value="file160">github.com/wfusion/gofusion/log/field.go (90.9%)</option>
				
				<option value="file161">github.com/wfusion/gofusion/log/logger.go (81.2%)</option>
				
				<option value="file162">github.com/wfusion/gofusion/log/utils.go (75.0%)</option>
				
				<option value="file163">github.com/wfusion/gofusion/metrics/construct.go (90.1%)</option>
				
				<option value="file164">github.com/wfusion/gofusion/metrics/http.go (0.0%)</option>
				
				<option value="file165">github.com/wfusion/gofusion/metrics/metrics.go (68.1%)</option>
				
				<option value="file166">github.com/wfusion/gofusion/metrics/mock.go (100.0%)</option>
				
				<option value="file167">github.com/wfusion/gofusion/metrics/prometheus.go (25.0%)</option>
				
				<option value="file168">github.com/wfusion/gofusion/metrics/types.go (100.0%)</option>
				
				<option value="file169">github.com/wfusion/gofusion/mongo/construct.go (90.2%)</option>
				
				<option value="file170">github.com/wfusion/gofusion/mongo/metrics.go (33.8%)</option>
				
				<option value="file171">github.com/wfusion/gofusion/mongo/mongo.go (52.0%)</option>
				
				<option value="file172">github.com/wfusion/gofusion/mq/amqp.go (76.1%)</option>
				
				<option value="file173">github.com/wfusion/gofusion/mq/construct.go (76.2%)</option>
				
				<option value="file174">github.com/wfusion/gofusion/mq/event.go (60.2%)</option>
				
				<option value="file175">github.com/wfusion/gofusion/mq/gochannel.go (100.0%)</option>
				
				<option value="file176">github.com/wfusion/gofusion/mq/kafka.go (71.1%)</option>
				
				<option value="file177">github.com/wfusion/gofusion/mq/log.go (0.0%)</option>
				
				<option value="file178">github.com/wfusion/gofusion/mq/mq.go (39.1%)</option>
				
				<option value="file179">github.com/wfusion/gofusion/mq/mysql.go (90.9%)</option>
				
				<option value="file180">github.com/wfusion/gofusion/mq/postgres.go (90.9%)</option>
				
				<option value="file181">github.com/wfusion/gofusion/mq/pulsar.go (73.5%)</option>
				
				<option value="file182">github.com/wfusion/gofusion/mq/redis.go (88.9%)</option>
				
				<option value="file183">github.com/wfusion/gofusion/mq/router.go (66.1%)</option>
				
				<option value="file184">github.com/wfusion/gofusion/mq/types.go (59.1%)</option>
				
				<option value="file185">github.com/wfusion/gofusion/mq/utils.go (0.0%)</option>
				
				<option value="file186">github.com/wfusion/gofusion/redis/construct.go (90.2%)</option>
				
				<option value="file187">github.com/wfusion/gofusion/redis/metrics.go (59.1%)</option>
				
				<option value="file188">github.com/wfusion/gofusion/redis/redis.go (84.6%)</option>
				
				<option value="file189">github.com/wfusion/gofusion/redis/wrap.go (5.7%)</option>
				
				<option value="file190">github.com/wfusion/gofusion/routine/candy.go (37.1%)</option>
				
				<option value="file191">github.com/wfusion/gofusion/routine/candy_utils.go (32.8%)</option>
				
				<option value="file192">github.com/wfusion/gofusion/routine/construct.go (92.7%)</option>
				
				<option value="file193">github.com/wfusion/gofusion/routine/future.go (39.7%)</option>
				
				<option value="file194">github.com/wfusion/gofusion/routine/metrics.go (73.2%)</option>
				
				<option value="file195">github.com/wfusion/gofusion/routine/pool.go (68.6%)</option>
				
				<option value="file196">github.com/wfusion/gofusion/routine/promise.go (33.3%)</option>
				
				<option value="file197">github.com/wfusion/gofusion/routine/types.go (58.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package async

import (
        "context"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/pkg/errors"
        "github.com/wfusion/gofusion/log"
        "go.uber.org/multierr"

        "github.com/wfusion/gofusion/common/infra/asynq"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/common/utils/serialize"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/redis"

        rdsDrv "github.com/redis/go-redis/v9"

        pd "github.com/wfusion/gofusion/internal/util/payload"
)

const (
        asyncqTaskTypenameField = "typename"
)

var (
        asynqLoggerType = reflect.TypeOf((*asynq.Logger)(nil)).Elem()
)

type asynqConsumer struct {
        *asynq.ServeMux

        appName string
        n       string
        c       *Conf

        mws      []asynq.MiddlewareFunc
        logger   asynq.Logger
        consumer *asynq.Server
}

func newAsynqConsumer(ctx context.Context, appName, name string, conf *Conf) Consumable <span class="cov7" title="11">{
        consumer := &amp;asynqConsumer{appName: appName, n: name, c: conf}

        var rdsCli rdsDrv.UniversalClient
        switch conf.InstanceType </span>{
        case instanceTypeRedis:<span class="cov7" title="11">
                rdsCli = redis.Use(ctx, conf.Instance, redis.AppName(appName))</span>
        case instanceTypeDB:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unknown instance type: %s", conf.InstanceType))</span>
        }

        <span class="cov7" title="11">if consumer.logger == nil &amp;&amp; utils.IsStrNotBlank(conf.Logger) </span><span class="cov7" title="11">{
                loggerType := inspect.TypeOf(conf.Logger)
                loggerValue := reflect.New(loggerType)
                if loggerValue.Type().Implements(customLoggerType) </span><span class="cov7" title="11">{
                        logger := log.Use(conf.LogInstance, log.AppName(appName))
                        loggerValue.Interface().(customLogger).Init(logger, appName, name)
                }</span>
                <span class="cov7" title="11">consumer.logger = loggerValue.Convert(asynqLoggerType).Interface().(asynq.Logger)</span>
        }

        <span class="cov7" title="11">logLevel := asynq.LogLevel(0)
        utils.MustSuccess(logLevel.Set(conf.LogLevel))

        consumer.ServeMux = asynq.NewServeMux()
        asynqCfg := asynq.Config{
                Concurrency:    conf.ConsumerConcurrency,
                BaseContext:    context.Background,
                RetryDelayFunc: asynq.DefaultRetryDelayFunc,
                IsFailure:      nil,
                Queues:         nil,
                StrictPriority: conf.StrictPriority,
                ErrorHandler: asynq.ErrorHandlerFunc(func(ctx context.Context, task *asynq.Task, err error) </span><span class="cov0" title="0">{
                        taskName := "unknown"
                        if task != nil </span><span class="cov0" title="0">{
                                taskName = consumer.unformatTaskName(task.Type())
                        }</span>
                        <span class="cov0" title="0">consumer.info(ctx, "handle task %s message error %s", taskName, err)</span>
                }),
                Logger:                   consumer.logger,
                LogLevel:                 logLevel,
                ShutdownTimeout:          8 * time.Second,
                HealthCheckFunc:          func(err error) <span class="cov0" title="0">{ consumer.warn(ctx, "health check check failed: %s", err) }</span>,
                HealthCheckInterval:      15 * time.Second,
                DelayedTaskCheckInterval: 5 * time.Second,
                GroupGracePeriod:         1 * time.Minute,
                GroupMaxDelay:            0,
                GroupMaxSize:             0,
                GroupAggregator:          nil,
                DisableRedisConnClose:    true,
        }
        <span class="cov7" title="11">if len(conf.Queues) &gt; 0 </span><span class="cov7" title="9">{
                asynqCfg.Queues = make(map[string]int, len(conf.Queues))
                for _, queue := range conf.Queues </span><span class="cov7" title="9">{
                        if _, ok := asynqCfg.Queues[queue.Name]; ok </span><span class="cov0" title="0">{
                                panic(ErrDuplicatedQueueName)</span>
                        }
                        <span class="cov7" title="9">if utils.IsStrBlank(queue.Name) </span><span class="cov7" title="8">{
                                queue.Name = defaultQueue(appName)
                        }</span>
                        <span class="cov7" title="9">asynqCfg.Queues[queue.Name] = queue.Level</span>
                }
        } else<span class="cov3" title="2"> {
                asynqCfg.Queues = map[string]int{defaultQueue(appName): 3}
        }</span>

        <span class="cov7" title="11">consumer.consumer = asynq.NewServer(&amp;asynqRedisConnOpt{UniversalClient: rdsCli}, asynqCfg)
        return consumer</span>
}

func (a *asynqConsumer) Use(mws ...routerMiddleware) <span class="cov0" title="0">{
        for _, mw := range mws </span><span class="cov0" title="0">{
                a.mws = append(a.mws, a.adaptMiddleware(mw))
        }</span>
}

func (a *asynqConsumer) Handle(pattern string, fn any, _ ...utils.OptionExtender) <span class="cov3" title="2">{
        if !a.c.Consumer </span><span class="cov0" title="0">{
                a.debug(context.Background(), "cannot handle task: consumer is not enabled")
                return
        }</span>
        <span class="cov3" title="2">name := formatTaskName(a.appName, pattern)
        funcName := formatTaskName(a.appName, utils.GetFuncName(fn))

        callbackMapLock.Lock()
        defer callbackMapLock.Unlock()
        if callbackMap[a.appName] == nil </span><span class="cov1" title="1">{
                callbackMap[a.appName] = make(map[string]any)
        }</span>
        <span class="cov3" title="2">if funcNameToTaskName[a.appName] == nil </span><span class="cov1" title="1">{
                funcNameToTaskName[a.appName] = make(map[string]string)
        }</span>
        <span class="cov3" title="2">if _, ok := callbackMap[a.appName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedHandlerName)</span>
        }
        <span class="cov3" title="2">callbackMap[a.appName][name] = fn
        callbackMap[a.appName][funcName] = fn
        funcNameToTaskName[a.appName][funcName] = name

        typ, embed := wrapParams(fn)
        a.ServeMux.Handle(name, a.adaptAsynqHandlerFunc(fn, typ, embed))
        if name != funcName </span><span class="cov3" title="2">{
                a.ServeMux.Handle(funcName, a.adaptAsynqHandlerFunc(fn, typ, embed))
        }</span>
}

func (a *asynqConsumer) HandleFunc(fn any, _ ...utils.OptionExtender) <span class="cov1" title="1">{
        if !a.c.Consumer </span><span class="cov0" title="0">{
                a.debug(context.Background(), "cannot handle task: consumer is not enabled")
                return
        }</span>
        <span class="cov1" title="1">funcName := formatTaskName(a.appName, utils.GetFuncName(fn))

        callbackMapLock.Lock()
        defer callbackMapLock.Unlock()
        if callbackMap[a.appName] == nil </span><span class="cov0" title="0">{
                callbackMap[a.appName] = make(map[string]any)
        }</span>
        <span class="cov1" title="1">if funcNameToTaskName[a.appName] == nil </span><span class="cov0" title="0">{
                funcNameToTaskName[a.appName] = make(map[string]string)
        }</span>
        <span class="cov1" title="1">if _, ok := callbackMap[funcName]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedHandlerName)</span>
        }
        <span class="cov1" title="1">callbackMap[a.appName][funcName] = fn

        typ, embed := wrapParams(fn)
        a.ServeMux.Handle(funcName, a.adaptAsynqHandlerFunc(fn, typ, embed))</span>
}

func (a *asynqConsumer) Serve() (err error) <span class="cov0" title="0">{
        if !a.c.Consumer </span><span class="cov0" title="0">{
                return ErrConsumerDisabled
        }</span>
        <span class="cov0" title="0">defer a.info(context.Background(), "consumer started")

        a.ServeMux.Use(a.gatewayMiddleware)
        a.ServeMux.Use(a.mws...)
        return a.consumer.Run(a.ServeMux)</span>
}

func (a *asynqConsumer) Start() (err error) <span class="cov3" title="2">{
        if !a.c.Consumer </span><span class="cov0" title="0">{
                return ErrConsumerDisabled
        }</span>

        <span class="cov3" title="2">defer a.info(context.Background(), "consumer started")

        a.ServeMux.Use(a.gatewayMiddleware)
        a.ServeMux.Use(a.mws...)

        return a.consumer.Start(a.ServeMux)</span>
}

func (a *asynqConsumer) shutdown() (err error) <span class="cov7" title="11">{
        if a.consumer != nil </span><span class="cov7" title="11">{
                _, catchErr := utils.Catch(a.consumer.Shutdown)
                err = multierr.Append(err, errors.Cause(catchErr))
        }</span>
        <span class="cov7" title="11">return</span>
}

func (a *asynqConsumer) gatewayMiddleware(next asynq.Handler) asynq.Handler <span class="cov6" title="6">{
        return asynq.HandlerFunc(func(ctx context.Context, raw *asynq.Task) (err error) </span><span class="cov6" title="6">{
                taskName := a.unformatTaskName(raw.Type())
                inspect.SetField(raw, asyncqTaskTypenameField, taskName)
                return next.ProcessTask(ctx, raw)
        }</span>)
}

func (a *asynqConsumer) adaptMiddleware(mw routerMiddleware) asynq.MiddlewareFunc <span class="cov0" title="0">{
        return func(asynqNext asynq.Handler) asynq.Handler </span><span class="cov0" title="0">{
                next := mw(a.adaptRouterHandlerFunc(asynqNext))
                return asynq.HandlerFunc(func(ctx context.Context, t *asynq.Task) error </span><span class="cov0" title="0">{
                        return next(ctx, a.newTask(t))
                }</span>)
        }
}

func (a *asynqConsumer) adaptAsynqHandlerFunc(h any, typ reflect.Type, embed bool) asynq.HandlerFunc <span class="cov5" title="5">{
        fn := utils.WrapFunc1[error](h)
        return func(ctx context.Context, task *asynq.Task) (err error) </span><span class="cov6" title="6">{
                ctx, data, _, err := pd.Unseal(task.Payload(), pd.Type(typ))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov6" title="6">params := unwrapParams(typ, embed, data)
                return fn(append([]any{ctx}, params...)...)</span>
        }
}

func (a *asynqConsumer) adaptRouterHandlerFunc(h asynq.Handler) routerMiddlewareFunc <span class="cov0" title="0">{
        return func(ctx context.Context, raw Task) (err error) </span><span class="cov0" title="0">{
                return h.ProcessTask(ctx, a.newAsynqTask(raw))
        }</span>
}

func (a *asynqConsumer) unformatTaskName(taskName string) (result string) <span class="cov6" title="6">{
        return strings.TrimPrefix(taskName, fmt.Sprintf("%s:async:", config.Use(a.appName).AppName()))
}</span>

func (a *asynqConsumer) newTask(raw *asynq.Task) (t Task) <span class="cov0" title="0">{
        return &amp;task{
                id:         raw.Type(),
                name:       raw.Type(),
                payload:    raw.Payload(),
                rawMessage: raw,
        }
}</span>

func (a *asynqConsumer) newAsynqTask(raw Task) (t *asynq.Task) <span class="cov0" title="0">{
        return raw.RawMessage().(*asynq.Task)
}</span>

type asynqProducer struct {
        *asynq.Client

        appName string
        n       string
        c       *Conf

        compressType  compress.Algorithm
        serializeType serialize.Algorithm
}

func newAsynqProducer(ctx context.Context, appName, name string, conf *Conf) Producable <span class="cov7" title="11">{
        var rdsCli rdsDrv.UniversalClient
        switch conf.InstanceType </span>{
        case instanceTypeRedis:<span class="cov7" title="11">
                rdsCli = redis.Use(ctx, conf.Instance, redis.AppName(appName))</span>
        case instanceTypeDB:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unknown instance type: %s", conf.InstanceType))</span>
        }

        <span class="cov7" title="11">producer := &amp;asynqProducer{
                appName:       appName,
                n:             name,
                c:             conf,
                Client:        asynq.NewClient(&amp;asynqRedisConnOpt{UniversalClient: rdsCli}),
                compressType:  compress.ParseAlgorithm(conf.MessageCompressType),
                serializeType: serialize.ParseAlgorithm(conf.MessageSerializeType),
        }
        // default serialize type
        if !producer.serializeType.IsValid() </span><span class="cov0" title="0">{
                producer.serializeType = serialize.AlgorithmGob
        }</span>
        <span class="cov7" title="11">return producer</span>
}

func (a *asynqProducer) Go(fn any, opts ...utils.OptionExtender) (err error) <span class="cov3" title="2">{
        var data any
        opt := utils.ApplyOptions[produceOption](opts...)
        if len(opt.args) &gt; 0 </span><span class="cov3" title="2">{
                argType, embed := wrapParams(fn)
                data = setParams(argType, embed, opt.args...)
        }</span>

        // get task name by func name
        <span class="cov3" title="2">funcName := formatTaskName(a.appName, utils.GetFuncName(fn))
        callbackMapLock.RLock()
        if mappingName, ok := funcNameToTaskName[a.appName][funcName]; ok </span><span class="cov3" title="2">{
                funcName = mappingName
        }</span>
        <span class="cov3" title="2">callbackMapLock.RUnlock()

        ctx := context.Background()
        task, err := a.newTask(ctx, funcName, data)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">_, err = a.Client.EnqueueContext(ctx, task, a.parseOption(opt)...)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="2">return</span>
}

func (a *asynqProducer) Goc(ctx context.Context, fn any, opts ...utils.OptionExtender) (err error) <span class="cov3" title="2">{
        var data any
        opt := utils.ApplyOptions[produceOption](opts...)
        if len(opt.args) &gt; 0 </span><span class="cov3" title="2">{
                argType, embed := wrapParams(fn)
                data = setParams(argType, embed, opt.args...)
        }</span>

        // get task name by func name
        <span class="cov3" title="2">funcName := formatTaskName(a.appName, utils.GetFuncName(fn))
        callbackMapLock.RLock()
        if mappingName, ok := funcNameToTaskName[a.appName][funcName]; ok </span><span class="cov0" title="0">{
                funcName = mappingName
        }</span>
        <span class="cov3" title="2">callbackMapLock.RUnlock()

        task, err := a.newTask(ctx, funcName, data)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">_, err = a.Client.EnqueueContext(ctx, task, a.parseOption(opt)...)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="2">return</span>
}

func (a *asynqProducer) Send(ctx context.Context, taskName string, data any, opts ...utils.OptionExtender) (err error) <span class="cov3" title="2">{
        opt := utils.ApplyOptions[produceOption](opts...)
        task, err := a.newTask(ctx, formatTaskName(a.appName, taskName), data)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">_, err = a.Client.EnqueueContext(ctx, task, a.parseOption(opt)...)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="2">return</span>
}

func (a *asynqProducer) parseOption(src *produceOption) (dst []asynq.Option) <span class="cov6" title="6">{
        if utils.IsStrNotBlank(src.id) </span><span class="cov0" title="0">{
                dst = append(dst, asynq.TaskID(src.id))
        }</span>
        <span class="cov6" title="6">if utils.IsStrNotBlank(src.queue) </span><span class="cov3" title="2">{
                dst = append(dst, asynq.Queue(src.queue))
        }</span> else<span class="cov5" title="4"> if len(a.c.Queues) == 1 </span><span class="cov0" title="0">{
                dst = append(dst, asynq.Queue(a.c.Queues[0].Name))
        }</span> else<span class="cov5" title="4"> {
                dst = append(dst, asynq.Queue(defaultQueue(a.appName)))
        }</span>
        <span class="cov6" title="6">if src.maxRetry &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, asynq.MaxRetry(src.maxRetry))
        }</span>
        <span class="cov6" title="6">if !src.deadline.IsZero() </span><span class="cov0" title="0">{
                dst = append(dst, asynq.Deadline(src.deadline))
        }</span>
        <span class="cov6" title="6">if src.timeout &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, asynq.Timeout(src.timeout))
        }</span>
        <span class="cov6" title="6">if src.delayDuration &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, asynq.ProcessIn(src.timeout))
        }</span>
        <span class="cov6" title="6">if !src.delayTime.IsZero() </span><span class="cov0" title="0">{
                dst = append(dst, asynq.ProcessAt(src.delayTime))
        }</span>
        <span class="cov6" title="6">if src.retentionDuration &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, asynq.Retention(src.retentionDuration))
        }</span>

        <span class="cov6" title="6">return</span>
}

func (a *asynqProducer) newTask(ctx context.Context, taskName string, data any) (task *asynq.Task, err error) <span class="cov6" title="6">{
        payload, err := pd.Seal(data, pd.Context(ctx), pd.Serialize(a.serializeType), pd.Compress(a.compressType))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="6">task = asynq.NewTask(taskName, payload)
        return</span>
}

type asynqRedisConnOpt struct{ rdsDrv.UniversalClient }

func (a *asynqRedisConnOpt) MakeRedisClient() any <span class="cov10" title="22">{ return a.UniversalClient }</span>

func formatTaskName(appName, taskName string) (result string) <span class="cov7" title="11">{
        return fmt.Sprintf("%s:async:%s", config.Use(appName).AppName(), taskName)
}</span>

func defaultQueue(appName string) (result string) <span class="cov8" title="14">{
        return fmt.Sprintf("%s:async", config.Use(appName).AppName())
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package async

import (
        "context"
        "log"
        "sync"
        "syscall"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
)

var (
        locker    sync.RWMutex
        consumers = map[string]map[string]Consumable{}
        producers = map[string]map[string]Producable{}
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov4" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov2" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov4" title="34">for name, conf := range confs </span><span class="cov3" title="11">{
                addInstance(ctx, name, conf, opt)
        }</span>
        <span class="cov4" title="34">return func() </span><span class="cov4" title="34">{
                locker.Lock()
                defer locker.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                if consumers != nil </span><span class="cov4" title="34">{
                        for name, router := range consumers[opt.AppName] </span><span class="cov3" title="11">{
                                log.Printf("%v [Gofusion] %s %s %s exiting...", pid, app, config.ComponentAsync, name)
                                if err := router.shutdown(); err == nil </span><span class="cov3" title="11">{
                                        log.Printf("%v [Gofusion] %s %s %s exited", pid, app, config.ComponentAsync, name)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("%v [Gofusion] %s %s %s exit failed: %s", pid, app, config.ComponentAsync, name, err)
                                }</span>
                        }
                        <span class="cov4" title="34">delete(consumers, opt.AppName)</span>
                }

                <span class="cov4" title="34">if producers != nil </span><span class="cov4" title="34">{
                        producers[opt.AppName] = make(map[string]Producable, len(producers))
                }</span>
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov3" title="11">{
        var (
                producer Producable
                consumer Consumable
        )
        switch conf.Type </span>{
        case asyncTypeAsynq:<span class="cov3" title="11">
                if conf.Producer </span><span class="cov3" title="11">{
                        producer = newAsynqProducer(ctx, opt.AppName, name, conf)
                }</span>
                <span class="cov3" title="11">if conf.Consumer </span><span class="cov3" title="11">{
                        consumer = newAsynqConsumer(ctx, opt.AppName, name, conf)
                }</span>
        case asyncTypeMysql:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                panic(ErrUnsupportedSchedulerType)</span>
        }

        <span class="cov3" title="11">locker.Lock()
        defer locker.Unlock()
        if consumer != nil </span><span class="cov3" title="11">{
                if consumers == nil </span><span class="cov0" title="0">{
                        consumers = make(map[string]map[string]Consumable)
                }</span>
                <span class="cov3" title="11">if consumers[opt.AppName] == nil </span><span class="cov3" title="10">{
                        consumers[opt.AppName] = make(map[string]Consumable)
                }</span>
                <span class="cov3" title="11">if _, ok := consumers[name]; ok </span><span class="cov0" title="0">{
                        panic(ErrDuplicatedInstanceName)</span>
                }
                <span class="cov3" title="11">consumers[opt.AppName][name] = consumer

                // ioc
                if opt.DI != nil </span><span class="cov3" title="11">{
                        opt.DI.MustProvide(
                                func() Consumable </span><span class="cov0" title="0">{ return C(name, AppName(opt.AppName)) }</span>,
                                di.Name(name),
                        )
                }
        }

        <span class="cov3" title="11">if producer != nil </span><span class="cov3" title="11">{
                if producers == nil </span><span class="cov0" title="0">{
                        producers = make(map[string]map[string]Producable)
                }</span>
                <span class="cov3" title="11">if producers[opt.AppName] == nil </span><span class="cov2" title="3">{
                        producers[opt.AppName] = make(map[string]Producable)
                }</span>
                <span class="cov3" title="11">if _, ok := producers[name]; ok </span><span class="cov0" title="0">{
                        panic(ErrDuplicatedInstanceName)</span>
                }
                <span class="cov3" title="11">producers[opt.AppName][name] = producer

                // ioc
                if opt.DI != nil </span><span class="cov3" title="11">{
                        opt.DI.MustProvide(
                                func() Producable </span><span class="cov0" title="0">{ return P(name) }</span>,
                                di.Name(name),
                        )
                }
        }
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov10" title="3863">{
        return func(o *useOption) </span><span class="cov9" title="3628">{
                o.appName = name
        }</span>
}

func C(name string, opts ...utils.OptionExtender) Consumable <span class="cov9" title="1870">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        consumers, ok := consumers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("async consumer instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov9" title="1979">consumer, ok := consumers[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("async consumer instance not found for name: %s", name))</span>
        }
        <span class="cov9" title="1987">return consumer</span>
}

func P(name string, opts ...utils.OptionExtender) Producable <span class="cov9" title="1910">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        producers, ok := producers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("async producer instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov9" title="2002">producer, ok := producers[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("async producer instance not found for name: %s", name))</span>
        }
        <span class="cov9" title="2002">return producer</span>
}

func init() <span class="cov3" title="14">{
        config.AddComponent(config.ComponentAsync, Construct)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package async

import (
        "context"
        "fmt"
        "log"
        "syscall"

        "github.com/wfusion/gofusion/config"
)

func (a *asynqConsumer) debug(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        msg = a.format(msg)
        if a.logger == nil </span><span class="cov0" title="0">{
                log.Printf(msg, args...)
        }</span> else<span class="cov0" title="0"> {
                logArgs := make([]any, 0, len(args)+2)
                logArgs = append(logArgs, ctx, msg)
                logArgs = append(logArgs, args...)
                a.logger.Debug(logArgs...)
        }</span>
}

func (a *asynqConsumer) info(ctx context.Context, msg string, args ...any) <span class="cov10" title="2">{
        msg = a.format(msg)
        if a.logger == nil </span><span class="cov0" title="0">{
                log.Printf(msg, args...)
        }</span> else<span class="cov10" title="2"> {
                logArgs := make([]any, 0, len(args)+2)
                logArgs = append(logArgs, ctx, msg)
                logArgs = append(logArgs, args...)
                a.logger.Info(logArgs...)
        }</span>
}

func (a *asynqConsumer) warn(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        msg = a.format(msg)
        if a.logger == nil </span><span class="cov0" title="0">{
                log.Printf(msg, args...)
        }</span> else<span class="cov0" title="0"> {
                logArgs := make([]any, 0, len(args)+2)
                logArgs = append(logArgs, ctx, msg)
                logArgs = append(logArgs, args...)
                a.logger.Warn(logArgs...)
        }</span>
}

func (a *asynqConsumer) format(src string) (dst string) <span class="cov10" title="2">{
        return fmt.Sprintf("%v [Gofusion] %s %s asynq %s",
                syscall.Getpid(), config.ComponentAsync, a.n, src)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package async

import (
        "context"
        "reflect"
        "sync"
        "time"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/log"
)

const (
        ErrDuplicatedHandlerName    utils.Error = "duplicated async handler name"
        ErrDuplicatedInstanceName   utils.Error = "duplicated async instance name"
        ErrDuplicatedQueueName      utils.Error = "duplicated async queue name"
        ErrConsumerDisabled         utils.Error = "async consumer is disabled"
        ErrUnsupportedSchedulerType utils.Error = "unsupported async type"
)

var (
        // callbackMap taskName:callback function
        funcNameToTaskName = map[string]map[string]string{}
        callbackMap        = map[string]map[string]any{}
        callbackMapLock    = sync.RWMutex{}

        customLoggerType = reflect.TypeOf((*customLogger)(nil)).Elem()
)

type Producable interface {
        Go(fn any, opts ...utils.OptionExtender) error
        Goc(ctx context.Context, fn any, opts ...utils.OptionExtender) error
        Send(ctx context.Context, taskName string, data any, opts ...utils.OptionExtender) (err error)
}

type Consumable interface {
        Use(mws ...routerMiddleware)
        Handle(pattern string, fn any, opts ...utils.OptionExtender)
        HandleFunc(fn any, opts ...utils.OptionExtender)
        Serve() error
        Start() error
        shutdown() error
}

type Task interface {
        ID() string
        Name() string
        Payload() []byte
        RawMessage() any
}

// Conf async conf
//nolint: revive // struct tag too long issue
type Conf struct {
        Type                 asyncType    `yaml:"type" json:"type" toml:"type"`
        Instance             string       `yaml:"instance" json:"instance" toml:"instance"`
        InstanceType         instanceType `yaml:"instance_type" json:"instance_type" toml:"instance_type"`
        Producer             bool         `yaml:"producer" json:"producer" toml:"producer" default:"true"`
        Consumer             bool         `yaml:"consumer" json:"consumer" toml:"consumer" default:"false"`
        ConsumerConcurrency  int          `yaml:"consumer_concurrency" json:"consumer_concurrency" toml:"consumer_concurrency"`
        MessageSerializeType string       `yaml:"message_serialize_type" json:"message_serialize_type" toml:"message_serialize_type" default:"gob"`
        MessageCompressType  string       `yaml:"message_compress_type" json:"message_compress_type" toml:"message_compress_type"`
        Queues               []*queueConf `yaml:"queues" json:"queues" toml:"queues"`
        StrictPriority       bool         `yaml:"strict_priority" json:"strict_priority" toml:"strict_priority"`

        EnableLogger bool   `yaml:"enable_logger" json:"enable_logger" toml:"enable_logger" default:"false"`
        LogLevel     string `yaml:"log_level" json:"log_level" toml:"log_level" default:"info"`
        Logger       string `yaml:"logger" json:"logger" toml:"logger" default:"github.com/wfusion/gofusion/log/customlogger.asyncLogger"`
        LogInstance  string `yaml:"log_instance" json:"log_instance" toml:"log_instance" default:"default"`
}

type queueConf struct {
        Name  string `yaml:"name" json:"name" toml:"name"`
        Level int    `yaml:"level" json:"level" toml:"level"`
}

type instanceType string

const (
        instanceTypeRedis instanceType = "redis"
        instanceTypeDB    instanceType = "db"
)

type task struct {
        id, name   string
        payload    []byte
        rawMessage any
}

func (t *task) ID() string <span class="cov0" title="0">{
        return t.id
}</span>

func (t *task) Name() string <span class="cov0" title="0">{
        return t.name
}</span>

func (t *task) Payload() []byte <span class="cov0" title="0">{
        return t.payload
}</span>

func (t *task) RawMessage() any <span class="cov0" title="0">{
        return t.rawMessage
}</span>

type produceOption struct {
        id                string
        args              []any
        queue             string
        maxRetry          int
        deadline          time.Time
        timeout           time.Duration
        delayDuration     time.Duration
        delayTime         time.Time
        retentionDuration time.Duration
}

func TaskID(id string) utils.OptionFunc[produceOption] <span class="cov0" title="0">{
        return func(o *produceOption) </span><span class="cov0" title="0">{ o.id = id }</span>
}
func Args(args ...any) utils.OptionFunc[produceOption] <span class="cov10" title="4">{
        return func(o *produceOption) </span><span class="cov10" title="4">{ o.args = append(o.args, args...) }</span>
}
func Queue(queue string) utils.OptionFunc[produceOption] <span class="cov5" title="2">{
        return func(o *produceOption) </span><span class="cov5" title="2">{ o.queue = queue }</span>
}
func MaxRetry(n int) utils.OptionFunc[produceOption] <span class="cov0" title="0">{
        return func(o *produceOption) </span><span class="cov0" title="0">{ o.maxRetry = n }</span>
}
func Deadline(t time.Time) utils.OptionFunc[produceOption] <span class="cov0" title="0">{
        return func(o *produceOption) </span><span class="cov0" title="0">{ o.deadline = t }</span>
}
func Timeout(d time.Duration) utils.OptionFunc[produceOption] <span class="cov0" title="0">{
        return func(o *produceOption) </span><span class="cov0" title="0">{ o.timeout = d }</span>
}
func Delay(d time.Duration) utils.OptionFunc[produceOption] <span class="cov0" title="0">{
        return func(o *produceOption) </span><span class="cov0" title="0">{ o.delayDuration = d }</span>
}
func DelayAt(t time.Time) utils.OptionFunc[produceOption] <span class="cov0" title="0">{
        return func(o *produceOption) </span><span class="cov0" title="0">{ o.delayTime = t }</span>
}
func Retention(d time.Duration) utils.OptionFunc[produceOption] <span class="cov0" title="0">{
        return func(o *produceOption) </span><span class="cov0" title="0">{ o.retentionDuration = d }</span>
}

type asyncType string

const (
        asyncTypeAsynq asyncType = "asynq"
        asyncTypeMysql asyncType = "mysql"
)

type routerMiddlewareFunc func(ctx context.Context, task Task) (err error)

type routerMiddleware func(next routerMiddlewareFunc) routerMiddlewareFunc

type customLogger interface {
        Init(log log.Logable, appName, name string)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package async

import (
        "fmt"
        "reflect"
)

func wrapParams(fn any) (argType reflect.Type, embed bool) <span class="cov6" title="7">{
        typ := reflect.TypeOf(fn)

        inLength := typ.NumIn()
        if inLength == 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="7">if inLength == 2 </span><span class="cov1" title="1">{
                return typ.In(1), false
        }</span>

        <span class="cov6" title="6">fields := make([]reflect.StructField, 0, inLength)
        for i := 1; i &lt; inLength; i++ </span><span class="cov10" title="24">{
                fields = append(fields, reflect.StructField{
                        Name:      fmt.Sprintf("Arg%X", i+1),
                        PkgPath:   "",
                        Type:      typ.In(i),
                        Tag:       "",
                        Offset:    0,
                        Index:     nil,
                        Anonymous: false,
                })
        }</span>

        <span class="cov6" title="6">return reflect.StructOf(fields), true</span>
}

func unwrapParams(typ reflect.Type, embed bool, arg any) (params []any) <span class="cov6" title="6">{
        if typ == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="6">if !embed </span><span class="cov2" title="2">{
                return []any{arg}
        }</span>

        <span class="cov4" title="4">argVal := reflect.Indirect(reflect.ValueOf(arg))
        num := argVal.Type().NumField()
        params = make([]any, 0, num)
        for i := 0; i &lt; num; i++ </span><span class="cov8" title="16">{
                params = append(params, argVal.Field(i).Interface())
        }</span>

        <span class="cov4" title="4">return</span>
}

func setParams(typ reflect.Type, embed bool, params ...any) (arg any) <span class="cov4" title="4">{
        if typ == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="4">argValPtr := reflect.New(typ)
        argVal := argValPtr.Elem()
        if !embed </span><span class="cov0" title="0">{
                if len(params) &gt; 0 </span><span class="cov0" title="0">{
                        argVal.Set(reflect.ValueOf(params[0]))
                }</span>
                <span class="cov0" title="0">return argValPtr.Interface()</span>
        }

        <span class="cov4" title="4">for i := 0; i &lt; len(params); i++ </span><span class="cov8" title="16">{
                ft := argVal.Field(i)
                ft.Set(reflect.ValueOf(params[i]).Convert(ft.Type()))
        }</span>
        <span class="cov4" title="4">return argValPtr.Interface()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cache

import (
        "context"
        "fmt"
        "strings"
        "syscall"
        "time"

        "github.com/pkg/errors"
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/constraint"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/common/utils/serialize"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"

        pd "github.com/wfusion/gofusion/internal/util/payload"
)

type provider interface {
        get(ctx context.Context, keys ...string) (cached map[string]any, missed []string)
        set(ctx context.Context, kvs map[string]any, expired map[string]time.Duration) (failure []string)
        del(ctx context.Context, keys ...string) (failure []string)
}

type parsedConf[K constraint.Sortable, T any] struct {
        size    int
        expired time.Duration
        version int

        cacheType      cacheType
        remoteType     remoteType
        remoteInstance string
        localEvictType string
        serializeType  serialize.Algorithm
        compressType   compress.Algorithm

        log      log.Logable
        callback callback[K, T]
}

type initOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[initOption] <span class="cov3" title="27">{
        return func(o *initOption) </span><span class="cov3" title="27">{
                o.appName = name
        }</span>
}

func New[K constraint.Sortable, T any, TS ~[]T](name string, opts ...utils.OptionExtender) Cachable[K, T, TS] <span class="cov3" title="27">{
        opt := utils.ApplyOptions[initOption](opts...)

        instance := &amp;cache[K, T, TS]{
                name:    name,
                appName: opt.appName,
                prefix:  fmt.Sprintf("%s:%s", config.Use(opt.appName).AppName(), name),
                visited: utils.NewSet[string](),
        }

        conf := instance.getConfig()
        switch conf.cacheType </span>{
        case cacheTypeLocal:<span class="cov3" title="17">
                instance.provider = newGCache(conf.size, conf.localEvictType, conf.log)</span>
        case cacheTypeRemote:<span class="cov3" title="10">
                if conf.remoteType != remoteTypeRedis </span><span class="cov0" title="0">{
                        panic(UnknownRemoteType)</span>
                }
                <span class="cov3" title="10">if !conf.serializeType.IsValid() &amp;&amp; !conf.compressType.IsValid() </span><span class="cov0" title="0">{
                        panic(UnknownSerializeType)</span>
                }
                <span class="cov3" title="10">instance.provider = newRedis(opt.appName, conf.remoteInstance, conf.log)</span>
        case cacheTypeRemoteLocal:<span class="cov0" title="0">
                panic(ErrNotImplement)</span>
        default:<span class="cov0" title="0">
                panic(UnknownCacheType)</span>
        }

        <span class="cov3" title="27">return instance</span>
}

type cache[K constraint.Sortable, T any, TS ~[]T] struct {
        appName  string
        name     string
        prefix   string
        provider provider
        visited  *utils.Set[string]
}

func (c *cache[K, T, TS]) Get(ctx context.Context, keys []K, cb callback[K, T]) (ts TS) <span class="cov8" title="2322">{
        conf := c.getConfig()
        innerKeys := c.convKeysToInner(keys, conf.version)
        cached, missed := c.provider.get(ctx, innerKeys...)
        kvs, _ := c.convInnerToMap(ctx, cached, conf)
        defer c.visited.Insert(innerKeys...)

        if cb == nil </span><span class="cov5" title="100">{
                cb = conf.callback
        }</span>
        <span class="cov8" title="2323">if len(missed) &gt; 0 &amp;&amp; cb != nil </span><span class="cov7" title="1312">{
                keys := c.convInnerToKeys(missed, conf.version)
                if conf.log != nil </span><span class="cov7" title="1312">{
                        conf.log.Debug(ctx, "%v [Gofusion] %s call callback function because we do not hit the cache "+
                                "when get [keys%+v]", syscall.Getpid(), config.ComponentCache, keys)
                }</span>

                <span class="cov7" title="1312">callbackKVs, opts := cb(ctx, keys)
                kvs = utils.MapMerge(kvs, callbackKVs)
                innerVals, _ := c.convMapToInner(ctx, callbackKVs, conf)
                _ = c.provider.set(ctx, innerVals, c.parseCallbackOption(kvs, conf, opts...))</span>
                // innerFailureKeys = append(innerFailureKeys, convInnerFailureKeys...)
        }

        // order by param -&gt; keys
        <span class="cov8" title="2323">ts = make(TS, 0, len(kvs))
        missedKeys := make([]K, 0, len(keys))
        for _, k := range keys </span><span class="cov8" title="6243">{
                v, ok := kvs[k]
                if !ok </span><span class="cov0" title="0">{
                        missedKeys = append(missedKeys, k)
                        continue</span>
                }

                <span class="cov8" title="6245">ts = append(ts, v)</span>
        }
        <span class="cov8" title="2322">if len(missedKeys) &gt; 0 &amp;&amp; conf.log != nil </span><span class="cov0" title="0">{
                conf.log.Info(ctx, "%v [Gofusion] %s we still get missing keys after callback when cache get [keys%v]",
                        syscall.Getpid(), config.ComponentCache, missedKeys)
        }</span>

        <span class="cov8" title="2322">return</span>
}

func (c *cache[K, T, TS]) GetAll(ctx context.Context, cb callback[K, T]) (ts TS) <span class="cov1" title="1">{
        conf := c.getConfig()
        allInnerKeys := c.visited.Items()
        cached, missed := c.provider.get(ctx, allInnerKeys...)
        kvs, _ := c.convInnerToMap(ctx, cached, conf)
        if len(missed) &gt; 0 &amp;&amp; (cb != nil || conf.callback != nil) </span><span class="cov0" title="0">{
                keys := c.convInnerToKeys(missed, conf.version)
                if conf.log != nil </span><span class="cov0" title="0">{
                        conf.log.Info(ctx, "%v [Gofusion] %s call callback function because we do not hit the cache "+
                                "when get all [keys%+v]", syscall.Getpid(), config.ComponentCache, keys)
                }</span>

                <span class="cov0" title="0">var (
                        callbackKVs map[K]T
                        opts        []utils.OptionExtender
                )
                if cb != nil </span><span class="cov0" title="0">{
                        callbackKVs, opts = cb(ctx, keys)
                }</span> else<span class="cov0" title="0"> {
                        callbackKVs, opts = conf.callback(ctx, keys)
                }</span>

                <span class="cov0" title="0">kvs = utils.MapMerge(kvs, callbackKVs)

                innerVals, _ := c.convMapToInner(ctx, callbackKVs, conf)
                c.provider.set(ctx, innerVals, c.parseCallbackOption(kvs, conf, opts...))</span>
        }

        // order by param -&gt; keys
        <span class="cov1" title="1">ts = make(TS, 0, len(kvs))
        missedKeys := make([]K, 0, len(allInnerKeys))
        for _, k := range c.convInnerToKeys(allInnerKeys, conf.version) </span><span class="cov3" title="15">{
                v, ok := kvs[k]
                if !ok </span><span class="cov3" title="14">{
                        missedKeys = append(missedKeys, k)
                        continue</span>
                }

                <span class="cov1" title="1">ts = append(ts, v)</span>
        }
        <span class="cov1" title="1">c.visited.Remove(c.convKeysToInner(missedKeys, conf.version)...)
        if len(missedKeys) &gt; 0 &amp;&amp; conf.log != nil </span><span class="cov1" title="1">{
                conf.log.Warn(ctx, "%v [Gofusion] %s index key value failed when cache get all [keys%v]",
                        syscall.Getpid(), config.ComponentCache, missedKeys)
        }</span>

        <span class="cov1" title="1">return</span>
}

func (c *cache[K, T, TS]) Set(ctx context.Context, kvs map[K]T, opts ...utils.OptionExtender) (failure []K) <span class="cov8" title="2312">{
        conf := c.getConfig()
        innerVals, innerFailureKeys := c.convMapToInner(ctx, kvs, conf)
        defer func() </span><span class="cov8" title="2311">{
                innerKeys := utils.MapKeys(innerVals)
                c.visited.Insert(innerKeys...)
        }</span>()

        <span class="cov8" title="2312">innerFailureKeys = append(
                innerFailureKeys,
                c.provider.set(ctx, innerVals, c.parseCallbackOption(kvs, conf, opts...))...,
        )

        if failure = c.convInnerToKeys(innerFailureKeys, conf.version); len(failure) &gt; 0 &amp;&amp; conf.log != nil </span><span class="cov0" title="0">{
                conf.log.Info(ctx, "%v [Gofusion] %s set some kvs failed when set [keys%+v vals%+v]",
                        syscall.Getpid(), config.ComponentCache, failure, utils.MapValuesByKeys(kvs, failure))
        }</span>

        <span class="cov8" title="2312">return</span>
}

func (c *cache[K, T, TS]) Del(ctx context.Context, keys ...K) (failure []K) <span class="cov2" title="6">{
        conf := c.getConfig()
        innerKeys := c.convKeysToInner(keys, conf.version)
        innerFailureKeys := c.provider.del(ctx, innerKeys...)
        defer c.visited.Remove(innerKeys...)

        if failure = c.convInnerToKeys(innerFailureKeys, conf.version); len(failure) &gt; 0 &amp;&amp; conf.log != nil </span><span class="cov0" title="0">{
                conf.log.Info(ctx, "%v [Gofusion] %s del some kvs failed when del [keys%+v]",
                        syscall.Getpid(), config.ComponentCache, failure)
        }</span>
        <span class="cov2" title="6">return</span>
}

func (c *cache[K, T, TS]) Clear(ctx context.Context) (failureKeys []K) <span class="cov4" title="29">{
        conf := c.getConfig()
        innerKeys := c.visited.Items()
        innerFailureKeys := c.provider.del(ctx, innerKeys...)
        defer c.visited.Remove(innerKeys...)

        if failureKeys = c.convInnerToKeys(innerFailureKeys, conf.version); len(failureKeys) &gt; 0 &amp;&amp; conf.log != nil </span><span class="cov0" title="0">{
                conf.log.Info(ctx, "%v [Gofusion] %s del some kvs failed when clear [keys%+v]",
                        syscall.Getpid(), config.ComponentCache, failureKeys)
        }</span>
        <span class="cov4" title="29">return</span>
}

func (c *cache[K, T, TS]) convKeysToInner(keys []K, version int) (inner []string) <span class="cov8" title="2329">{
        return utils.SliceMapping(keys, func(k K) string </span><span class="cov8" title="6272">{
                return c.convKeyToInner(k, version)
        }</span>)
}

func (c *cache[K, T, TS]) convKeyToInner(k K, ver int) (inner string) <span class="cov10" title="20177">{
        return fmt.Sprintf("%s:%v:%s", c.prefix, ver, cast.ToString(k))
}</span>

func (c *cache[K, T, TS]) convInnerToKeys(innerKeys []string, ver int) (keys []K) <span class="cov8" title="3659">{
        return utils.SliceMapping(innerKeys, func(inner string) K </span><span class="cov8" title="3937">{
                return c.convInnerToKey(inner, ver)
        }</span>)
}

func (c *cache[K, T, TS]) convInnerToKey(inner string, ver int) (k K) <span class="cov8" title="6262">{
        key := strings.TrimPrefix(inner, fmt.Sprintf("%s:%v:", c.prefix, ver))
        return utils.SortableToGeneric[string, K](key)
}</span>

func (c *cache[K, T, TS]) convMapToInner(ctx context.Context, kvs map[K]T, conf *parsedConf[K, T]) (
        inner map[string]any, innerFailureKeys []string) <span class="cov8" title="3622">{
        inner = make(map[string]any, len(kvs))
        for k, v := range kvs </span><span class="cov8" title="6300">{
                innerKey := c.convKeyToInner(k, conf.version)
                innerVal, err := c.convValToInner(v, conf)
                if err != nil </span><span class="cov0" title="0">{
                        if conf.log != nil </span><span class="cov0" title="0">{
                                conf.log.Info(ctx, "%v [Gofusion] %s convert value to inner failed [err[%s] key[%+v] val[%+v]]",
                                        syscall.Getpid(), config.ComponentCache, err, k, v)
                        }</span>
                        <span class="cov0" title="0">innerFailureKeys = append(innerFailureKeys, innerKey)
                        continue</span>
                }
                <span class="cov8" title="6302">inner[innerKey] = innerVal</span>
        }
        <span class="cov8" title="3624">return</span>
}

func (c *cache[K, T, TS]) convValToInner(src T, conf *parsedConf[K, T]) (dst any, err error) <span class="cov8" title="6301">{
        if !conf.serializeType.IsValid() &amp;&amp; !conf.compressType.IsValid() </span><span class="cov6" title="471">{
                return c.cloneVal(src), nil
        }</span>

        <span class="cov8" title="5831">return c.seal(src, conf)</span>
}

func (c *cache[K, T, TS]) convInnerToMap(ctx context.Context, inner map[string]any, conf *parsedConf[K, T]) (
        kvs map[K]T, innerFailureKeys []string) <span class="cov8" title="2324">{
        kvs = make(map[K]T, len(inner))
        for k, v := range inner </span><span class="cov8" title="2326">{
                innerKey := c.convInnerToKey(k, conf.version)
                innerVal, err := c.convInnerToVal(v)
                if err != nil </span><span class="cov0" title="0">{
                        if conf.log != nil </span><span class="cov0" title="0">{
                                conf.log.Info(ctx, "%v [Gofusion] %s convert inner to value failed [err[%s] key[%+v] val[%+v]]",
                                        syscall.Getpid(), config.ComponentCache, err, innerKey, v)
                        }</span>
                        <span class="cov0" title="0">innerFailureKeys = append(innerFailureKeys, k)
                        continue</span>
                }
                <span class="cov8" title="2326">kvs[innerKey] = innerVal</span>
        }
        <span class="cov8" title="2324">return</span>
}

func (c *cache[K, T, TS]) convInnerToVal(src any) (dst T, err error) <span class="cov8" title="2325">{
        srcBytes, ok1 := src.([]byte)
        srcString, ok2 := src.(string)
        if !ok1 &amp;&amp; !ok2 </span><span class="cov5" title="117">{
                return c.cloneVal(src.(T)), nil
        }</span>
        <span class="cov7" title="2208">if ok2 </span><span class="cov7" title="1008">{
                buffer, cb := utils.BytesBufferPool.Get(nil)
                defer cb()
                buffer.WriteString(srcString)
                srcBytes = buffer.Bytes()
        }</span>
        <span class="cov7" title="2209">dst, ok, err := c.unseal(srcBytes)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov7" title="2209">if !ok </span><span class="cov0" title="0">{
                return c.cloneVal(src.(T)), nil
        }</span>
        <span class="cov7" title="2209">return</span>
}

func (c *cache[K, T, TS]) parseCallbackOption(kvs map[K]T, conf *parsedConf[K, T], opts ...utils.OptionExtender) (
        exp map[string]time.Duration) <span class="cov8" title="3624">{
        opt := utils.ApplyOptions[option[K]](opts...)
        exp = make(map[string]time.Duration, len(kvs))

        // opt.keyExpired &gt; opt.expired &gt; conf.expired
        if conf.expired &gt; 0 </span><span class="cov8" title="3624">{
                for k := range kvs </span><span class="cov9" title="7606">{
                        innerKey := c.convKeyToInner(k, conf.version)
                        exp[innerKey] = conf.expired
                }</span>
        }

        <span class="cov8" title="3624">if opt.expired &gt; 0 </span><span class="cov1" title="1">{
                for k := range kvs </span><span class="cov1" title="1">{
                        innerKey := c.convKeyToInner(k, conf.version)
                        exp[innerKey] = conf.expired
                }</span>
        }

        <span class="cov8" title="3624">for k, e := range opt.keyExpired </span><span class="cov1" title="1">{
                exp[c.convKeyToInner(k, conf.version)] = e
        }</span>

        <span class="cov8" title="3624">return</span>
}

func (c *cache[K, T, TS]) seal(src T, conf *parsedConf[K, T]) (dst []byte, err error) <span class="cov8" title="5831">{
        return pd.Seal(src, pd.Serialize(conf.serializeType), pd.Compress(conf.compressType))
}</span>

func (c *cache[K, T, TS]) unseal(src []byte) (dst T, ok bool, err error) <span class="cov7" title="2209">{
        _, dst, ok, err = pd.UnsealT[T](src)
        return
}</span>

func (c *cache[K, T, TS]) cloneVal(src T) (dst T) <span class="cov6" title="588">{
        if cl, ok := any(src).(clone.Clonable[T]); ok </span><span class="cov0" title="0">{
                dst = cl.Clone()
                return
        }</span>
        <span class="cov6" title="588">return clone.Slowly(src)</span>
}

func (c *cache[K, T, TS]) getConfig() (conf *parsedConf[K, T]) <span class="cov8" title="4698">{
        var cfgs map[string]*Conf
        _ = config.Use(c.appName).LoadComponentConfig(config.ComponentCache, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov0" title="0">{
                panic(ErrCacheNotFound)</span>
        }

        <span class="cov8" title="4698">cfg, ok := cfgs[c.name]
        if !ok </span><span class="cov0" title="0">{
                panic(ErrCacheNotFound)</span>
        }

        <span class="cov8" title="4698">conf = &amp;parsedConf[K, T]{
                size:           cfg.Size,
                localEvictType: cfg.LocalEvictType,
                cacheType:      cfg.CacheType,
                remoteType:     cfg.RemoteType,
                remoteInstance: cfg.RemoteInstance,
                version:        cfg.Version,
        }
        if utils.IsStrNotBlank(cfg.Expired) </span><span class="cov8" title="4698">{
                conf.expired = utils.Must(time.ParseDuration(cfg.Expired))
        }</span>
        <span class="cov8" title="4697">if utils.IsStrNotBlank(cfg.LogInstance) </span><span class="cov8" title="4697">{
                conf.log = log.Use(cfg.LogInstance, log.AppName(c.appName))
        }</span>

        <span class="cov8" title="4698">if utils.IsStrNotBlank(cfg.SerializeType) </span><span class="cov8" title="2432">{
                conf.serializeType = serialize.ParseAlgorithm(cfg.SerializeType)
        }</span>

        <span class="cov8" title="4696">if utils.IsStrNotBlank(cfg.Compress) </span><span class="cov8" title="3224">{
                conf.compressType = compress.ParseAlgorithm(cfg.Compress)
                if !conf.compressType.IsValid() </span><span class="cov0" title="0">{
                        panic(UnknownCompress)</span>
                }
        }
        // default serialize type when need compress
        <span class="cov8" title="4696">if conf.compressType.IsValid() &amp;&amp; !conf.serializeType.IsValid() </span><span class="cov7" title="2020">{
                conf.serializeType = serialize.AlgorithmGob
        }</span>

        <span class="cov8" title="4696">if utils.IsStrNotBlank(cfg.Callback) </span><span class="cov5" title="202">{
                callbackFn := inspect.FuncOf(cfg.Callback)
                if callbackFn == nil </span><span class="cov0" title="0">{
                        panic(errors.Errorf("not found callback function: %s", cfg.Callback))</span>
                }
                <span class="cov5" title="202">conf.callback = *(*func(ctx context.Context, missed []K) (rs map[K]T, opts []utils.OptionExtender))(callbackFn)</span>
        }

        <span class="cov8" title="4697">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cache

import (
        "context"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/common/utils/serialize"
        "github.com/wfusion/gofusion/config"
)

// Construct cache only check some configures
func Construct(ctx context.Context, confs map[string]*Conf, _ ...utils.OptionExtender) func() <span class="cov9" title="34">{
        for _, conf := range confs </span><span class="cov10" title="43">{
                addInstance(ctx, conf)
        }</span>

        <span class="cov9" title="34">return func() </span>{<span class="cov9" title="34">

        }</span>
}

func addInstance(ctx context.Context, conf *Conf) <span class="cov10" title="43">{
        switch conf.CacheType </span>{
        case cacheTypeLocal:<span class="cov9" title="29"></span>
        case cacheTypeRemote:<span class="cov7" title="14">
                if conf.RemoteType != remoteTypeRedis </span><span class="cov0" title="0">{
                        panic(UnknownRemoteType)</span>
                }

                <span class="cov7" title="14">parsedSerializeType := serialize.ParseAlgorithm(conf.SerializeType)
                parsedCompressType := compress.ParseAlgorithm(conf.Compress)
                if !parsedSerializeType.IsValid() &amp;&amp; !parsedCompressType.IsValid() </span><span class="cov0" title="0">{
                        panic(UnknownSerializeType)</span>
                }
        case cacheTypeRemoteLocal:<span class="cov0" title="0">
                panic(ErrNotImplement)</span>

        default:<span class="cov0" title="0">
                panic(UnknownCacheType)</span>
        }

        <span class="cov10" title="43">if utils.IsStrNotBlank(conf.Callback) &amp;&amp; inspect.FuncOf(conf.Callback) == nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("not found callback function: %s", conf.Callback))</span>
        }
}

func init() <span class="cov7" title="14">{
        config.AddComponent(config.ComponentCache, Construct)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cache

import (
        "context"
        "errors"
        "syscall"
        "time"

        "github.com/bluele/gcache"

        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

func newGCache(size int, strategy string, log log.Logable) *gCache <span class="cov4" title="17">{
        cacheBuilder := gcache.New(size)
        switch strategy </span>{
        case gcache.TYPE_ARC:<span class="cov4" title="17">
                cacheBuilder = cacheBuilder.ARC()</span>
        case gcache.TYPE_LFU:<span class="cov0" title="0">
                cacheBuilder = cacheBuilder.LFU()</span>
        case gcache.TYPE_LRU:<span class="cov0" title="0">
                cacheBuilder = cacheBuilder.LRU()</span>
        case gcache.TYPE_SIMPLE:<span class="cov0" title="0">
                cacheBuilder = cacheBuilder.Simple()</span>
        default:<span class="cov0" title="0">
                cacheBuilder = cacheBuilder.ARC()</span>
        }

        <span class="cov4" title="17">return &amp;gCache{
                log:      log,
                instance: cacheBuilder.Build(),
        }</span>
}

type gCache struct {
        log      log.Logable
        instance gcache.Cache
}

func (g *gCache) get(ctx context.Context, keys ...string) (cached map[string]any, missed []string) <span class="cov8" title="1316">{
        cached = make(map[string]any, len(keys))
        missed = make([]string, 0, len(keys))
        for _, k := range keys </span><span class="cov9" title="3746">{
                v, err := g.instance.Get(k)
                if err != nil </span><span class="cov9" title="2429">{
                        missed = append(missed, k)
                        if !errors.Is(err, gcache.KeyNotFoundError) &amp;&amp; g.log != nil </span><span class="cov0" title="0">{
                                g.log.Info(ctx, "%v [Gofusion] %s call gcache get failed "+
                                        "when get cache from gcache [err[%s] key[%s]]", syscall.Getpid(), config.ComponentCache, err, k)
                        }</span>
                        <span class="cov9" title="2429">continue</span>
                }
                <span class="cov8" title="1317">cached[k] = v</span>
        }
        <span class="cov8" title="1316">return</span>
}

func (g *gCache) set(ctx context.Context, kvs map[string]any, expired map[string]time.Duration) (failure []string) <span class="cov9" title="2117">{
        failure = make([]string, 0, len(kvs))
        for k, v := range kvs </span><span class="cov10" title="3771">{
                var err error
                if exp, ok := expired[k]; ok </span><span class="cov10" title="3771">{
                        err = g.instance.SetWithExpire(k, v, exp)
                }</span> else<span class="cov0" title="0"> {
                        err = g.instance.Set(k, v)
                }</span>

                <span class="cov10" title="3771">if err != nil </span><span class="cov0" title="0">{
                        failure = append(failure, k)
                        if g.log != nil </span><span class="cov0" title="0">{
                                g.log.Info(ctx, "%v [Gofusion] %s call gcache set/set_with_expire failed "+
                                        "when set cache into gcache [err[%s] key[%s]]", syscall.Getpid(), config.ComponentCache, err, k)
                        }</span>
                }
        }
        <span class="cov9" title="2117">return</span>
}

func (g *gCache) del(ctx context.Context, keys ...string) (failure []string) <span class="cov4" title="21">{
        failure = make([]string, 0, len(keys))
        for _, k := range keys </span><span class="cov9" title="3750">{
                if g.instance.Remove(k) </span><span class="cov9" title="3738">{
                        continue</span>
                }

                <span class="cov3" title="12">if _, err := g.instance.Get(k); !errors.Is(err, gcache.KeyNotFoundError) </span><span class="cov0" title="0">{
                        failure = append(failure, k)
                        if g.log != nil </span><span class="cov0" title="0">{
                                g.log.Info(ctx, "%v [Gofusion] %s call gcache remove failed "+
                                        "when delete cache from gcache [err[%s] key[%s]]", syscall.Getpid(), config.ComponentCache, err, k)
                        }</span>
                }
        }
        <span class="cov4" title="21">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cache

import (
        "context"
        "syscall"
        "time"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
        "github.com/wfusion/gofusion/redis"

        rdsDrv "github.com/redis/go-redis/v9"
)

type rds struct {
        appName  string
        name     string
        log      log.Logable
        instance rdsDrv.UniversalClient
}

func newRedis(appName, name string, log log.Logable) provider <span class="cov3" title="10">{
        return &amp;rds{
                appName:  appName,
                name:     name,
                log:      log,
                instance: redis.Use(context.Background(), name, redis.AppName(appName)),
        }
}</span>

func (r *rds) get(ctx context.Context, keys ...string) (cached map[string]any, missed []string) <span class="cov8" title="1005">{
        cached = make(map[string]any, len(keys))
        missed = make([]string, 0, len(keys))

        rs, err := r.instance.MGet(ctx, keys...).Result()
        if err != nil </span><span class="cov0" title="0">{
                missed = keys
                if r.log != nil </span><span class="cov0" title="0">{
                        r.log.Info(ctx, "%v [Gofusion] %s call redis mget failed when get cache from redis "+
                                "[err[%s] redis[%s]]", syscall.Getpid(), config.ComponentCache, err, r.name)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1008">for i := 0; i &lt; len(keys); i++ </span><span class="cov9" title="2516">{
                if rs[i] != nil </span><span class="cov8" title="1009">{
                        cached[keys[i]] = rs[i]
                }</span> else<span class="cov9" title="1507"> {
                        missed = append(missed, keys[i])
                }</span>
        }

        <span class="cov8" title="1008">return</span>
}

func (r *rds) set(ctx context.Context, kvs map[string]any, expired map[string]time.Duration) (failure []string) <span class="cov9" title="1507">{
        failure = make([]string, 0, len(kvs))
        pipe := r.instance.Pipeline()
        keys := make([]string, 0, len(kvs))
        for k, v := range kvs </span><span class="cov10" title="2531">{
                keys = append(keys, k)
                pipe.Set(ctx, k, v, expired[k])
        }</span>

        <span class="cov9" title="1507">cmds := utils.Must(pipe.Exec(ctx))
        for i := 0; i &lt; len(keys); i++ </span><span class="cov9" title="2529">{
                if err := cmds[i].Err(); err != nil </span><span class="cov0" title="0">{
                        failure = append(failure, keys[i])
                        if r.log != nil </span><span class="cov0" title="0">{
                                r.log.Info(ctx, "%v [Gofusion] %s call redis set failed when set cache into redis "+
                                        "[err[%s] redis[%s] key[%s]]", syscall.Getpid(), config.ComponentCache, err, r.name, keys[i])
                        }</span>
                }
        }
        <span class="cov9" title="1505">return</span>
}

func (r *rds) del(ctx context.Context, keys ...string) (failure []string) <span class="cov4" title="14">{
        affected, err := r.instance.Del(ctx, keys...).Result()
        if err != nil &amp;&amp; r.log != nil </span><span class="cov0" title="0">{
                r.log.Info(ctx, "%v [Gofusion] %s call redis del failed when delete from cache "+
                        "[err[%s] redis[%s] keys%v]", syscall.Getpid(), config.ComponentCache, err, r.name, keys)
        }</span>

        <span class="cov4" title="14">if affected == int64(len(keys)) </span><span class="cov3" title="12">{
                return
        }</span>

        <span class="cov1" title="2">failure = make([]string, 0, len(keys))
        pipe := r.instance.Pipeline()
        for i := 0; i &lt; len(keys); i++ </span><span class="cov4" title="17">{
                pipe.Exists(ctx, keys[i])
        }</span>
        <span class="cov1" title="2">cmds, err := pipe.Exec(ctx)
        if err != nil &amp;&amp; r.log != nil </span><span class="cov0" title="0">{
                r.log.Info(ctx, "%v [Gofusion] %s call redis exists failed when delete from cache "+
                        "[err[%s] redis[%s] keys%v]", syscall.Getpid(), config.ComponentCache, err, r.name, keys)
                return keys // we cannot know whether ths keys are deleted
        }</span>

        <span class="cov1" title="2">for i := 0; i &lt; len(keys); i++ </span><span class="cov4" title="17">{
                if err := cmds[i].Err(); err != nil </span><span class="cov0" title="0">{
                        failure = append(failure, keys[i]) // we cannot know whether ths key is deleted
                        r.log.Info(ctx, "%v [Gofusion] %s call redis exists failed when delete from cache "+
                                "[err[%s] redis[%s] key[%s]]", syscall.Getpid(), config.ComponentCache, err, r.name, keys[i])
                        continue</span>
                }

                <span class="cov4" title="17">if cmds[i].String() == "1" </span><span class="cov0" title="0">{
                        failure = append(failure, keys[i])
                }</span>
        }

        <span class="cov1" title="2">return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cache

import (
        "context"
        "errors"
        "time"

        "github.com/wfusion/gofusion/common/constraint"
        "github.com/wfusion/gofusion/common/utils"
)

var (
        UnknownCacheType     = errors.New("unknown cache type")
        UnknownCompress      = errors.New("unknown compress type")
        UnknownSerializeType = errors.New("unknown serialize type")
        UnknownRemoteType    = errors.New("unknown remote type")
        ErrNotImplement      = errors.New("not implement")
        ErrCacheNotFound     = errors.New("not found cache to use")
        ErrCallbackNotFound  = errors.New("not found callback function")
)

type Cachable[K constraint.Sortable, T any, TS ~[]T] interface {
        Get(ctx context.Context, keys []K, cb callback[K, T]) TS
        GetAll(ctx context.Context, cb callback[K, T]) TS
        Set(ctx context.Context, kv map[K]T, opts ...utils.OptionExtender) (failure []K)
        Del(ctx context.Context, keys ...K) (failure []K)
        Clear(ctx context.Context) (failure []K)
}

type callback[K constraint.Sortable, T any] func(ctx context.Context, missed []K) (
        rs map[K]T, opts []utils.OptionExtender)

type option[K constraint.Sortable] struct {
        expired    time.Duration
        keyExpired map[K]time.Duration
}

func Expired[K constraint.Sortable](expired time.Duration) utils.OptionFunc[option[K]] <span class="cov8" title="1">{
        return func(o *option[K]) </span><span class="cov8" title="1">{
                o.expired = expired
        }</span>
}

func KeyExpired[K constraint.Sortable](keyExpired map[K]time.Duration) utils.OptionFunc[option[K]] <span class="cov8" title="1">{
        return func(o *option[K]) </span><span class="cov8" title="1">{
                o.keyExpired = keyExpired
        }</span>
}

type cacheType string

const (
        // cacheTypeLocal local cache, base on gcache
        cacheTypeLocal cacheType = "local"
        // cacheTypeRemote remote cache should be serialized
        cacheTypeRemote cacheType = "remote"
        // cacheTypeRemoteLocal remove cache version and local cache data, not implement now
        cacheTypeRemoteLocal cacheType = "remote_local"
)

type remoteType string

const (
        remoteTypeRedis remoteType = "redis"
)

type Conf struct {
        Size           int        `yaml:"size" json:"size" toml:"size" default:"10000"`
        Expired        string     `yaml:"expired" json:"expired" toml:"expired" default:"1h"`
        Version        int        `yaml:"version" json:"version" toml:"version"`
        CacheType      cacheType  `yaml:"type" json:"type" toml:"type" default:"local"`
        RemoteType     remoteType `yaml:"remote_type" json:"remote_type" toml:"remote_type" default:"redis"`
        RemoteInstance string     `yaml:"remote_instance" json:"remote_instance" toml:"remote_instance"`
        LocalEvictType string     `yaml:"local_evict_type" json:"local_evict_type" toml:"local_evict_type" default:"arc"`
        Compress       string     `yaml:"compress" json:"compress" toml:"compress"`
        SerializeType  string     `yaml:"serialize_type" json:"serialize_type" toml:"serialize_type"`
        Callback       string     `yaml:"callback" json:"callback" toml:"callback"`
        LogInstance    string     `yaml:"log_instance" json:"log_instance" toml:"log_instance" default:"default"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package constant

import (
        "time"
)

const (
        StdDateLayout      = "2006-01-02"
        StdTimeLayout      = "2006-01-02 15:04:05"
        StdTimeWithZLayout = "2006-01-02T15:04:05Z"
        StdTimeMSLayout    = "2006-01-02 15:04:05.999999"
)

const (
        DefaultTimezone = "Asia/Shanghai"
)

func DefaultLocation() *time.Location <span class="cov0" title="0">{
        loc, err := time.LoadLocation(DefaultTimezone)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return loc</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package di

import (
        "fmt"
        "reflect"

        "go.uber.org/dig"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
)

var (
        Dig = NewDI()

        inType     = reflect.TypeOf(In{})
        outType    = reflect.TypeOf(Out{})
        digInType  = reflect.TypeOf(dig.In{})
        digOutType = reflect.TypeOf(dig.Out{})

        Type = reflect.TypeOf(NewDI())
)

type _dig struct {
        *dig.Container
        fields []reflect.StructField
}

func NewDI() DI <span class="cov6" title="52">{
        return &amp;_dig{Container: dig.New()}
}</span>

type provideOption struct {
        name  string
        group string
}

func Name(name string) utils.OptionFunc[provideOption] <span class="cov9" title="345">{
        return func(p *provideOption) </span><span class="cov9" title="345">{
                p.name = name
        }</span>
}

func Group(group string) utils.OptionFunc[provideOption] <span class="cov0" title="0">{
        return func(p *provideOption) </span><span class="cov0" title="0">{
                p.group = group
        }</span>
}

func (d *_dig) Invoke(fn any) error <span class="cov4" title="12">{ return d.Container.Invoke(fn) }</span>
func (d *_dig) MustInvoke(fn any)   <span class="cov1" title="1">{ utils.MustSuccess(d.Container.Invoke(fn)) }</span>
func (d *_dig) Provide(ctor any, opts ...utils.OptionExtender) (err error) <span class="cov10" title="509">{
        opt := utils.ApplyOptions[provideOption](opts...)
        digOpts := make([]dig.ProvideOption, 0, 2)
        if opt.name != "" </span><span class="cov9" title="345">{
                digOpts = append(digOpts, dig.Name(opt.name))
        }</span>
        <span class="cov10" title="509">if opt.group != "" </span><span class="cov0" title="0">{
                digOpts = append(digOpts, dig.Group(opt.group))
        }</span>

        <span class="cov10" title="509">defer d.addFields(ctor, opt)
        return d.Container.Provide(ctor, digOpts...)</span>
}
func (d *_dig) MustProvide(ctor any, opts ...utils.OptionExtender) DI <span class="cov9" title="481">{
        utils.MustSuccess(d.Provide(ctor, opts...))
        return d
}</span>
func (d *_dig) Decorate(decorator any) error <span class="cov0" title="0">{ return d.Container.Decorate(decorator) }</span>
func (d *_dig) MustDecorate(decorator any) DI <span class="cov0" title="0">{
        utils.MustSuccess(d.Container.Decorate(decorator))
        return d
}</span>

func (d *_dig) String() string <span class="cov0" title="0">{
        return d.Container.String()
}</span>

func (d *_dig) Clear() <span class="cov6" title="36">{
        d.Container = dig.New()
}</span>

// Preload prevent invoke concurrently because invoke is not concurrent safe
// base on: https://github.com/uber-go/dig/issues/241
func (d *_dig) Preload() <span class="cov1" title="1">{
        fields := make([]reflect.StructField, 0, 1+len(d.fields))
        fields = append(fields, reflect.StructField{
                Name:      "In",
                PkgPath:   "",
                Type:      digInType,
                Tag:       "",
                Offset:    0,
                Index:     nil,
                Anonymous: true,
        })
        for i := 0; i &lt; len(d.fields); i++ </span><span class="cov5" title="25">{
                fields = append(fields, reflect.StructField{
                        Name:      fmt.Sprintf("Arg%X", i+1),
                        PkgPath:   "",
                        Type:      d.fields[i].Type,
                        Tag:       d.fields[i].Tag,
                        Offset:    0,
                        Index:     nil,
                        Anonymous: false,
                })
        }</span>
        <span class="cov1" title="1">structType := reflect.StructOf(fields)

        // FIXME: we cannot declare function param type dynamic now
        scope := inspect.GetField[*dig.Scope](d.Container, "scope")
        containerStoreType := inspect.TypeOf("go.uber.org/dig.containerStore")
        containerStoreVal := reflect.ValueOf(scope).Convert(containerStoreType)

        fakeParam := utils.Must(newParam(structType, scope))
        paramType := inspect.TypeOf("go.uber.org/dig.param")
        paramVal := reflect.ValueOf(fakeParam).Convert(paramType)
        buildFn := paramVal.MethodByName("Build")
        returnValList := buildFn.Call([]reflect.Value{containerStoreVal})
        if errVal := returnValList[len(returnValList)-1].Interface(); errVal != nil </span><span class="cov0" title="0">{
                if err, ok := errVal.(error); ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
}

func (d *_dig) addFields(ctor any, opt *provideOption) <span class="cov10" title="509">{
        typ := reflect.TypeOf(ctor)
        numOfOut := typ.NumOut()
        for i := 0; i &lt; numOfOut; i++ </span><span class="cov10" title="509">{
                out := typ.Out(i)
                // ignore error and non-interface nor non-struct out param
                if out == constant.ErrorType ||
                        (out.Kind() != reflect.Interface &amp;&amp;
                                (out.Kind() != reflect.Struct &amp;&amp; !(out.Kind() == reflect.Ptr &amp;&amp; out.Elem().Kind() == reflect.Struct))) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov10" title="509">if out.Kind() == reflect.Ptr </span><span class="cov7" title="72">{
                        out = out.Elem()
                }</span>

                <span class="cov10" title="509">if !utils.EmbedsType(out, digOutType) </span><span class="cov10" title="509">{
                        var tag reflect.StructTag
                        switch </span>{
                        case opt.name != "":<span class="cov9" title="345">
                                tag = reflect.StructTag(fmt.Sprintf(`name:"%s"`, opt.name))</span>
                        case opt.group != "":<span class="cov0" title="0">
                                tag = reflect.StructTag(fmt.Sprintf(`group:"%s"`, opt.group))
                                out = reflect.SliceOf(out)</span>
                        }

                        <span class="cov10" title="509">d.fields = append(d.fields, reflect.StructField{Type: out, Tag: tag})
                        continue</span>
                }

                // traverse all field
                <span class="cov0" title="0">numOfFields := out.NumField()
                for j := 0; j &lt; numOfFields; j++ </span><span class="cov0" title="0">{
                        f := out.Field(j)

                        // ignore dig out
                        if f.Type == digOutType || f.Type == outType </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">d.fields = append(d.fields, f)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package env

import (
        "os"
        "path/filepath"
)

const (
        Dev     = "dev"
        Online  = "online"
        Staging = "staging"
        CI      = "ci"
)

var (
        WorkDir string
        env     string
        svcName string
)

// GetEnv get environment ENV
func GetEnv() string <span class="cov10" title="80">{
        if env != "" </span><span class="cov9" title="66">{
                return env
        }</span>
        <span class="cov6" title="14">if env = os.Getenv("ENV"); env == "" </span><span class="cov6" title="14">{
                env = Dev
        }</span>
        <span class="cov6" title="14">return env</span>
}

// IsDEV is dev
func IsDEV() bool <span class="cov0" title="0">{
        return GetEnv() == Dev
}</span>

// IsOnline is online
func IsOnline() bool <span class="cov0" title="0">{
        return GetEnv() == Online
}</span>

// IsStaging is staging
func IsStaging() bool <span class="cov0" title="0">{
        return GetEnv() == Staging
}</span>

// IsCI is ci
func IsCI() bool <span class="cov0" title="0">{
        return GetEnv() == CI
}</span>

func SetSvcName(name string) <span class="cov0" title="0">{
        svcName = name
}</span>

func SvcName() string <span class="cov6" title="14">{
        if svcName != "" </span><span class="cov0" title="0">{
                return svcName
        }</span>
        <span class="cov6" title="14">if svcName = os.Getenv("SVC_NAME"); svcName != "" </span><span class="cov0" title="0">{
                return svcName
        }</span>
        <span class="cov6" title="14">if svcName = os.Getenv("SERVICE_NAME"); svcName != "" </span><span class="cov0" title="0">{
                return svcName
        }</span>
        <span class="cov6" title="14">return ""</span>
}

func init() <span class="cov6" title="14">{
        GetEnv()
        SvcName()

        dir, _ := filepath.Abs(filepath.Dir(os.Args[0]))
        WorkDir = dir
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package mongo

import (
        "context"

        "go.mongodb.org/mongo-driver/event"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "github.com/wfusion/gofusion/common/utils"
)

type Dialect interface {
        New(ctx context.Context, option Option, opts ...utils.OptionExtender) (cli *Mongo, err error)
}

type newOption struct {
        monitor     *event.CommandMonitor
        poolMonitor *event.PoolMonitor
}

type Mongo struct {
        *mongo.Client
}

func (m *Mongo) GetProxy() *mongo.Client <span class="cov3" title="10">{
        return m.Client
}</span>

func (m *Mongo) Database(name string, opts ...*options.DatabaseOptions) *mongo.Database <span class="cov10" title="1929">{
        return m.Client.Database(name, opts...)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package mongo

import (
        "go.mongodb.org/mongo-driver/event"

        "github.com/wfusion/gofusion/common/utils"
)

func WithMonitor(monitor *event.CommandMonitor) utils.OptionFunc[newOption] <span class="cov10" title="10">{
        return func(o *newOption) </span><span class="cov10" title="10">{
                o.monitor = monitor
        }</span>
}

func WithPoolMonitor(monitor *event.PoolMonitor) utils.OptionFunc[newOption] <span class="cov10" title="10">{
        return func(o *newOption) </span><span class="cov10" title="10">{
                o.poolMonitor = monitor
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package mongo

import (
        "context"
        "fmt"
        "strings"
        "time"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils"
)

// Option
//nolint: revive // mongo options comments too long issue
type Option struct {
        DB        string   `yaml:"db" json:"db" toml:"db"`
        AuthDB    string   `yaml:"auth_db" json:"auth_db" toml:"auth_db" default:"admin"`
        User      string   `yaml:"user" json:"user" toml:"user"`
        Password  string   `yaml:"password" json:"password" toml:"password" encrypted:""`
        Endpoints []string `yaml:"endpoints" json:"endpoints" toml:"endpoints"`

        // Timeout specifies the amount of time that a single operation run on this Client can execute before returning an error.
        // The deadline of any operation run through the Client will be honored above any Timeout set on the Client; Timeout will only
        // be honored if there is no deadline on the operation Context. Timeout can also be set through the "timeoutMS" URI option
        // (e.g. "timeoutMS=1000"). The default value is nil, meaning operations do not inherit a timeout from the Client.
        //
        // If any Timeout is set (even 0) on the Client, the values of MaxTime on operation options, TransactionOptions.MaxCommitTime and
        // SessionOptions.DefaultMaxCommitTime will be ignored. Setting Timeout and SocketTimeout or writeConcern.wTimeout will result
        // in undefined behavior.
        //
        // NOTE(benjirewis): SetTimeout represents unstable, provisional API. The behavior of the driver when a Timeout is specified is
        // subject to change.
        Timeout string `yaml:"timeout" json:"timeout" toml:"timeout" default:"5s"`
        // ConnTimeout specifies a timeout that is used for creating connections to the server. If a custom Dialer is
        // specified through SetDialer, this option must not be used. This can be set through ApplyURI with the
        // "connectTimeoutMS" (e.g "connectTimeoutMS=30") option. If set to 0, no timeout will be used. The default is 30
        // seconds.
        ConnTimeout string `yaml:"conn_timeout" json:"conn_timeout" toml:"conn_timeout" default:"30s"`
        // SocketTimeout specifies the timeout to be used for the Client's socket reads and writes.
        //
        // NOTE(benjirewis): SocketTimeout will be deprecated in a future release. The more general Timeout option
        // may be used in its place to control the amount of time that a single operation can run before returning
        // an error. Setting SocketTimeout and Timeout on a single client will result in undefined behavior.
        SocketTimeout string `yaml:"socket_timeout" json:"socket_timeout" toml:"socket_timeout" default:"5s"`
        // HeartbeatInterval specifies the amount of time to wait between periodic background server checks. This can also be
        // set through the "heartbeatIntervalMS" URI option (e.g. "heartbeatIntervalMS=10000"). The default is 10 seconds.
        HeartbeatInterval string `yaml:"heartbeat_interval" json:"heartbeat_interval" toml:"heartbeat_interval" default:"10s"`

        // MaxConnecting specifies the maximum number of connections a connection pool may establish simultaneously. This can
        // also be set through the "maxConnecting" URI option (e.g. "maxConnecting=2"). If this is 0, the default is used. The
        // default is 2. Values greater than 100 are not recommended.
        MaxConnecting uint64 `yaml:"max_connecting" json:"max_connecting" toml:"max_connecting" default:"2"`
        // MinPoolSize specifies the minimum number of connections allowed in the driver's connection pool to each server. If
        // this is non-zero, each server's pool will be maintained in the background to ensure that the size does not fall below
        // the minimum. This can also be set through the "minPoolSize" URI option (e.g. "minPoolSize=100"). The default is 0.
        MinPoolSize uint64 `yaml:"min_pool_size" json:"min_pool_size" toml:"min_pool_size"`
        // MaxPoolSize specifies that maximum number of connections allowed in the driver's connection pool to each server.
        // Requests to a server will block if this maximum is reached. This can also be set through the "maxPoolSize" URI option
        // (e.g. "maxPoolSize=100"). If this is 0, maximum connection pool size is not limited. The default is 100.
        MaxPoolSize uint64 `yaml:"max_pool_size" json:"max_pool_size" toml:"max_pool_size" default:"100"`
        // MaxConnIdleTime specifies the maximum amount of time that a connection will remain idle in a connection pool
        // before it is removed from the pool and closed. This can also be set through the "maxIdleTimeMS" URI option (e.g.
        // "maxIdleTimeMS=10000"). The default is 0, meaning a connection can remain unused indefinitely.
        MaxConnIdleTime string `yaml:"max_conn_idle_time" json:"max_conn_idle_time" toml:"max_conn_idle_time" default:"10s"`

        // RetryWrites specifies whether supported write operations should be retried once on certain errors, such as network
        // errors.
        //
        // Supported operations are InsertOne, UpdateOne, ReplaceOne, DeleteOne, FindOneAndDelete, FindOneAndReplace,
        // FindOneAndDelete, InsertMany, and BulkWrite. Note that BulkWrite requests must not include UpdateManyModel or
        // DeleteManyModel instances to be considered retryable. Unacknowledged writes will not be retried, even if this option
        // is set to true.
        //
        // This option requires server version &gt;= 3.6 and a replica set or sharded cluster and will be ignored for any other
        // cluster type. This can also be set through the "retryWrites" URI option (e.g. "retryWrites=true"). The default is
        // true.
        RetryWrites bool `yaml:"retry_writes" json:"retry_writes" toml:"retry_writes" default:"true"`

        // SetRetryReads specifies whether supported read operations should be retried once on certain errors, such as network
        // errors.
        //
        // Supported operations are Find, FindOne, Aggregate without a $out stage, Distinct, CountDocuments,
        // EstimatedDocumentCount, Watch (for Client, Database, and Collection), ListCollections, and ListDatabases. Note that
        // operations run through RunCommand are not retried.
        //
        // This option requires server version &gt;= 3.6 and driver version &gt;= 1.1.0. The default is true.
        RetryReads bool `yaml:"retry_reads" json:"retry_reads" toml:"retry_reads" default:"true"`
}

var Default Dialect = new(defaultDialect)

type defaultDialect struct{}

func (d *defaultDialect) New(ctx context.Context, option Option, opts ...utils.OptionExtender) (cli *Mongo, err error) <span class="cov6" title="10">{
        opt := options.Client().ApplyURI(d.parseOption(option))
        opt.SetRetryReads(option.RetryReads)
        opt.SetRetryWrites(option.RetryWrites)
        d.wrapDurationSetter(option.Timeout, func(du time.Duration) </span><span class="cov6" title="10">{ opt.SetTimeout(du) }</span>)
        <span class="cov6" title="10">d.wrapDurationSetter(option.ConnTimeout, func(du time.Duration) </span><span class="cov6" title="10">{ opt.SetConnectTimeout(du) }</span>)
        <span class="cov6" title="10">d.wrapDurationSetter(option.SocketTimeout, func(du time.Duration) </span><span class="cov6" title="10">{ opt.SetSocketTimeout(du) }</span>)
        <span class="cov6" title="10">d.wrapDurationSetter(option.MaxConnIdleTime, func(du time.Duration) </span><span class="cov6" title="10">{ opt.SetMaxConnIdleTime(du) }</span>)
        <span class="cov6" title="10">d.wrapDurationSetter(option.HeartbeatInterval, func(du time.Duration) </span><span class="cov6" title="10">{ opt.SetHeartbeatInterval(du) }</span>)
        <span class="cov6" title="10">d.wrapNumberSetter(option.MaxConnecting, func(nu uint64) </span><span class="cov6" title="10">{ opt.SetMaxConnecting(option.MaxConnecting) }</span>)
        <span class="cov6" title="10">d.wrapNumberSetter(option.MinPoolSize, func(nu uint64) </span><span class="cov0" title="0">{ opt.SetMinPoolSize(option.MinPoolSize) }</span>)
        <span class="cov6" title="10">d.wrapNumberSetter(option.MaxPoolSize, func(nu uint64) </span><span class="cov6" title="10">{ opt.SetMaxPoolSize(option.MaxPoolSize) }</span>)

        <span class="cov6" title="10">newOpt := utils.ApplyOptions[newOption](opts...)
        if newOpt.monitor != nil </span><span class="cov6" title="10">{
                opt = opt.SetMonitor(newOpt.monitor)
        }</span>
        <span class="cov6" title="10">if newOpt.poolMonitor != nil </span><span class="cov6" title="10">{
                opt = opt.SetPoolMonitor(newOpt.poolMonitor)
        }</span>

        <span class="cov6" title="10">mgoCli, err := mongo.Connect(ctx, opt)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // authentication check
        <span class="cov6" title="10">if err = mgoCli.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="10">cli = &amp;Mongo{Client: mgoCli}
        return</span>
}

func (d *defaultDialect) wrapDurationSetter(s string, setter func(du time.Duration)) <span class="cov10" title="50">{
        if utils.IsStrBlank(s) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="50">duration, err := time.ParseDuration(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov10" title="50">setter(duration)</span>
}

func (d *defaultDialect) wrapNumberSetter(n uint64, setter func(nu uint64)) <span class="cov8" title="30">{
        if n &gt; 0 </span><span class="cov7" title="20">{
                setter(n)
        }</span>
}

func (d *defaultDialect) parseOption(option Option) (dsn string) <span class="cov6" title="10">{
        return fmt.Sprintf("mongodb://%s:%s@%s/%s?authSource=%s",
                option.User, option.Password, strings.Join(option.Endpoints, constant.Comma), option.DB, option.AuthDB)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package orm

import (
        "context"
        "fmt"
        "path"
        "time"

        "github.com/glebarez/sqlite"
        "github.com/pkg/errors"
        "gorm.io/driver/clickhouse"
        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/driver/sqlserver"
        "gorm.io/gorm"

        "github.com/wfusion/gofusion/common/env"
        "github.com/wfusion/gofusion/common/infra/drivers/orm/opengauss"
        "github.com/wfusion/gofusion/common/utils"
)

var Gorm Dialect = new(gormDriver)

type gormDriver struct{}

type gormDriverOption struct {
        Driver       driver  `yaml:"driver"`
        Dialect      dialect `yaml:"dialect"`
        Timeout      string  `yaml:"timeout"`
        ReadTimeout  string  `yaml:"read_timeout"`
        WriteTimeout string  `yaml:"write_timeout"`
        User         string  `yaml:"user"`
        Password     string  `yaml:"password"`
        DBName       string  `yaml:"db_name"`
        DBCharset    string  `yaml:"db_charset"`
        DBHostname   string  `yaml:"db_hostname"`
        DBPort       string  `yaml:"db_port"`
        MaxIdleConns int     `yaml:"max_idle_conns"`
        MaxOpenConns int     `yaml:"max_open_conns"`
        Scheme       string  `yaml:"scheme"`
}

func (g *gormDriver) New(ctx context.Context, option Option, opts ...utils.OptionExtender) (db *DB, err error) <span class="cov10" title="62">{
        opt := g.parseDBOption(option)
        gormDB, dialector, err := g.open(opt.Driver, string(opt.Dialect), opt)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="62">sqlDB, err := gormDB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // optional
        <span class="cov10" title="62">if opt.MaxOpenConns &gt; 0 </span><span class="cov10" title="62">{
                sqlDB.SetMaxOpenConns(opt.MaxOpenConns)
        }</span>
        <span class="cov10" title="62">if opt.MaxIdleConns &gt; 0 </span><span class="cov10" title="62">{
                sqlDB.SetMaxIdleConns(opt.MaxIdleConns)
        }</span>
        <span class="cov10" title="62">if utils.IsStrNotBlank(option.ConnMaxLifeTime) </span><span class="cov10" title="62">{
                if liftTime, err := time.ParseDuration(option.ConnMaxLifeTime); err == nil </span><span class="cov10" title="62">{
                        sqlDB.SetConnMaxLifetime(liftTime)
                }</span>
        }
        <span class="cov10" title="62">if utils.IsStrNotBlank(option.ConnMaxLifeTime) </span><span class="cov10" title="62">{
                if idleTime, err := time.ParseDuration(option.ConnMaxIdleTime); err == nil </span><span class="cov10" title="62">{
                        sqlDB.SetConnMaxIdleTime(idleTime)
                }</span>
        }

        <span class="cov10" title="62">newOpt := utils.ApplyOptions[newOption](opts...)
        if newOpt.logger != nil </span><span class="cov9" title="55">{
                gormDB.Logger = newOpt.logger
        }</span>

        <span class="cov10" title="62">return &amp;DB{DB: gormDB.WithContext(ctx), dialector: dialector}, nil</span>
}

func (g *gormDriver) open(driver driver, dialect string, opt *gormDriverOption) (
        db *gorm.DB, dialector gorm.Dialector, err error) <span class="cov10" title="62">{
        // alternative driver
        switch driver </span>{
        case DriverMysql:<span class="cov8" title="35">
                dialector = mysql.New(mysql.Config{
                        DriverName: dialect,
                        DSN:        g.genMySqlDsn(opt),
                })</span>

        case DriverPostgres:<span class="cov6" title="15">
                if dialect == string(DialectOpenGauss) </span><span class="cov4" title="6">{
                        dialector = opengauss.New(opengauss.Config{
                                DriverName: dialect,
                                DSN:        g.genPostgresDsn(opt),
                        })
                }</span> else<span class="cov5" title="9"> {
                        dialector = postgres.New(postgres.Config{
                                DriverName: dialect,
                                DSN:        g.genPostgresDsn(opt),
                        })
                }</span>

        // sqlite dsn is filepath
        // or file::memory:?cache=shared is also available, see also https://www.sqlite.org/inmemorydb.html
        case DriverSqlite:<span class="cov4" title="6">
                dialector = sqlite.Open(path.Join(env.WorkDir, path.Clean(opt.DBName)))</span>

        case DriverSqlserver:<span class="cov4" title="6">
                dialector = sqlserver.New(sqlserver.Config{
                        DriverName: dialect,
                        DSN:        g.genSqlServerDsn(opt),
                })</span>

        // tidb is compatible with mysql protocol
        case DriverTiDB:<span class="cov0" title="0">
                dialector = mysql.New(mysql.Config{
                        DriverName: dialect,
                        DSN:        g.genMySqlDsn(opt),
                })</span>

        case DriverClickhouse:<span class="cov0" title="0">
                dialector = clickhouse.New(clickhouse.Config{
                        DriverName: dialect,
                        DSN:        g.genClickhouseDsn(opt),
                })</span>

        default:<span class="cov0" title="0">
                panic(errors.Errorf("unknown db driver or dialect: %s %s", driver, dialect))</span>
        }

        <span class="cov10" title="62">db, err = gorm.Open(dialector, &amp;gorm.Config{
                DisableForeignKeyConstraintWhenMigrating: true,
        })
        return</span>
}

func (g *gormDriver) parseDBOption(option Option) (parsed *gormDriverOption) <span class="cov10" title="62">{
        parsed = &amp;gormDriverOption{
                Driver:       option.Driver,
                Dialect:      option.Dialect,
                Timeout:      option.Timeout,
                ReadTimeout:  option.ReadTimeout,
                WriteTimeout: option.WriteTimeout,
                User:         option.User,
                Password:     option.Password,
                DBName:       option.DB,
                DBCharset:    "utf8mb4,utf8",
                DBHostname:   option.Host,
                DBPort:       fmt.Sprintf("%v", option.Port),
                Scheme:       "tcp",
        }

        if option.Driver != "" </span><span class="cov10" title="62">{
                parsed.Driver = option.Driver
        }</span>
        <span class="cov10" title="62">if option.MaxIdleConns &gt; 0 </span><span class="cov10" title="62">{
                parsed.MaxIdleConns = option.MaxIdleConns
        }</span>
        <span class="cov10" title="62">if option.MaxOpenConns &gt; 0 </span><span class="cov10" title="62">{
                parsed.MaxOpenConns = option.MaxOpenConns
        }</span>

        <span class="cov10" title="62">if utils.IsStrBlank(string(parsed.Dialect)) </span><span class="cov9" title="48">{
                parsed.Dialect = defaultDriverDialectMapping[parsed.Driver]
        }</span>

        <span class="cov10" title="62">return</span>
}

func (g *gormDriver) genMySqlDsn(opt *gormDriverOption) (dsn string) <span class="cov8" title="35">{
        if opt.DBCharset == "" </span><span class="cov0" title="0">{
                opt.DBCharset = "utf8"
        }</span>
        <span class="cov8" title="35">if opt.Scheme == "" </span><span class="cov0" title="0">{
                opt.Scheme = "tcp"
        }</span>

        <span class="cov8" title="35">const (
                dsnFormat = "%s:%s@%s(%s:%s)/%s?charset=%s&amp;parseTime=True&amp;loc=Local&amp;timeout=%s&amp;readTimeout=%s&amp;writeTimeout=%s"
        )

        return fmt.Sprintf(dsnFormat, opt.User, opt.Password, opt.Scheme, opt.DBHostname, opt.DBPort, opt.DBName,
                opt.DBCharset, opt.Timeout, opt.ReadTimeout, opt.WriteTimeout)</span>
}

func (g *gormDriver) genPostgresDsn(opt *gormDriverOption) (dsn string) <span class="cov6" title="15">{
        const (
                dsnFormat = "host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=Asia/Shanghai"
        )

        return fmt.Sprintf(dsnFormat, opt.DBHostname, opt.User, opt.Password, opt.DBName, opt.DBPort)
}</span>

func (g *gormDriver) genSqlServerDsn(opt *gormDriverOption) (dsn string) <span class="cov4" title="6">{
        const (
                dsnFormat = "sqlserver://%s:%s@%s:%s?database=%s&amp;connection+timeout=%s"
        )

        timeout := "5" // seconds
        if utils.IsStrNotBlank(opt.Timeout) </span><span class="cov4" title="6">{
                if duration, err := time.ParseDuration(opt.Timeout); err == nil </span><span class="cov4" title="6">{
                        timeout = fmt.Sprintf("%v", int(duration/time.Second))
                }</span>
        }

        <span class="cov4" title="6">return fmt.Sprintf(dsnFormat, opt.User, opt.Password, opt.DBHostname, opt.DBPort, opt.DBName, timeout)</span>
}

func (g *gormDriver) genClickhouseDsn(opt *gormDriverOption) (dsn string) <span class="cov0" title="0">{
        const (
                dsnFormat = "tcp://%s:%s?database=%s&amp;username=%s&amp;password=%s&amp;read_timeout=%s&amp;write_timeout=%s"
        )

        readTimeout := "2" // seconds
        if utils.IsStrNotBlank(opt.ReadTimeout) </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(opt.ReadTimeout); err == nil </span><span class="cov0" title="0">{
                        readTimeout = fmt.Sprintf("%v", int(duration/time.Second))
                }</span>
        }
        <span class="cov0" title="0">writeTimeout := "2" // seconds
        if utils.IsStrNotBlank(opt.ReadTimeout) </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(opt.WriteTimeout); err == nil </span><span class="cov0" title="0">{
                        writeTimeout = fmt.Sprintf("%v", int(duration/time.Second))
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf(dsnFormat, opt.DBHostname, opt.DBPort, opt.DBName, opt.User, opt.Password,
                readTimeout, writeTimeout)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package idgen

import (
        "errors"

        "gorm.io/gorm"

        "github.com/wfusion/gofusion/common/utils"
)

var (
        ErrNewGenerator = errors.New("new id generator error")
)

type Generator interface {
        Next(opts ...utils.OptionExtender) (id uint64, err error)
}

type option struct {
        tx        *gorm.DB
        idx       int64
        tableName string
}

func GormTx(tx *gorm.DB) utils.OptionFunc[option] <span class="cov10" title="10">{
        return func(o *option) </span><span class="cov0" title="0">{
                o.tx = tx
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package idgen

import (
        "fmt"
        "hash/fnv"
        "log"
        "net"
        "os"
        "reflect"
        "sync"
        "time"

        "github.com/sony/sonyflake"

        "github.com/wfusion/gofusion/common/utils"
)

var (
        // NewSnowflakeType FIXME: should not be deleted to avoid compiler optimized
        NewSnowflakeType = reflect.TypeOf(NewSnowflake)

        snowflakeOnce     sync.Once
        snowflakeInstance *snowflake
)

type snowflake struct {
        instance *sonyflake.Sonyflake
}

// NewSnowflake it should be only one snowflake generator per service instance
func NewSnowflake() Generator <span class="cov10" title="188">{
        snowflakeOnce.Do(func() </span><span class="cov2" title="2">{
                flake := sonyflake.NewSonyflake(sonyflake.Settings{
                        StartTime: time.Time{},
                        // machine id: hash(host ip + local ip + pid)(8 bit) - local ip(8 bit)
                        MachineID: func() (id uint16, err error) </span><span class="cov2" title="2">{
                                pid := os.Getpid()
                                hostIP := utils.HostIPInDocker()
                                localIP := utils.ClientIP()
                                log.Printf("[Common] snowflake get machine id base [host[%s] local[%s] pid[%v]]", hostIP, localIP, pid)
                                if hostIP == "" </span><span class="cov2" title="2">{
                                        hostIP = utils.ClientIP()
                                }</span>
                                <span class="cov2" title="2">hash := fnv.New32a()
                                _, err = hash.Write([]byte(fmt.Sprintf("%s%s%v", hostIP, localIP, pid)))
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov2" title="2">high := byte(hash.Sum32() % 255)
                                low := net.ParseIP(localIP).To4()[3]
                                id = uint16(high)&lt;&lt;8 | uint16(low)
                                log.Printf("[Common] snowflake get machine id [%X]", id)
                                return</span>
                        },
                        CheckMachineID: nil,
                })
                <span class="cov2" title="2">if flake == nil </span><span class="cov0" title="0">{
                        panic(ErrNewGenerator)</span>
                }
                <span class="cov2" title="2">snowflakeInstance = &amp;snowflake{instance: flake}</span>
        })

        <span class="cov10" title="188">return snowflakeInstance</span>
}

func (s *snowflake) Next(opts ...utils.OptionExtender) (id uint64, err error) <span class="cov5" title="15">{
        return s.instance.NextID()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package orm

import (
        "context"

        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "github.com/wfusion/gofusion/common/utils"
)

type Dialect interface {
        New(ctx context.Context, option Option, opts ...utils.OptionExtender) (db *DB, err error)
}

type newOption struct {
        logger logger.Interface
}

// Option db option
//nolint: revive // struct tag too long issue
type Option struct {
        Driver          driver  `yaml:"driver" json:"driver" toml:"driver"`
        Dialect         dialect `yaml:"dialect" json:"dialect" toml:"dialect"`
        DB              string  `yaml:"db" json:"db" toml:"db"`
        Host            string  `yaml:"host" json:"host" toml:"host"`
        Port            uint    `yaml:"port" json:"port" toml:"port"`
        User            string  `yaml:"user" json:"user" toml:"user"`
        Password        string  `yaml:"password" json:"password" toml:"password" encrypted:""`
        Timeout         string  `yaml:"timeout" json:"timeout" toml:"timeout" default:"5s"`
        ReadTimeout     string  `yaml:"read_timeout" json:"read_timeout" toml:"read_timeout" default:"2s"`
        WriteTimeout    string  `yaml:"write_timeout" json:"write_timeout" toml:"write_timeout" default:"2s"`
        MaxIdleConns    int     `yaml:"max_idle_conns" json:"max_idle_conns" toml:"max_idle_conns" default:"20"`
        MaxOpenConns    int     `yaml:"max_open_conns" json:"max_open_conns" toml:"max_open_conns" default:"20"`
        ConnMaxLifeTime string  `yaml:"conn_max_life_time" json:"conn_max_life_time" toml:"conn_max_life_time" default:"30m"`
        ConnMaxIdleTime string  `yaml:"conn_max_idle_time" json:"conn_max_idle_time" toml:"conn_max_idle_time" default:"15m"`
}

type DB struct {
        *gorm.DB
        dialector gorm.Dialector
}

func (d *DB) GetProxy() *gorm.DB <span class="cov7" title="548">{
        return d.DB
}</span>

func (d *DB) GetDialector() gorm.Dialector <span class="cov0" title="0">{
        return d.dialector
}</span>

func (d *DB) WithContext(ctx context.Context) *DB <span class="cov10" title="4863">{
        d.DB = d.DB.WithContext(ctx)
        return d
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package orm

import (
        "gorm.io/gorm/logger"

        "github.com/wfusion/gofusion/common/utils"
)

func WithLogger(l logger.Interface) utils.OptionFunc[newOption] <span class="cov10" title="62">{
        return func(o *newOption) </span><span class="cov10" title="62">{
                o.logger = l
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package redis

import (
        "github.com/redis/go-redis/v9"

        "github.com/wfusion/gofusion/common/utils"
)

func WithHook(hooks []redis.Hook) utils.OptionFunc[newOption] <span class="cov10" title="18">{
        return func(o *newOption) </span><span class="cov10" title="18">{
                o.hooks = append(o.hooks, hooks...)
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package redis

import (
        "context"

        "github.com/redis/go-redis/v9"

        "github.com/wfusion/gofusion/common/utils"
)

type Dialect interface {
        New(ctx context.Context, option Option, opts ...utils.OptionExtender) (redis *Redis, err error)
}

type newOption struct {
        hooks []redis.Hook
}

type Option struct {
        Cluster   bool     `yaml:"cluster" json:"cluster" toml:"cluster"`
        Endpoints []string `yaml:"endpoints" json:"endpoints" toml:"endpoints"`
        DB        uint     `yaml:"db" json:"db" toml:"db"`
        User      string   `yaml:"user" json:"user" toml:"user"`
        Password  string   `yaml:"password" json:"password" toml:"password" encrypted:""`

        // Dial timeout for establishing new connections.
        // Default is 5 seconds.
        DialTimeout string `yaml:"dial_timeout" json:"dial_timeout" toml:"dial_timeout" default:"5s"`
        // Timeout for socket reads. If reached, commands will fail
        // with a timeout instead of blocking. Supported values:
        //   - `0` - default timeout (3 seconds).
        //   - `-1` - no timeout (block indefinitely).
        //   - `-2` - disables SetReadDeadline calls completely.
        ReadTimeout string `yaml:"read_timeout" json:"read_timeout" toml:"read_timeout" default:"3s"`
        // Timeout for socket writes. If reached, commands will fail
        // with a timeout instead of blocking.  Supported values:
        //   - `0` - default timeout (3 seconds).
        //   - `-1` - no timeout (block indefinitely).
        //   - `-2` - disables SetWriteDeadline calls completely.
        WriteTimeout string `yaml:"write_timeout" json:"write_timeout" toml:"write_timeout" default:"3s"`

        // Minimum number of idle connections which is useful when establishing
        // new connection is slow.
        MinIdleConns int `yaml:"min_idle_conns" json:"min_idle_conns" toml:"min_idle_conns"`
        // Maximum number of idle connections.
        MaxIdleConns int `yaml:"max_idle_conns" json:"max_idle_conns" toml:"max_idle_conns"`
        // ConnMaxIdleTime is the maximum amount of time a connection may be idle.
        // Should be less than server's timeout.
        //
        // Expired connections may be closed lazily before reuse.
        // If d &lt;= 0, connections are not closed due to a connection's idle time.
        //
        // Default is 30 minutes. -1 disables idle timeout check.
        ConnMaxIdleTime string `yaml:"conn_max_idle_time" json:"conn_max_idle_time" toml:"conn_max_idle_time" default:"30m"`
        // ConnMaxLifetime is the maximum amount of time a connection may be reused.
        //
        // Expired connections may be closed lazily before reuse.
        // If &lt;= 0, connections are not closed due to a connection's age.
        //
        // Default is to not close idle connections.
        ConnMaxLifetime string `yaml:"conn_max_life_time" json:"conn_max_life_time" toml:"conn_max_life_time"`

        // Maximum number of retries before giving up.
        // Default is 3 retries; -1 (not 0) disables retries.
        MaxRetries int `yaml:"max_retries" json:"max_retries" toml:"max_retries" default:"3"`
        // Minimum backoff between each retry.
        // Default is 8 milliseconds; -1 disables backoff.
        MinRetryBackoff string `yaml:"min_retry_backoff" json:"min_retry_backoff" toml:"min_retry_backoff" default:"8ms"`
        // Maximum backoff between each retry.
        // Default is 512 milliseconds; -1 disables backoff.
        MaxRetryBackoff string `yaml:"max_retry_backoff" json:"max_retry_backoff" toml:"max_retry_backoff" default:"512ms"`

        // Maximum number of socket connections.
        // Default is 10 connections per every available CPU as reported by runtime.GOMAXPROCS.
        PoolSize int `yaml:"pool_size" json:"pool_size" toml:"pool_size"`
        // Amount of time client waits for connection if all connections
        // are busy before returning an error.
        // Default is ReadTimeout + 1 second.
        PoolTimeout string `yaml:"pool_timeout" json:"pool_timeout" toml:"pool_timeout"`
}

type Redis struct {
        redis redis.UniversalClient
}

func (r *Redis) GetProxy() redis.UniversalClient <span class="cov10" title="8474">{
        return r.redis
}</span>

func (r *Redis) Close() error <span class="cov0" title="0">{
        switch rdsCli := r.redis.(type) </span>{
        case *redis.ClusterClient:<span class="cov0" title="0">
                return rdsCli.Close()</span>
        case *redis.Client:<span class="cov0" title="0">
                return rdsCli.Close()</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (r *Redis) PoolStatus() *redis.PoolStats <span class="cov0" title="0">{
        switch rdsCli := r.redis.(type) </span>{
        case *redis.ClusterClient:<span class="cov0" title="0">
                return rdsCli.PoolStats()</span>
        case *redis.Client:<span class="cov0" title="0">
                return rdsCli.PoolStats()</span>
        default:<span class="cov0" title="0">
                return new(redis.PoolStats)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package redis

import (
        "context"
        "time"

        "github.com/redis/go-redis/v9"

        "github.com/wfusion/gofusion/common/utils"
)

var Default Dialect = new(defaultDialect)

type defaultDialect struct{}

func (d *defaultDialect) New(ctx context.Context, option Option, opts ...utils.OptionExtender) (
        r *Redis, err error) <span class="cov6" title="18">{
        if option.Cluster </span><span class="cov0" title="0">{
                opt := d.parseClusterOption(option)
                d.wrapDurationSetter(option.PoolTimeout, func(du time.Duration) </span><span class="cov0" title="0">{ opt.PoolTimeout = du }</span>)
                <span class="cov0" title="0">d.wrapDurationSetter(option.DialTimeout, func(du time.Duration) </span><span class="cov0" title="0">{ opt.DialTimeout = du }</span>)
                <span class="cov0" title="0">d.wrapDurationSetter(option.ReadTimeout, func(du time.Duration) </span><span class="cov0" title="0">{ opt.ReadTimeout = du }</span>)
                <span class="cov0" title="0">d.wrapDurationSetter(option.WriteTimeout, func(du time.Duration) </span><span class="cov0" title="0">{ opt.WriteTimeout = du }</span>)
                <span class="cov0" title="0">d.wrapDurationSetter(option.ConnMaxIdleTime, func(du time.Duration) </span><span class="cov0" title="0">{ opt.ConnMaxIdleTime = du }</span>)
                <span class="cov0" title="0">d.wrapDurationSetter(option.ConnMaxLifetime, func(du time.Duration) </span><span class="cov0" title="0">{ opt.ConnMaxLifetime = du }</span>)
                <span class="cov0" title="0">d.wrapDurationSetter(option.MinRetryBackoff, func(du time.Duration) </span><span class="cov0" title="0">{ opt.MinRetryBackoff = du }</span>)
                <span class="cov0" title="0">d.wrapDurationSetter(option.MaxRetryBackoff, func(du time.Duration) </span><span class="cov0" title="0">{ opt.MaxRetryBackoff = du }</span>)

                <span class="cov0" title="0">rdsCli := redis.NewClusterClient(opt)

                // authentication check
                if err = rdsCli.Ping(context.Background()).Err(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">newOpt := utils.ApplyOptions[newOption](opts...)
                for _, hook := range newOpt.hooks </span><span class="cov0" title="0">{
                        rdsCli.AddHook(hook)
                }</span>

                <span class="cov0" title="0">return &amp;Redis{redis: rdsCli}, nil</span>

        } else<span class="cov6" title="18"> {
                opt := d.parseOption(option)
                d.wrapDurationSetter(option.PoolTimeout, func(du time.Duration) </span><span class="cov0" title="0">{ opt.PoolTimeout = du }</span>)
                <span class="cov6" title="18">d.wrapDurationSetter(option.DialTimeout, func(du time.Duration) </span><span class="cov6" title="18">{ opt.DialTimeout = du }</span>)
                <span class="cov6" title="18">d.wrapDurationSetter(option.ReadTimeout, func(du time.Duration) </span><span class="cov6" title="18">{ opt.ReadTimeout = du }</span>)
                <span class="cov6" title="18">d.wrapDurationSetter(option.WriteTimeout, func(du time.Duration) </span><span class="cov6" title="18">{ opt.WriteTimeout = du }</span>)
                <span class="cov6" title="18">d.wrapDurationSetter(option.ConnMaxIdleTime, func(du time.Duration) </span><span class="cov6" title="18">{ opt.ConnMaxIdleTime = du }</span>)
                <span class="cov6" title="18">d.wrapDurationSetter(option.ConnMaxLifetime, func(du time.Duration) </span><span class="cov4" title="8">{ opt.ConnMaxLifetime = du }</span>)
                <span class="cov6" title="18">d.wrapDurationSetter(option.MinRetryBackoff, func(du time.Duration) </span><span class="cov6" title="18">{ opt.MinRetryBackoff = du }</span>)
                <span class="cov6" title="18">d.wrapDurationSetter(option.MaxRetryBackoff, func(du time.Duration) </span><span class="cov6" title="18">{ opt.MaxRetryBackoff = du }</span>)

                <span class="cov6" title="18">rdsCli := redis.NewClient(opt)

                // authentication check
                if err = rdsCli.Ping(context.Background()).Err(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov6" title="18">newOpt := utils.ApplyOptions[newOption](opts...)
                for _, hook := range newOpt.hooks </span><span class="cov6" title="18">{
                        rdsCli.AddHook(hook)
                }</span>

                <span class="cov6" title="18">return &amp;Redis{redis: rdsCli}, nil</span>
        }
}

func (d *defaultDialect) wrapDurationSetter(s string, setter func(du time.Duration)) <span class="cov10" title="144">{
        if utils.IsStrBlank(s) </span><span class="cov7" title="28">{
                return
        }</span>
        <span class="cov9" title="116">duration, err := time.ParseDuration(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov9" title="116">setter(duration)</span>
}

func (d *defaultDialect) parseOption(option Option) (cfg *redis.Options) <span class="cov6" title="18">{
        return &amp;redis.Options{
                Addr:         option.Endpoints[0],
                Username:     option.User,
                Password:     option.Password,
                MaxRetries:   option.MaxRetries,
                MinIdleConns: option.MinIdleConns,
                MaxIdleConns: option.MaxIdleConns,
                PoolSize:     option.PoolSize,
        }
}</span>

func (d *defaultDialect) parseClusterOption(option Option) (cfg *redis.ClusterOptions) <span class="cov0" title="0">{
        return &amp;redis.ClusterOptions{
                Addrs:        option.Endpoints,
                Username:     option.User,
                Password:     option.Password,
                MaxRetries:   option.MaxRetries,
                MinIdleConns: option.MinIdleConns,
                MaxIdleConns: option.MaxIdleConns,
                PoolSize:     option.PoolSize,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import (
        "io"
        "runtime/debug"

        "github.com/pkg/errors"
)

func Catch(fn any) (isPanic bool, err error) <span class="cov9" title="182440">{
        defer func() </span><span class="cov9" title="182295">{
                r := recover()
                if r == nil </span><span class="cov9" title="182236">{
                        return
                }</span>

                <span class="cov3" title="58">isPanic = true
                switch v := r.(type) </span>{
                case error:<span class="cov3" title="58">
                        err = errors.Wrapf(v, "panic when call Catch function =&gt;\n%s", debug.Stack())</span>
                default:<span class="cov0" title="0">
                        err = errors.Errorf("panic when call Catch function: %s =&gt;\n%s", r, debug.Stack())</span>
                }
        }()

        // check supported function
        <span class="cov9" title="182440">var v any
        switch f := fn.(type) </span>{
        case func():<span class="cov8" title="42092">
                f()</span>
        case func() error:<span class="cov9" title="140348">
                err = f()</span>
        case func() (any, error):<span class="cov0" title="0">
                v, err = f()</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unsupported function signature %T", fn))</span>
        }

        <span class="cov9" title="182253">if err != nil </span><span class="cov4" title="64">{
                return
        }</span>
        <span class="cov9" title="182188">if ve, ok := v.(error); ok </span><span class="cov0" title="0">{
                err = ve
        }</span>
        <span class="cov9" title="182186">return</span>
}

func CheckIfAny(fnList ...func() error) error <span class="cov2" title="5">{
        for _, fn := range fnList </span><span class="cov2" title="10">{
                if err := fn(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="5">return nil</span>
}

func IfAny(fnList ...func() bool) <span class="cov8" title="39267">{
        for _, fn := range fnList </span><span class="cov8" title="53047">{
                if fn() </span><span class="cov8" title="37952">{
                        break</span>
                }
        }
}

func MustSuccess(err error) <span class="cov10" title="260382">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func Must[T any](out T, err error) T <span class="cov7" title="8832">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov7" title="8832">return out</span>
}

func MustOk[T any](out T, ok bool) T <span class="cov0" title="0">{
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("get %T with ok is false", out))</span>
        }
        <span class="cov0" title="0">return out</span>
}

type closerA interface{ Close() }
type closerB[T any] interface{ Close() T }

func CloseAnyway[T any](closer T) <span class="cov9" title="107465">{
        if any(closer) == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="107456">switch c := any(closer).(type) </span>{
        case io.Closer:<span class="cov8" title="52328">
                _ = c.Close()</span>
        case closerA:<span class="cov8" title="20915">
                c.Close()</span>
        case closerB[T]:<span class="cov0" title="0">
                c.Close()</span>
        }
}

type flusherA interface{ Flush() }
type flusherB interface{ Flush() error }

func FlushAnyway[T any](flusher T) <span class="cov8" title="28142">{
        if any(flusher) == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="28142">switch f := any(flusher).(type) </span>{
        case flusherA:<span class="cov0" title="0">
                f.Flush()</span>
        case flusherB:<span class="cov7" title="6900">
                _ = f.Flush()</span>
        }
}

func ErrIgnore(src error, ignored ...error) (dst error) <span class="cov7" title="15440">{
        for _, target := range ignored </span><span class="cov8" title="30749">{
                if errors.Is(src, target) </span><span class="cov7" title="15378">{
                        return
                }</span>
        }
        <span class="cov3" title="61">return src</span>
}

type lookupByFuzzyKeywordFuncType[T any] interface {
        func(string) T |
                func(string) (T, bool) |
                func(string) (T, error)
}

func LookupByFuzzyKeyword[T any, F lookupByFuzzyKeywordFuncType[T]](lookup F, keyword string) (v T) <span class="cov5" title="844">{
        fn := WrapFunc1[T](lookup)
        for _, k := range FuzzyKeyword(keyword) </span><span class="cov7" title="8324">{
                if v = fn(k); !IsBlank(v) </span><span class="cov5" title="360">{
                        return
                }</span>
        }
        <span class="cov5" title="484">return</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package utils

func IsChannelClosed[T any](ch &lt;-chan T) (data T, ok bool) <span class="cov10" title="20">{
        select </span>{
        case d, closed := &lt;-ch:<span class="cov7" title="8">
                if closed </span><span class="cov0" title="0">{
                        ok = true
                        return
                }</span>
                <span class="cov7" title="8">return d, false</span>
        default:<span class="cov8" title="12">
                ok = true
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package cipher

import (
        "crypto/cipher"
        "errors"

        "github.com/wfusion/gofusion/common/utils"
)

const (
        blockSizeTimes   = 1 &lt;&lt; 10 // 1024 times
        defaultBlockSize = 16      // 16 bytes
)

type abstractAEADWrapper struct {
        cipher.AEAD
        overheadSize    int
        nonceSize       int
        blockSize       int
        plainBlockSize  int
        cipherBlockSize int
        sealedSize      int

        mode Mode
}

func newAbstractAEADWrapper(cipherAEAD cipher.AEAD, blockSize int, mode Mode) abstractAEADWrapper <span class="cov7" title="10551">{
        plainBlockSize := blockSize * blockSizeTimes
        return abstractAEADWrapper{
                AEAD:            cipherAEAD,
                overheadSize:    cipherAEAD.Overhead(),
                nonceSize:       cipherAEAD.NonceSize(),
                blockSize:       blockSize,
                plainBlockSize:  plainBlockSize,
                cipherBlockSize: cipherAEAD.NonceSize() + cipherAEAD.Overhead() + plainBlockSize,
                sealedSize:      cipherAEAD.Overhead() + plainBlockSize,
                mode:            mode,
        }
}</span>

func (a *abstractAEADWrapper) PlainBlockSize() int  <span class="cov8" title="20595">{ return a.plainBlockSize }</span>
func (a *abstractAEADWrapper) CipherBlockSize() int <span class="cov7" title="10551">{ return a.cipherBlockSize }</span>
func (a *abstractAEADWrapper) CipherMode() Mode     <span class="cov7" title="10551">{ return a.mode }</span>

type aeadEncryptWrapper struct {
        abstractAEADWrapper
}

func newAEADEncryptWrapper(cipherAEAD cipher.AEAD, blockSize int, mode Mode) blockMode <span class="cov7" title="5260">{
        return &amp;aeadEncryptWrapper{abstractAEADWrapper: newAbstractAEADWrapper(cipherAEAD, blockSize, mode)}
}</span>

func (a *aeadEncryptWrapper) CryptBlocks(dst, src, buf []byte) (n int, err error) <span class="cov9" title="197024">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="197021">nonce, cb := utils.BytesPool.Get(a.nonceSize)
        defer cb()
        if _, err = utils.CryptoRandom(nonce); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="197072">sealed := a.Seal(buf[:0], nonce, src[:utils.Min(a.plainBlockSize, len(src))], nil)
        copy(dst[:a.nonceSize], nonce)
        copy(dst[a.nonceSize:], sealed)
        n = len(nonce) + len(sealed)
        return</span>
}

type aeadDecryptWrapper struct {
        abstractAEADWrapper
}

func newAEADDecryptWrapper(cipherAEAD cipher.AEAD, blockSize int, mode Mode) blockMode <span class="cov7" title="5291">{
        return &amp;aeadDecryptWrapper{abstractAEADWrapper: newAbstractAEADWrapper(cipherAEAD, blockSize, mode)}
}</span>

func (a *aeadDecryptWrapper) CryptBlocks(dst, src, buf []byte) (n int, err error) <span class="cov9" title="197081">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="197079">sealedSize := utils.Min(a.sealedSize, len(src)-a.nonceSize)
        if sealedSize &lt; 0 </span><span class="cov0" title="0">{
                return 0, errors.New("input not full blocks when decrypt")
        }</span>

        <span class="cov9" title="197068">nonce := src[:a.nonceSize]
        src = src[a.nonceSize:]
        unsealed, err := a.Open(buf[:0], nonce, src[:sealedSize], nil)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="197096">copy(dst, unsealed)
        n = len(unsealed)
        return</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package cipher

import (
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
)

//go:generate stringer -type=Algorithm -trimprefix=Algorithm
type Algorithm uint8

const (
        AlgorithmUnknown Algorithm = iota
        AlgorithmDES
        Algorithm3DES
        AlgorithmAES
        AlgorithmRC4
        AlgorithmChaCha20poly1305
        AlgorithmXChaCha20poly1305
        AlgorithmSM4 // GM/T 0002-2012
)

var (
        algorithmEnum = utils.NewEnumString[Algorithm, []Algorithm](
                map[Algorithm]string{
                        AlgorithmDES:               "des",
                        Algorithm3DES:              "3des",
                        AlgorithmAES:               "aes",
                        AlgorithmRC4:               "rc4",
                        AlgorithmChaCha20poly1305:  "chacha20poly1305",
                        AlgorithmXChaCha20poly1305: "xchacha20poly1305",
                        AlgorithmSM4:               "sm4",
                },
        )
)

func (e Algorithm) Value() uint8 <span class="cov0" title="0">{
        return uint8(e)
}</span>

func (e Algorithm) String() string <span class="cov6" title="1062">{
        return algorithmEnum.String(e)
}</span>

func (e Algorithm) IsValid() bool <span class="cov10" title="144748">{
        return algorithmEnum.IsValid(e)
}</span>

func ParseAlgorithm(s any) Algorithm <span class="cov3" title="35">{
        switch v := s.(type) </span>{
        case string:<span class="cov3" title="35">
                if enumList := algorithmEnum.Enum(v); len(enumList) &gt; 0 </span><span class="cov3" title="35">{
                        return enumList[0]
                }</span>
        case Algorithm:<span class="cov0" title="0">
                return v</span>
        default:<span class="cov0" title="0">
                return Algorithm(cast.ToInt(s))</span>
        }
        <span class="cov0" title="0">return AlgorithmUnknown</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package cipher

import (
        "crypto/cipher"

        "github.com/wfusion/gofusion/common/utils"
)

type blockModeWrapper struct {
        block     cipher.Block
        blockMode cipher.BlockMode
        stream    cipher.Stream
        blockSize int

        mode      Mode
        isEncoder bool
}

type blockModeOption struct {
        block     cipher.Block
        blockMode cipher.BlockMode
        stream    cipher.Stream
        mode      Mode
        isEncoder bool
}

func wrapBlock(block cipher.Block, mode Mode, isEncoder bool) utils.OptionFunc[blockModeOption] <span class="cov5" title="5736">{
        return func(o *blockModeOption) </span><span class="cov5" title="5736">{
                o.mode = mode
                o.block = block
                o.isEncoder = isEncoder
        }</span>
}

func wrapBlockMode(bm cipher.BlockMode, mode Mode) utils.OptionFunc[blockModeOption] <span class="cov5" title="5736">{
        return func(o *blockModeOption) </span><span class="cov5" title="5736">{
                o.mode = mode
                o.blockMode = bm
        }</span>
}

func wrapStream(stream cipher.Stream, mode Mode) utils.OptionFunc[blockModeOption] <span class="cov6" title="31523">{
        return func(o *blockModeOption) </span><span class="cov6" title="31523">{
                o.mode = mode
                o.stream = stream
        }</span>
}

func newBlockModeWrapper(opts ...utils.OptionExtender) (w *blockModeWrapper) <span class="cov6" title="42996">{
        opt := utils.ApplyOptions[blockModeOption](opts...)
        w = &amp;blockModeWrapper{
                block:     opt.block,
                blockMode: opt.blockMode,
                stream:    opt.stream,
                blockSize: 0,
                mode:      opt.mode,
                isEncoder: opt.isEncoder,
        }

        switch </span>{
        case opt.block != nil:<span class="cov5" title="5736">
                w.blockSize = w.block.BlockSize()</span>
        case opt.blockMode != nil:<span class="cov5" title="5736">
                w.blockSize = w.blockMode.BlockSize()</span>
        case opt.stream != nil:<span class="cov6" title="31521">
                w.blockSize = defaultBlockSize * blockSizeTimes</span>
        }

        <span class="cov6" title="42992">return</span>
}

func (b *blockModeWrapper) CipherMode() Mode     <span class="cov6" title="42993">{ return b.mode }</span>
func (b *blockModeWrapper) PlainBlockSize() int  <span class="cov6" title="78822">{ return b.blockSize }</span>
func (b *blockModeWrapper) CipherBlockSize() int <span class="cov6" title="42970">{ return b.blockSize }</span>
func (b *blockModeWrapper) CryptBlocks(dst, src, buf []byte) (n int, err error) <span class="cov9" title="47413803">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="47453328">n = len(src)
        switch </span>{
        case b.blockMode != nil:<span class="cov9" title="23654533">
                b.blockMode.CryptBlocks(dst, src)</span>
        case b.block != nil:<span class="cov9" title="23599172">
                if b.isEncoder </span><span class="cov9" title="11950573">{
                        b.block.Encrypt(dst, src)
                }</span> else<span class="cov9" title="12148236"> {
                        b.block.Decrypt(dst, src)
                }</span>
        case b.stream != nil:<span class="cov8" title="1181738">
                b.stream.XORKeyStream(dst, src)</span>
        default:<span class="cov0" title="0">
                copy(dst, src)</span>
        }
        <span class="cov10" title="49197993">return</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package cipher

import (
        "crypto/cipher"
        "errors"
        "fmt"
        "io"

        "github.com/wfusion/gofusion/common/utils"
)

func DecryptBytesFunc(algo Algorithm, mode Mode, key, iv []byte) (
        enc func(src []byte) (dst []byte, err error), err error) <span class="cov6" title="18646">{
        bm, err := getDecrypter(algo, mode, key, iv)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="18646">mode = bm.CipherMode()
        return func(src []byte) (dst []byte, err error) </span><span class="cov6" title="18646">{
                dst, err = decrypt(bm, src)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov6" title="18646">if mode.ShouldPadding() </span><span class="cov5" title="5724">{
                        dst, err = PKCS7Unpad(dst)
                }</span>
                <span class="cov6" title="18646">return</span>
        }, err
}

func DecryptStreamFunc(algo Algorithm, mode Mode, key, iv []byte) (
        dec func(dst io.Writer, src io.Reader) (err error), err error) <span class="cov3" title="162">{
        var fn func(src io.Reader) io.ReadCloser

        _, err = utils.Catch(func() </span><span class="cov3" title="162">{ fn = NewDecFunc(algo, mode, key, iv) }</span>)
        <span class="cov3" title="162">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="162">dec = func(dst io.Writer, src io.Reader) (err error) </span><span class="cov3" title="162">{
                buf, cb := utils.BytesPool.Get(defaultBlockSize * blockSizeTimes)
                defer cb()

                wrapper := fn(src)
                defer utils.CloseAnyway(wrapper)
                _, err = io.CopyBuffer(dst, wrapper, buf)
                return
        }</span>

        <span class="cov3" title="162">return</span>
}

func decrypt(bm blockMode, src []byte) (dst []byte, err error) <span class="cov8" title="1468605">{
        plainBlockSize := bm.PlainBlockSize()
        cipherBlockSize := bm.CipherBlockSize()
        defers := make([]func(), 0, 3)

        w, cb := utils.BytesBufferPool.Get(nil)
        defers = append(defers, cb)

        if plainBlockSize != 0 &amp;&amp; cipherBlockSize != 0 </span><span class="cov6" title="17215">{
                w.Grow((len(src) / cipherBlockSize) * plainBlockSize)
        }</span> else<span class="cov8" title="1451237"> {
                plainBlockSize, cipherBlockSize = len(src), len(src)
                w.Grow(plainBlockSize)
        }</span>

        <span class="cov8" title="1468289">unsealed, cb := utils.BytesPool.Get(plainBlockSize)
        defers = append(defers, cb)

        buf, cb := utils.BytesPool.Get(plainBlockSize)
        defers = append(defers, cb)

        var n, blockSize int
        for len(src) &gt; 0 </span><span class="cov10" title="25267679">{
                blockSize = utils.Min(cipherBlockSize, len(src))
                n, err = bm.CryptBlocks(unsealed[:plainBlockSize], src[:blockSize], buf)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="25217397">if _, err = w.Write(unsealed[:n]); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="25266513">src = src[blockSize:]</span>
        }

        <span class="cov8" title="1468724">bs := w.Bytes()
        dst = make([]byte, len(bs))
        copy(dst, bs)
        return</span>
}

func getDecrypter(algo Algorithm, mode Mode, key, iv []byte) (bm blockMode, err error) <span class="cov6" title="29617">{
        if blockMapping, ok := cipherBlockMapping[algo]; ok </span><span class="cov6" title="24852">{
                var cipherBlock cipher.Block
                cipherBlock, err = blockMapping(key)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov6" title="24852">modeMapping, ok := decryptModeMapping[mode]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown cipher mode %+v", mode)
                }</span>
                <span class="cov6" title="24852">bm, err = modeMapping(cipherBlock, iv)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // stream
        <span class="cov6" title="29618">if bm == nil </span><span class="cov5" title="4765">{
                blockMapping, ok := streamDecryptMapping[algo]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown cipher algorithm %+v", algo)
                }</span>
                <span class="cov5" title="4765">if bm, err = blockMapping(key); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov6" title="29618">if bm == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unknown cipher algorithm(%+v) or mode(%+v)", algo, mode)
        }</span>

        <span class="cov6" title="29618">return</span>
}

type dec struct {
        bm blockMode
        r  io.Reader

        buf  []byte
        cb   func()
        n    int // current position in buf
        end  int // end of data in buf
        size int

        eof                 bool
        unsealed, unsealBuf []byte
}

func NewDecFunc(algo Algorithm, mode Mode, key, iv []byte) func(r io.Reader) io.ReadCloser <span class="cov5" title="10971">{
        bm, err := getDecrypter(algo, mode, key, iv)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov5" title="10972">if !bm.CipherMode().SupportStream() </span><span class="cov0" title="0">{
                panic(ErrNotSupportStream)</span>
        }

        <span class="cov5" title="10972">var (
                buf, unsealed, unsealBuf []byte
                cb                       func()
                size                     int
        )

        if size = bm.CipherBlockSize(); size &gt; 0 </span><span class="cov5" title="9544">{
                var bcb, ucb, ubcb func()
                buf, bcb = utils.BytesPool.Get(size)
                unsealed, ucb = utils.BytesPool.Get(bm.PlainBlockSize())
                unsealBuf, ubcb = utils.BytesPool.Get(bm.PlainBlockSize())
                cb = func() </span><span class="cov5" title="9544">{ bcb(); ucb(); ubcb() }</span>
        }

        <span class="cov5" title="10971">return func(r io.Reader) io.ReadCloser </span><span class="cov5" title="10971">{
                return &amp;dec{
                        bm:        bm,
                        r:         r,
                        buf:       buf,
                        cb:        cb,
                        n:         0,
                        end:       0,
                        size:      size,
                        eof:       false,
                        unsealed:  unsealed,
                        unsealBuf: unsealBuf,
                }
        }</span>
}

func (d *dec) Read(p []byte) (n int, err error) <span class="cov9" title="6373624">{
        var (
                nr, nc int
                dst    []byte
        )

        if d.buf == nil </span><span class="cov8" title="1449922">{
                n, err = d.r.Read(p)
                d.eof = errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF)
                if err != nil &amp;&amp; !d.eof </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1450655">dst, err = decrypt(d.bm, p[:n])
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1448820">n = copy(p[:len(dst)], dst)
                if d.eof </span><span class="cov4" title="1428">{
                        err = io.EOF
                }</span>
                <span class="cov8" title="1449290">return</span>
        }

        <span class="cov9" title="4929110">for len(p) &gt; 0 </span><span class="cov9" title="6293336">{
                // read from buffer
                if length := d.end - d.n; length &gt; 0 </span><span class="cov9" title="5539999">{
                        copied := utils.Min(length, len(p))
                        n += copy(p[:copied], d.buf[d.n:d.n+copied])
                        d.n += copied
                        p = p[copied:]
                        continue</span>
                }

                // buffer is empty, write new buffer
                <span class="cov8" title="758003">if d.eof </span><span class="cov5" title="9544">{
                        return n, io.EOF
                }</span>
                <span class="cov8" title="748471">d.n = 0
                d.end = 0
                for </span><span class="cov9" title="5651123">{
                        nr, err = d.r.Read(d.buf[d.n:d.size])
                        d.eof = errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF)
                        if err != nil &amp;&amp; !d.eof </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov9" title="5653822">d.n += nr
                        if d.n &lt; d.size &amp;&amp; !d.eof </span><span class="cov9" title="4906870">{
                                continue</span>
                        }

                        <span class="cov8" title="748807">nc, err = d.bm.CryptBlocks(d.unsealed, d.buf[:d.n], d.unsealBuf)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="748601">d.end += copy(d.buf[:nc], d.unsealed[:nc])
                        d.n = 0
                        break</span>
                }
        }

        <span class="cov9" title="4909078">return</span>
}

func (d *dec) Close() (err error) <span class="cov5" title="10972">{
        utils.CloseAnyway(d.r)
        if d.cb != nil </span><span class="cov5" title="9544">{
                d.cb()
        }</span>
        <span class="cov5" title="10972">return</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package cipher

import (
        "crypto/cipher"
        "fmt"
        "io"

        "github.com/wfusion/gofusion/common/utils"
)

func EncryptBytesFunc(algo Algorithm, mode Mode, key, iv []byte) (
        enc func(src []byte) (dst []byte, err error), err error) <span class="cov6" title="18599">{
        bm, err := getEncrypter(algo, mode, key, iv)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="18602">mode = bm.CipherMode()
        plainBlockSize := bm.PlainBlockSize()
        return func(src []byte) (dst []byte, err error) </span><span class="cov6" title="18603">{
                if mode.ShouldPadding() </span><span class="cov5" title="5724">{
                        src = PKCS7Pad(src, plainBlockSize)
                }</span>
                <span class="cov6" title="18602">return encrypt(bm, src)</span>
        }, err
}

func EncryptStreamFunc(algo Algorithm, mode Mode, key, iv []byte) (
        enc func(dst io.Writer, src io.Reader) (err error), err error) <span class="cov3" title="239">{
        var fn func(w io.Writer) io.WriteCloser

        _, err = utils.Catch(func() </span><span class="cov3" title="240">{ fn = NewEncFunc(algo, mode, key, iv) }</span>)
        <span class="cov3" title="240">if err != nil </span><span class="cov2" title="24">{
                return nil, err
        }</span>

        <span class="cov3" title="216">enc = func(dst io.Writer, src io.Reader) (err error) </span><span class="cov3" title="162">{
                buf, cb := utils.BytesPool.Get(defaultBlockSize * blockSizeTimes)
                defer cb()

                wrapper := fn(dst)
                defer utils.CloseAnyway(wrapper)

                _, err = io.CopyBuffer(wrapper, src, buf)
                return
        }</span>

        <span class="cov3" title="216">return</span>
}

func encrypt(bm blockMode, src []byte) (dst []byte, err error) <span class="cov8" title="844189">{
        plainBlockSize := bm.PlainBlockSize()
        cipherBlockSize := bm.CipherBlockSize()
        defers := make([]func(), 0, 3)
        defer func() </span><span class="cov8" title="844123">{
                for _, cb := range defers </span><span class="cov8" title="2531117">{
                        cb()
                }</span>
        }()

        <span class="cov8" title="844022">w, cb := utils.BytesBufferPool.Get(nil)
        defers = append(defers, cb)

        if plainBlockSize != 0 &amp;&amp; cipherBlockSize != 0 </span><span class="cov6" title="17172">{
                w.Grow((len(src) / plainBlockSize) * cipherBlockSize)
        }</span> else<span class="cov8" title="827111"> {
                plainBlockSize, cipherBlockSize = len(src), len(src)
                w.Grow(cipherBlockSize)
        }</span>

        <span class="cov8" title="844330">sealed, cb := utils.BytesPool.Get(cipherBlockSize)
        defers = append(defers, cb)

        buf, cb := utils.BytesPool.Get(plainBlockSize)
        defers = append(defers, cb)

        var n, blockSize int
        for len(src) &gt; 0 </span><span class="cov9" title="24397777">{
                blockSize = utils.Min(plainBlockSize, len(src))
                n, err = bm.CryptBlocks(sealed[:cipherBlockSize], src[:blockSize], buf)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov10" title="24406272">if _, err = w.Write(sealed[:n]); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="24405073">src = src[blockSize:]</span>
        }

        <span class="cov8" title="844331">bs := w.Bytes()
        dst = make([]byte, len(bs))
        copy(dst, bs)
        return</span>
}

func getEncrypter(algo Algorithm, mode Mode, key, iv []byte) (bm blockMode, err error) <span class="cov6" title="29649">{
        if blockMapping, ok := cipherBlockMapping[algo]; ok </span><span class="cov6" title="24874">{
                var cipherBlock cipher.Block
                cipherBlock, err = blockMapping(key)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov6" title="24877">modeMapping, ok := encryptModeMapping[mode]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown cipher mode %+v", mode)
                }</span>
                <span class="cov6" title="24877">bm, err = modeMapping(cipherBlock, iv)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // stream
        <span class="cov6" title="29649">if bm == nil </span><span class="cov5" title="4775">{
                blockMapping, ok := streamEncryptMapping[algo]
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unknown cipher algorithm %+v", algo)
                }</span>
                <span class="cov5" title="4775">if bm, err = blockMapping(key); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov6" title="29650">if bm == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unknown cipher algorithm(%+v) or mode(%+v)", algo, mode)
        }</span>

        <span class="cov6" title="29650">return</span>
}

type enc struct {
        bm blockMode
        w  io.Writer

        n   int
        buf []byte
        cb  func()

        sealed, sealBuf []byte
}

func NewEncFunc(algo Algorithm, mode Mode, key, iv []byte) func(w io.Writer) io.WriteCloser <span class="cov5" title="11050">{
        bm, err := getEncrypter(algo, mode, key, iv)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov5" title="11048">if !bm.CipherMode().SupportStream() </span><span class="cov2" title="24">{
                panic(ErrNotSupportStream)</span>
        }

        <span class="cov5" title="11026">var (
                buf, sealed, sealBuf []byte
                cb                   func()
        )
        if bm.PlainBlockSize() &gt; 0 </span><span class="cov5" title="9592">{
                var bcb, scb, sbcb func()
                buf, bcb = utils.BytesPool.Get(bm.PlainBlockSize())
                sealed, scb = utils.BytesPool.Get(bm.CipherBlockSize())
                sealBuf, sbcb = utils.BytesPool.Get(bm.PlainBlockSize())
                cb = func() </span><span class="cov5" title="9544">{ bcb(); scb(); sbcb() }</span>
        }

        <span class="cov5" title="11025">return func(w io.Writer) io.WriteCloser </span><span class="cov5" title="10971">{
                return &amp;enc{
                        bm:      bm,
                        w:       w,
                        n:       0,
                        buf:     buf,
                        cb:      cb,
                        sealed:  sealed,
                        sealBuf: sealBuf,
                }
        }</span>
}

func (e *enc) Write(p []byte) (n int, err error) <span class="cov9" title="6326019">{
        if e.buf == nil </span><span class="cov8" title="826069">{
                var dst []byte
                dst, err = encrypt(e.bm, p)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="825782">n = len(p)
                _, err = e.w.Write(dst)
                return</span>
        }

        <span class="cov9" title="5502075">written := 0
        for len(p) &gt; 0 </span><span class="cov9" title="6075238">{
                nCopy := utils.Min(len(p), len(e.buf)-e.n)
                copy(e.buf[e.n:], p[:nCopy])
                e.n += nCopy
                written += nCopy
                p = p[nCopy:]

                if e.n == len(e.buf) </span><span class="cov8" title="739016">{
                        if err = e.flush(); err != nil </span><span class="cov0" title="0">{
                                return written, err
                        }</span>
                }
        }

        <span class="cov9" title="5483759">return written, nil</span>
}

func (e *enc) flush() (err error) <span class="cov8" title="748545">{
        if e.buf == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="748547">n, err := e.bm.CryptBlocks(e.sealed, e.buf[:e.n], e.sealBuf)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="748612">_, err = e.w.Write(e.sealed[:n])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="748441">e.n = 0
        return</span>
}

func (e *enc) Flush() (err error) <span class="cov6" title="14422">{
        defer utils.FlushAnyway(e.w)
        if e.n &gt; 0 </span><span class="cov5" title="9544">{
                err = e.flush()
        }</span>
        <span class="cov6" title="14422">return</span>
}

func (e *enc) Close() (err error) <span class="cov5" title="10972">{
        defer func() </span><span class="cov5" title="10972">{
                utils.CloseAnyway(e.w)
                if e.cb != nil </span><span class="cov5" title="9544">{
                        e.cb()
                }</span>
        }()

        <span class="cov5" title="10972">return e.Flush()</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package cipher

import (
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
)

//go:generate stringer -type=Mode -trimprefix=Mode
type Mode uint8

const (
        ModeUnknown Mode = iota
        ModeECB
        ModeCBC
        ModeCFB
        ModeCTR
        ModeOFB
        ModeGCM
        // modeStream may be ECB but not, it is unnecessary for padding like ECB or CBC
        modeStream
)

var (
        modeEnum = utils.NewEnumString[Mode, []Mode](
                map[Mode]string{
                        ModeECB:    "ecb",
                        ModeCBC:    "cbc",
                        ModeCFB:    "cfb",
                        ModeCTR:    "ctr",
                        ModeOFB:    "ofb",
                        ModeGCM:    "gcm",
                        modeStream: "stream",
                },
        )
        ivMode      = utils.NewSet(ModeCBC, ModeCFB, ModeCTR, ModeOFB)
        streamMode  = utils.NewSet(ModeCFB, ModeCTR, ModeOFB, ModeGCM, modeStream)
        paddingMode = utils.NewSet(ModeECB, ModeCBC)
)

func (m Mode) Value() uint8 <span class="cov0" title="0">{
        return uint8(m)
}</span>

func (m Mode) String() string <span class="cov6" title="875">{
        return modeEnum.String(m)
}</span>

func (m Mode) IsValid() bool <span class="cov3" title="17">{
        return modeEnum.IsValid(m)
}</span>

func (m Mode) ShouldPadding() bool <span class="cov10" title="37249">{
        return paddingMode.Contains(m)
}</span>

func (m Mode) NeedIV() bool <span class="cov3" title="17">{
        return ivMode.Contains(m)
}</span>

func (m Mode) SupportStream() bool <span class="cov9" title="22019">{
        return streamMode.Contains(m)
}</span>

func ParseMode(s any) Mode <span class="cov4" title="35">{
        switch v := s.(type) </span>{
        case string:<span class="cov4" title="35">
                if enumList := modeEnum.Enum(v); len(enumList) &gt; 0 </span><span class="cov4" title="35">{
                        return enumList[0]
                }</span>
        case Mode:<span class="cov0" title="0">
                return v</span>
        default:<span class="cov0" title="0">
                return Mode(cast.ToInt(s))</span>
        }
        <span class="cov0" title="0">return ModeUnknown</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package cipher

import (
        "bytes"
        "github.com/pkg/errors"
)

// PKCS7Pad Apply PKCS#7 padding
func PKCS7Pad(data []byte, blockSize int) []byte <span class="cov8" title="5724">{
        if blockSize == 0 </span><span class="cov0" title="0">{
                return data
        }</span>
        <span class="cov8" title="5724">padding := blockSize - len(data)%blockSize
        return append(data, bytes.Repeat([]byte{byte(padding)}, padding)...)</span>
}

// PKCS7Unpad Remove PKCS#7 padding
func PKCS7Unpad(data []byte) ([]byte, error) <span class="cov8" title="5724">{
        length := len(data)
        if length == 0 </span><span class="cov0" title="0">{
                return data, nil
        }</span>
        <span class="cov8" title="5724">padding := int(data[length-1])
        if padding == 0 || padding &gt; len(data) </span><span class="cov0" title="0">{
                return data, errors.New("invalid pkcs7 padding (padding size &gt; data)")
        }</span>
        <span class="cov8" title="5724">for i := 1; i &lt; padding; i++ </span><span class="cov10" title="46104">{
                if data[length-1-i] != byte(padding) </span><span class="cov0" title="0">{
                        return data, errors.New("invalid pkcs7 padding (pad[i] != padding text)")
                }</span>
        }

        <span class="cov8" title="5724">return data[:(length - padding)], nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package cipher

import "crypto/rc4"

type rc4Wrapper struct {
        rc *rc4.Cipher
}

func (r *rc4Wrapper) CipherMode() Mode     <span class="cov6" title="5724">{ return modeStream }</span>
func (r *rc4Wrapper) PlainBlockSize() int  <span class="cov10" title="2279304">{ return 0 }</span>
func (r *rc4Wrapper) CipherBlockSize() int <span class="cov9" title="2277938">{ return 0 }</span>
func (r *rc4Wrapper) CryptBlocks(dst, src, buf []byte) (n int, err error) <span class="cov9" title="2276295">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="2276267">r.rc.XORKeyStream(dst, src)
        n = len(src)
        return</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package cipher

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/des"
        "crypto/rc4"
        "errors"

        "github.com/tjfoc/gmsm/sm4"
        "golang.org/x/crypto/chacha20poly1305"
)

type blockMode interface {
        CipherMode() Mode
        PlainBlockSize() int
        CipherBlockSize() int
        CryptBlocks(dst, src, buf []byte) (n int, err error)
}

const (
        RndSeed int64 = -3250455768463625913
)

var (
        // ErrNotSupportStream for stream encryption
        ErrNotSupportStream = errors.New("not support stream encryption mode")
)

var (
        cipherBlockMapping = map[Algorithm]func(key []byte) (cipher.Block, error){
                AlgorithmDES:  func(key []byte) (cipher.Block, error) <span class="cov8" title="7636">{ return des.NewCipher(key) }</span>,
                Algorithm3DES: func(key []byte) (cipher.Block, error) <span class="cov8" title="7636">{ return des.NewTripleDESCipher(key) }</span>,
                AlgorithmAES:  func(key []byte) (cipher.Block, error) <span class="cov9" title="28631">{ return aes.NewCipher(key) }</span>,
                AlgorithmSM4:  func(key []byte) (cipher.Block, error) <span class="cov8" title="5825">{ return sm4.NewCipher(key) }</span>,
        }

        encryptModeMapping = map[Mode]func(b cipher.Block, iv []byte) (e blockMode, err error){
                ModeECB: func(b cipher.Block, iv []byte) (e blockMode, err error) <span class="cov7" title="2874">{
                        return wrapErr(newBlockModeWrapper(
                                wrapBlock(b, ModeECB, true)),
                        )
                }</span>,
                ModeCBC: func(b cipher.Block, iv []byte) (e blockMode, err error) <span class="cov7" title="2874">{
                        return wrapErr(newBlockModeWrapper(
                                wrapBlockMode(cipher.NewCBCEncrypter(b, iv), ModeCBC)),
                        )
                }</span>,
                ModeCFB: func(b cipher.Block, iv []byte) (e blockMode, err error) <span class="cov8" title="5260">{
                        return wrapErr(newBlockModeWrapper(
                                wrapStream(cipher.NewCFBEncrypter(b, iv), ModeCFB)),
                        )
                }</span>,
                ModeCTR: func(b cipher.Block, iv []byte) (e blockMode, err error) <span class="cov8" title="5260">{
                        return wrapErr(newBlockModeWrapper(
                                wrapStream(cipher.NewCTR(b, iv), ModeCTR)),
                        )
                }</span>,
                ModeOFB: func(b cipher.Block, iv []byte) (e blockMode, err error) <span class="cov8" title="5260">{
                        return wrapErr(newBlockModeWrapper(
                                wrapStream(cipher.NewOFB(b, iv), ModeOFB)),
                        )
                }</span>,
                ModeGCM: func(b cipher.Block, iv []byte) (e blockMode, err error) <span class="cov7" title="3350">{
                        aead, err := cipher.NewGCM(b)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov7" title="3350">e = newAEADEncryptWrapper(aead, b.BlockSize(), ModeGCM)
                        return</span>
                },
        }
        decryptModeMapping = map[Mode]func(b cipher.Block, iv []byte) (bm blockMode, err error){
                ModeECB: func(b cipher.Block, iv []byte) (e blockMode, err error) <span class="cov7" title="2862">{
                        return wrapErr(newBlockModeWrapper(
                                wrapBlock(b, ModeECB, false)),
                        )
                }</span>,
                ModeCBC: func(b cipher.Block, iv []byte) (bm blockMode, err error) <span class="cov7" title="2862">{
                        return wrapErr(newBlockModeWrapper(
                                wrapBlockMode(cipher.NewCBCDecrypter(b, iv), ModeCBC)),
                        )
                }</span>,
                ModeCFB: func(b cipher.Block, iv []byte) (bm blockMode, err error) <span class="cov8" title="5248">{
                        return wrapErr(newBlockModeWrapper(
                                wrapStream(cipher.NewCFBDecrypter(b, iv), ModeCFB)),
                        )
                }</span>,
                ModeCTR: func(b cipher.Block, iv []byte) (bm blockMode, err error) <span class="cov8" title="5248">{
                        return wrapErr(newBlockModeWrapper(
                                wrapStream(cipher.NewCTR(b, iv), ModeCTR)),
                        )
                }</span>,
                ModeOFB: func(b cipher.Block, iv []byte) (bm blockMode, err error) <span class="cov8" title="5248">{
                        return wrapErr(newBlockModeWrapper(
                                wrapStream(cipher.NewOFB(b, iv), ModeOFB)),
                        )
                }</span>,
                ModeGCM: func(b cipher.Block, iv []byte) (bm blockMode, err error) <span class="cov7" title="3385">{
                        cipherAEAD, err := cipher.NewGCM(b)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov7" title="3385">bm = newAEADDecryptWrapper(cipherAEAD, b.BlockSize(), ModeGCM)
                        return</span>
                },
        }

        streamEncryptMapping = map[Algorithm]func(key []byte) (bm blockMode, err error){
                AlgorithmRC4: func(key []byte) (bm blockMode, err error) <span class="cov7" title="2865">{
                        cipher, err := rc4.NewCipher(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov7" title="2865">bm = &amp;rc4Wrapper{rc: cipher}
                        return</span>
                },
                AlgorithmChaCha20poly1305: func(key []byte) (bm blockMode, err error) <span class="cov6" title="955">{
                        cipherAEAD, err := chacha20poly1305.New(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov6" title="955">bm = newAEADEncryptWrapper(cipherAEAD, defaultBlockSize, modeStream)
                        return</span>
                },
                AlgorithmXChaCha20poly1305: func(key []byte) (bm blockMode, err error) <span class="cov6" title="955">{
                        cipherAEAD, err := chacha20poly1305.NewX(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov6" title="955">bm = newAEADEncryptWrapper(cipherAEAD, defaultBlockSize, modeStream)
                        return</span>
                },
        }
        streamDecryptMapping = map[Algorithm]func(key []byte) (bm blockMode, err error){
                AlgorithmRC4: func(key []byte) (bm blockMode, err error) <span class="cov7" title="2859">{
                        cipher, err := rc4.NewCipher(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov7" title="2859">bm = &amp;rc4Wrapper{rc: cipher}
                        return</span>
                },
                AlgorithmChaCha20poly1305: func(key []byte) (bm blockMode, err error) <span class="cov6" title="953">{
                        cipherAEAD, err := chacha20poly1305.New(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov6" title="953">bm = newAEADDecryptWrapper(cipherAEAD, defaultBlockSize, modeStream)
                        return</span>
                },
                AlgorithmXChaCha20poly1305: func(key []byte) (bm blockMode, err error) <span class="cov6" title="953">{
                        cipherAEAD, err := chacha20poly1305.NewX(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov6" title="953">bm = newAEADDecryptWrapper(cipherAEAD, defaultBlockSize, modeStream)
                        return</span>
                },
        }
)

func wrapErr[T any](a T) (b T, err error) <span class="cov10" title="42992">{ b = a; return }</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2023 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package clone

import (
        "reflect"
        "runtime"
        "sync"
        "unsafe"

        "github.com/wfusion/gofusion/common/utils"
)

var typeOfAllocator = reflect.TypeOf(Allocator{})

// defaultAllocator is the default allocator and allocates memory from heap.
var defaultAllocator = &amp;Allocator{
        new:       heapNew,
        makeSlice: heapMakeSlice,
        makeMap:   heapMakeMap,
        makeChan:  heapMakeChan,
        isScalar:  IsScalar,
}

// Allocator is a utility type for memory allocation.
type Allocator struct {
        parent *Allocator

        pool      unsafe.Pointer
        new       func(pool unsafe.Pointer, t reflect.Type) reflect.Value
        makeSlice func(pool unsafe.Pointer, t reflect.Type, len, cap int) reflect.Value
        makeMap   func(pool unsafe.Pointer, t reflect.Type, n int) reflect.Value
        makeChan  func(pool unsafe.Pointer, t reflect.Type, buffer int) reflect.Value
        isScalar  func(t reflect.Kind) bool

        cachedStructTypes     sync.Map
        cachedPointerTypes    sync.Map
        cachedCustomFuncTypes sync.Map
}

// FromHeap creates an allocator which allocate memory from heap.
func fromHeap() *Allocator <span class="cov0" title="0">{
        return newAllocator(nil, nil)
}</span>

// NewAllocator creates an allocator which allocate memory from the pool.
// Both pool and methods are optional.
//
// If methods.New is not nil, the allocator itself is created by calling methods.New.
//
// The pool is a pointer to the memory pool which is opaque to the allocator.
// It's methods' responsibility to allocate memory from the pool properly.
func newAllocator(pool unsafe.Pointer, methods *AllocatorMethods) (allocator *Allocator) <span class="cov0" title="0">{
        parent := methods.parent()
        new := methods.new(parent, pool)

        // Allocate the allocator from the pool.
        val := new(pool, typeOfAllocator)
        allocator = (*Allocator)(unsafe.Pointer(val.Pointer()))
        runtime.KeepAlive(val)

        allocator.pool = pool
        allocator.new = new
        allocator.makeSlice = methods.makeSlice(parent, pool)
        allocator.makeMap = methods.makeMap(parent, pool)
        allocator.makeChan = methods.makeChan(parent, pool)
        allocator.isScalar = methods.isScalar(parent)

        if parent == nil </span><span class="cov0" title="0">{
                parent = defaultAllocator
        }</span>

        <span class="cov0" title="0">allocator.parent = parent
        return</span>
}

// New returns a new zero value of t.
func (a *Allocator) New(t reflect.Type) reflect.Value <span class="cov10" title="7321116">{
        return a.new(a.pool, t)
}</span>

// MakeSlice creates a new zero-initialized slice value of t with len and cap.
func (a *Allocator) MakeSlice(t reflect.Type, len, cap int) reflect.Value <span class="cov8" title="832401">{
        return a.makeSlice(a.pool, t, len, cap)
}</span>

// MakeMap creates a new map with minimum size n.
func (a *Allocator) MakeMap(t reflect.Type, n int) reflect.Value <span class="cov7" title="95914">{
        return a.makeMap(a.pool, t, n)
}</span>

// MakeChan creates a new chan with buffer.
func (a *Allocator) MakeChan(t reflect.Type, buffer int) reflect.Value <span class="cov0" title="0">{
        return a.makeChan(a.pool, t, buffer)
}</span>

// Clone recursively deep clone val to a new value with memory allocated from a.
func (a *Allocator) Clone(val reflect.Value) reflect.Value <span class="cov0" title="0">{
        return a.clone(val, true)
}</span>

func (a *Allocator) clone(val reflect.Value, inCustomFunc bool) reflect.Value <span class="cov7" title="51143">{
        if !val.IsValid() </span><span class="cov0" title="0">{
                return val
        }</span>

        <span class="cov7" title="51144">state := &amp;cloneState{
                allocator: a,
        }

        if inCustomFunc </span><span class="cov0" title="0">{
                state.skipCustomFuncValue = val
        }</span>

        <span class="cov7" title="51144">return state.clone(val)</span>
}

// CloneSlowly recursively deep clone val to a new value with memory allocated from a.
// It marks all cloned values internally, thus it can clone v with cycle pointer.
func (a *Allocator) CloneSlowly(val reflect.Value) reflect.Value <span class="cov0" title="0">{
        return a.cloneSlowly(val, true)
}</span>

func (a *Allocator) cloneSlowly(val reflect.Value, inCustomFunc bool) reflect.Value <span class="cov4" title="711">{
        if !val.IsValid() </span><span class="cov0" title="0">{
                return val
        }</span>

        <span class="cov4" title="711">state := &amp;cloneState{
                allocator: a,
                visited:   visitMap{},
                invalid:   invalidPointers{},
        }

        if inCustomFunc </span><span class="cov0" title="0">{
                state.skipCustomFuncValue = val
        }</span>

        <span class="cov4" title="711">cloned := state.clone(val)
        state.fix(cloned)
        return cloned</span>
}

func (a *Allocator) loadStructType(t reflect.Type) (st structType) <span class="cov8" title="850549">{
        st, ok := a.lookupStructType(t)

        if ok </span><span class="cov8" title="853608">{
                return
        }</span>

        <span class="cov4" title="217">num := t.NumField()
        pointerFields := make([]structFieldType, 0, num)

        // Find pointer fields in depth-first order.
        for i := 0; i &lt; num; i++ </span><span class="cov5" title="1518">{
                field := t.Field(i)
                ft := field.Type
                k := ft.Kind()

                if a.isScalar(k) </span><span class="cov4" title="1030">{
                        continue</span>
                }

                <span class="cov4" title="488">switch k </span>{
                case reflect.Array:<span class="cov1" title="2">
                        if ft.Len() == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="2">elem := ft.Elem()

                        if a.isScalar(elem.Kind()) </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        <span class="cov1" title="1">if elem.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                if fst := a.loadStructType(elem); fst.CanShadowCopy() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                case reflect.Struct:<span class="cov3" title="128">
                        if fst := a.loadStructType(ft); fst.CanShadowCopy() </span><span class="cov3" title="78">{
                                continue</span>
                        }
                }

                <span class="cov4" title="409">pointerFields = append(pointerFields, structFieldType{
                        Offset: field.Offset,
                        Index:  i,
                })</span>
        }

        <span class="cov4" title="217">if len(pointerFields) == 0 </span><span class="cov3" title="88">{
                pointerFields = nil // Release memory ASAP.
        }</span>

        <span class="cov4" title="217">st = structType{
                PointerFields: pointerFields,
        }

        // Load custom function.
        current := a

        for current != nil </span><span class="cov4" title="217">{
                if fn, ok := current.cachedCustomFuncTypes.Load(t); ok </span><span class="cov0" title="0">{
                        st.fn = fn.(Func)
                        break</span>
                }

                <span class="cov4" title="217">current = current.parent</span>
        }

        <span class="cov4" title="217">a.cachedStructTypes.LoadOrStore(t, st)
        return</span>
}

func (a *Allocator) lookupStructType(t reflect.Type) (st structType, ok bool) <span class="cov8" title="850313">{
        var v interface{}
        current := a

        for current != nil </span><span class="cov8" title="850363">{
                v, ok = current.cachedStructTypes.Load(t)

                if ok </span><span class="cov8" title="854144">{
                        st = v.(structType)
                        return
                }</span>

                <span class="cov4" title="217">current = current.parent</span>
        }

        <span class="cov4" title="217">return</span>
}

func (a *Allocator) isOpaquePointer(t reflect.Type) (ok bool) <span class="cov9" title="5982000">{
        current := a

        for current != nil </span><span class="cov9" title="5983231">{
                if _, ok = current.cachedPointerTypes.Load(t); ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov9" title="6377001">current = current.parent</span>
        }

        <span class="cov9" title="6376542">return</span>
}

// MarkAsScalar marks t as a scalar type so that all clone methods will copy t by value.
// If t is not struct or pointer to struct, MarkAsScalar ignores t.
//
// In the most cases, it's not necessary to call it explicitly.
// If a struct type contains scalar type fields only, the struct will be marked as scalar automatically.
//
// Here is a list of types marked as scalar by default:
//   - time.Time
//   - reflect.Value
func (a *Allocator) MarkAsScalar(t reflect.Type) <span class="cov2" title="28">{
        t = utils.IndirectType(t)
        if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="28">a.cachedStructTypes.Store(t, zeroStructType)</span>
}

// MarkAsOpaquePointer marks t as an opaque pointer so that all clone methods will copy t by value.
// If t is not a pointer, MarkAsOpaquePointer ignores t.
//
// Here is a list of types marked as opaque pointers by default:
//   - `elliptic.Curve`, which is `*elliptic.CurveParam` or `elliptic.p256Curve`;
//   - `reflect.Type`, which is `*reflect.rtype` defined in `runtime`.
func (a *Allocator) MarkAsOpaquePointer(t reflect.Type) <span class="cov3" title="84">{
        if t.Kind() != reflect.Ptr </span><span class="cov3" title="56">{
                return
        }</span>

        <span class="cov2" title="28">a.cachedPointerTypes.Store(t, struct{}{})</span>
}

// SetCustomFunc sets a custom clone function for type t.
// If t is not struct or pointer to struct, SetCustomFunc ignores t.
//
// If fn is nil, remove the custom clone function for type t.
func (a *Allocator) SetCustomFunc(t reflect.Type, fn Func) <span class="cov3" title="98">{
        if fn == nil </span><span class="cov0" title="0">{
                a.cachedCustomFuncTypes.Delete(t)
                return
        }</span>

        <span class="cov3" title="98">t = utils.IndirectType(t)
        if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="98">a.cachedCustomFuncTypes.Store(t, fn)</span>
}

func heapNew(pool unsafe.Pointer, t reflect.Type) reflect.Value <span class="cov9" title="7228561">{
        return reflect.New(t)
}</span>

func heapMakeSlice(pool unsafe.Pointer, t reflect.Type, len, cap int) reflect.Value <span class="cov8" title="831903">{
        return reflect.MakeSlice(t, len, cap)
}</span>

func heapMakeMap(pool unsafe.Pointer, t reflect.Type, n int) reflect.Value <span class="cov7" title="95878">{
        return reflect.MakeMapWithSize(t, n)
}</span>

func heapMakeChan(pool unsafe.Pointer, t reflect.Type, buffer int) reflect.Value <span class="cov0" title="0">{
        return reflect.MakeChan(t, buffer)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2023 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package clone

import (
        "reflect"
        "unsafe"
)

// AllocatorMethods defines all methods required by allocator.
// If any of these methods is nil, allocator will use default method which allocates memory from heap.
type AllocatorMethods struct {
        // Parent is the allocator which handles all unhandled methods.
        // If it's nil, it will be the default allocator.
        Parent *Allocator

        New       func(pool unsafe.Pointer, t reflect.Type) reflect.Value
        MakeSlice func(pool unsafe.Pointer, t reflect.Type, len, cap int) reflect.Value
        MakeMap   func(pool unsafe.Pointer, t reflect.Type, n int) reflect.Value
        MakeChan  func(pool unsafe.Pointer, t reflect.Type, buffer int) reflect.Value
        IsScalar  func(k reflect.Kind) bool
}

func (am *AllocatorMethods) parent() *Allocator <span class="cov0" title="0">{
        if am != nil &amp;&amp; am.Parent != nil </span><span class="cov0" title="0">{
                return am.Parent
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (am *AllocatorMethods) new(parent *Allocator, pool unsafe.Pointer) func(pool unsafe.Pointer, t reflect.Type) reflect.Value <span class="cov0" title="0">{
        if am != nil &amp;&amp; am.New != nil </span><span class="cov0" title="0">{
                return am.New
        }</span>

        <span class="cov0" title="0">if parent != nil </span><span class="cov0" title="0">{
                if parent.pool == pool </span><span class="cov0" title="0">{
                        return parent.new
                }</span> else<span class="cov0" title="0"> {
                        return func(pool unsafe.Pointer, t reflect.Type) reflect.Value </span><span class="cov0" title="0">{
                                return parent.New(t)
                        }</span>
                }
        }

        <span class="cov0" title="0">return defaultAllocator.new</span>
}

func (am *AllocatorMethods) makeSlice(parent *Allocator, pool unsafe.Pointer) func(pool unsafe.Pointer, t reflect.Type, len, cap int) reflect.Value <span class="cov0" title="0">{
        if am != nil &amp;&amp; am.MakeSlice != nil </span><span class="cov0" title="0">{
                return am.MakeSlice
        }</span>

        <span class="cov0" title="0">if parent != nil </span><span class="cov0" title="0">{
                if parent.pool == pool </span><span class="cov0" title="0">{
                        return parent.makeSlice
                }</span> else<span class="cov0" title="0"> {
                        return func(pool unsafe.Pointer, t reflect.Type, len, cap int) reflect.Value </span><span class="cov0" title="0">{
                                return parent.MakeSlice(t, len, cap)
                        }</span>
                }
        }

        <span class="cov0" title="0">return defaultAllocator.makeSlice</span>
}

func (am *AllocatorMethods) makeMap(parent *Allocator, pool unsafe.Pointer) func(pool unsafe.Pointer, t reflect.Type, n int) reflect.Value <span class="cov0" title="0">{
        if am != nil &amp;&amp; am.MakeMap != nil </span><span class="cov0" title="0">{
                return am.MakeMap
        }</span>

        <span class="cov0" title="0">if parent != nil </span><span class="cov0" title="0">{
                if parent.pool == pool </span><span class="cov0" title="0">{
                        return parent.makeMap
                }</span> else<span class="cov0" title="0"> {
                        return func(pool unsafe.Pointer, t reflect.Type, n int) reflect.Value </span><span class="cov0" title="0">{
                                return parent.MakeMap(t, n)
                        }</span>
                }
        }

        <span class="cov0" title="0">return defaultAllocator.makeMap</span>
}

func (am *AllocatorMethods) makeChan(parent *Allocator, pool unsafe.Pointer) func(pool unsafe.Pointer, t reflect.Type, buffer int) reflect.Value <span class="cov0" title="0">{
        if am != nil &amp;&amp; am.MakeChan != nil </span><span class="cov0" title="0">{
                return am.MakeChan
        }</span>

        <span class="cov0" title="0">if parent != nil </span><span class="cov0" title="0">{
                if parent.pool == pool </span><span class="cov0" title="0">{
                        return parent.makeChan
                }</span> else<span class="cov0" title="0"> {
                        return func(pool unsafe.Pointer, t reflect.Type, buffer int) reflect.Value </span><span class="cov0" title="0">{
                                return parent.MakeChan(t, buffer)
                        }</span>
                }
        }

        <span class="cov0" title="0">return defaultAllocator.makeChan</span>
}

func (am *AllocatorMethods) isScalar(parent *Allocator) func(t reflect.Kind) bool <span class="cov0" title="0">{
        if am != nil &amp;&amp; am.IsScalar != nil </span><span class="cov0" title="0">{
                return am.IsScalar
        }</span>

        <span class="cov0" title="0">if parent != nil </span><span class="cov0" title="0">{
                return parent.isScalar
        }</span>

        <span class="cov0" title="0">return defaultAllocator.isScalar</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">//go:build go1.18
// +build go1.18

package clone

import (
        "reflect"
        "unsafe"
)

// Clone recursively deep clone v to a new value in heap.
// It assumes that there is no pointer cycle in v,
// e.g. v has a pointer points to v itself.
// If there is a pointer cycle, use Slowly instead.
//
// Clone allocates memory and deeply copies values inside v in depth-first sequence.
// There are a few special rules for following types.
//
//   - Scalar types: all number-like types are copied by value.
//   - func: Copied by value as func is an opaque pointer at runtime.
//   - string: Copied by value as string is immutable by design.
//   - unsafe.Pointer: Copied by value as we don't know what's in it.
//   - chan: A new empty chan is created as we cannot read data inside the old chan.
//
// Unlike many other packages, Clone is able to clone unexported fields of any struct.
// Use this feature wisely.
func Clone[T any](t T) T <span class="cov10" title="51138">{
        return cloner.Clone(t).(T)
}</span>

// Slowly recursively deep clone v to a new value in heap.
// It marks all cloned values internally, thus it can clone v with cycle pointer.
//
// Slowly works exactly the same as Clone. See Clone doc for more details.
func Slowly[T any](t T) T <span class="cov6" title="711">{
        return cloner.CloneSlowly(t).(T)
}</span>

// Wrap creates a wrapper of v, which must be a pointer.
// If v is not a pointer, Wrap simply returns v and do nothing.
//
// The wrapper is a deep clone of v's value. It holds a shadow copy to v internally.
//
//        t := &amp;T{Foo: 123}
//        v := Wrap(t).(*T)               // v is a clone of t.
//        reflect.DeepEqual(t, v) == true // v equals t.
//        v.Foo = 456                     // v.Foo is changed, but t.Foo doesn't change.
//        orig := Unwrap(v)               // Use `Unwrap` to discard wrapper and return original value, which is t.
//        orig.(*T) == t                  // orig and t is exactly the same.
//        Undo(v)                         // Use `Undo` to discard any change on v.
//        v.Foo == t.Foo                  // Now, the value of v and t are the same again.
func Wrap[T any](t T) T <span class="cov0" title="0">{
        return wrap(t).(T)
}</span>

// Unwrap returns v's original value if v is a wrapped value.
// Otherwise, simply returns v itself.
func Unwrap[T any](t T) T <span class="cov0" title="0">{
        return unwrap(t).(T)
}</span>

// Undo discards any change made in wrapped value.
// If v is not a wrapped value, nothing happens.
func Undo[T any](t T) <span class="cov0" title="0">{
        undo(t)
}</span>

// MarkAsOpaquePointer marks t as an opaque pointer in heap allocator,
// so that all clone methods will copy t by value.
// If t is not a pointer, MarkAsOpaquePointer ignores t.
//
// Here is a list of types marked as opaque pointers by default:
//   - `elliptic.Curve`, which is `*elliptic.CurveParam` or `elliptic.p256Curve`;
//   - `reflect.Type`, which is `*reflect.rtype` defined in `runtime`.
func MarkAsOpaquePointer(t reflect.Type) <span class="cov4" title="84">{
        markAsOpaquePointer(t)
}</span>

// MarkAsScalar marks t as a scalar type in heap allocator,
// so that all clone methods will copy t by value.
// If t is not struct or pointer to struct, MarkAsScalar ignores t.
//
// In the most cases, it's not necessary to call it explicitly.
// If a struct type contains scalar type fields only, the struct will be marked as scalar automatically.
//
// Here is a list of types marked as scalar by default:
//   - time.Time
//   - reflect.Value
func MarkAsScalar(t reflect.Type) <span class="cov3" title="28">{
        markAsScalar(t)
}</span>

// SetCustomFunc sets a custom clone function for type t in heap allocator.
// If t is not struct or pointer to struct, SetCustomFunc ignores t.
//
// If fn is nil, remove the custom clone function for type t.
func SetCustomFunc(t reflect.Type, fn Func) <span class="cov4" title="98">{
        setCustomFunc(t, fn)
}</span>

// FromHeap creates an allocator which allocate memory from heap.
func FromHeap() *Allocator <span class="cov0" title="0">{
        return fromHeap()
}</span>

// NewAllocator creates an allocator which allocate memory from the pool.
// Both pool and methods are optional.
//
// If methods.New is not nil, the allocator itself is created by calling methods.New.
//
// The pool is a pointer to the memory pool which is opaque to the allocator.
// It's methods' responsibility to allocate memory from the pool properly.
func NewAllocator(pool unsafe.Pointer, methods *AllocatorMethods) (allocator *Allocator) <span class="cov0" title="0">{
        return newAllocator(pool, methods)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package clone

import (
        "time"

        "github.com/shopspring/decimal"
        "gorm.io/gorm"
)

func ComparablePtr[T comparable](s *T) (d *T) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d = new(T)
        *d = *s
        return</span>
}

func SliceComparable[T comparable, TS ~[]T](s TS) (d TS) <span class="cov10" title="190035">{
        if s == nil </span><span class="cov8" title="14099">{
                return
        }</span>
        <span class="cov9" title="175927">d = make(TS, len(s), cap(s))
        copy(d, s)
        return</span>
}

func SliceComparablePtr[T comparable, TS ~[]*T](s TS) (d TS) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d = make(TS, len(s), cap(s))
        copy(d, s)
        return</span>
}

func TimePtr(s *time.Time) (d *time.Time) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d = new(time.Time)
        *d = time.Date(s.Year(), s.Month(), s.Day(), s.Hour(), s.Minute(), s.Second(), s.Nanosecond(),
                TimeLocationPtr(s.Location()))
        return</span>
}

func TimeLocationPtr(s *time.Location) (d *time.Location) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d, _ = time.LoadLocation(s.String())
        return</span>
}

func DecimalPtr(s *decimal.Decimal) (d *decimal.Decimal) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d = new(decimal.Decimal)
        *d = s.Copy()
        return</span>
}

func GormModelPtr(s *gorm.Model) (d *gorm.Model) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return &amp;gorm.Model{
                ID:        s.ID,
                CreatedAt: *TimePtr(&amp;s.CreatedAt),
                UpdatedAt: *TimePtr(&amp;s.UpdatedAt),
                DeletedAt: gorm.DeletedAt{
                        Time:  *TimePtr(&amp;s.DeletedAt.Time),
                        Valid: s.DeletedAt.Valid,
                },
        }</span>
}

type Clonable[T any] interface {
        Clone() T
}

func Slice[T Clonable[T], TS ~[]T](s TS) (d TS) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d = make(TS, 0, len(s))
        for _, item := range s </span><span class="cov0" title="0">{
                d = append(d, item.Clone())
        }</span>
        <span class="cov0" title="0">return</span>
}

func Map[T Clonable[T], K comparable](s map[K]T) (d map[K]T) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d = make(map[K]T, len(s))
        for k, v := range s </span><span class="cov0" title="0">{
                d[k] = v.Clone()
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2019 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

// Package clone provides functions to deep clone any Go data.
// It also provides a wrapper to protect a pointer from any unexpected mutation.
package clone

import (
        "fmt"
        "reflect"
        "unsafe"
)

var heapCloneState = &amp;cloneState{
        allocator: defaultAllocator,
}
var cloner = MakeCloner(defaultAllocator)

func clone(allocator *Allocator, v interface{}) interface{} <span class="cov6" title="51147">{
        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="51147">val := reflect.ValueOf(v)
        cloned := allocator.clone(val, false)
        return cloned.Interface()</span>
}

func cloneSlowly(allocator *Allocator, v interface{}) interface{} <span class="cov4" title="711">{
        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="711">val := reflect.ValueOf(v)
        cloned := allocator.cloneSlowly(val, false)
        return cloned.Interface()</span>
}

type cloneState struct {
        allocator *Allocator
        visited   visitMap
        invalid   invalidPointers

        // The value that should not be cloned by custom func.
        // It's useful to avoid infinite loop when custom func calls allocator.Clone().
        skipCustomFuncValue reflect.Value
}

type visit struct {
        p     uintptr
        extra int
        t     reflect.Type
}

type visitMap map[visit]reflect.Value
type invalidPointers map[visit]reflect.Value

func (state *cloneState) clone(v reflect.Value) reflect.Value <span class="cov10" title="12265569">{
        if state.allocator.isScalar(v.Kind()) </span><span class="cov9" title="5929895">{
                return copyScalarValue(v)
        }</span>

        <span class="cov9" title="7610036">switch v.Kind() </span>{
        case reflect.Array:<span class="cov4" title="588">
                return state.cloneArray(v)</span>
        case reflect.Chan:<span class="cov0" title="0">
                return state.allocator.MakeChan(v.Type(), v.Cap())</span>
        case reflect.Interface:<span class="cov7" title="123255">
                return state.cloneInterface(v)</span>
        case reflect.Map:<span class="cov7" title="287887">
                return state.cloneMap(v)</span>
        case reflect.Ptr:<span class="cov9" title="6065220">
                return state.clonePtr(v)</span>
        case reflect.Slice:<span class="cov8" title="1168914">
                return state.cloneSlice(v)</span>
        case reflect.Struct:<span class="cov7" title="323289">
                return state.cloneStruct(v)</span>
        case reflect.String:<span class="cov0" title="0">
                return state.cloneString(v)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("go-clone: &lt;bug&gt; unsupported type `%v`", v.Type()))</span>
        }
}

func (state *cloneState) cloneArray(v reflect.Value) reflect.Value <span class="cov4" title="588">{
        dst := state.allocator.New(v.Type())
        state.copyArray(v, dst)
        return dst.Elem()
}</span>

func (state *cloneState) copyArray(src, nv reflect.Value) <span class="cov4" title="588">{
        p := unsafe.Pointer(nv.Pointer()) // dst must be a Ptr.
        dst := nv.Elem()
        num := src.Len()

        if state.allocator.isScalar(src.Type().Elem().Kind()) </span><span class="cov0" title="0">{
                shadowCopy(src, p)
                return
        }</span>

        <span class="cov4" title="588">for i := 0; i &lt; num; i++ </span><span class="cov4" title="1176">{
                dst.Index(i).Set(state.clone(src.Index(i)))
        }</span>
}

func (state *cloneState) cloneInterface(v reflect.Value) reflect.Value <span class="cov7" title="123317">{
        if v.IsNil() </span><span class="cov6" title="17626">{
                return reflect.Zero(v.Type())
        }</span>

        <span class="cov7" title="105801">t := v.Type()
        elem := v.Elem()
        return state.clone(elem).Convert(elem.Type()).Convert(t)</span>
}

func (state *cloneState) cloneMap(v reflect.Value) reflect.Value <span class="cov7" title="287752">{
        if v.IsNil() </span><span class="cov7" title="192366">{
                return reflect.Zero(v.Type())
        }</span>

        <span class="cov7" title="95863">t := v.Type()

        if state.visited != nil </span><span class="cov5" title="1769">{
                vst := visit{
                        p: v.Pointer(),
                        t: t,
                }

                if val, ok := state.visited[vst]; ok </span><span class="cov0" title="0">{
                        return val
                }</span>
        }

        <span class="cov7" title="95926">nv := state.allocator.MakeMap(t, v.Len())

        if state.visited != nil </span><span class="cov5" title="1769">{
                vst := visit{
                        p: v.Pointer(),
                        t: t,
                }
                state.visited[vst] = nv
        }</span>

        <span class="cov7" title="95595">for iter := mapIter(v); iter.Next(); </span><span class="cov8" title="411156">{
                key := state.clone(iter.Key())
                value := state.clone(iter.Value())
                nv.SetMapIndex(key, value)
        }</span>

        <span class="cov7" title="96184">return nv</span>
}

func (state *cloneState) clonePtr(v reflect.Value) reflect.Value <span class="cov9" title="5726029">{
        if v.IsNil() </span><span class="cov6" title="43523">{
                return reflect.Zero(v.Type())
        }</span>

        <span class="cov9" title="5680550">t := v.Type()

        if state.allocator.isOpaquePointer(t) </span><span class="cov0" title="0">{
                if v.CanInterface() </span><span class="cov0" title="0">{
                        return v
                }</span>

                <span class="cov0" title="0">ptr := state.allocator.New(t)
                p := unsafe.Pointer(ptr.Pointer())
                shadowCopy(v, p)
                return ptr.Elem()</span>
        }

        <span class="cov9" title="6293122">if state.visited != nil </span><span class="cov9" title="5778976">{
                vst := visit{
                        p: v.Pointer(),
                        t: t,
                }

                if val, ok := state.visited[vst]; ok </span><span class="cov0" title="0">{
                        return val
                }</span>
        }

        <span class="cov9" title="7037637">src := v.Elem()
        elemType := src.Type()
        elemKind := src.Kind()
        nv := state.allocator.New(elemType)

        if state.visited != nil </span><span class="cov9" title="5652979">{
                vst := visit{
                        p: v.Pointer(),
                        t: t,
                }
                state.visited[vst] = nv
        }</span>

        <span class="cov9" title="6503726">switch elemKind </span>{
        case reflect.Struct:<span class="cov8" title="529134">
                state.copyStruct(src, nv)</span>
        case reflect.Array:<span class="cov0" title="0">
                state.copyArray(src, nv)</span>
        default:<span class="cov9" title="5511261">
                nv.Elem().Set(state.clone(src))</span>
        }

        // If this pointer is the address of a struct field and it's a cycle pointer,
        // it may be updated.
        <span class="cov9" title="5839759">if state.visited != nil </span><span class="cov9" title="5113937">{
                vst := visit{
                        p: v.Pointer(),
                        t: t,
                }
                nv = state.visited[vst]
        }</span>

        <span class="cov9" title="6675435">return nv</span>
}

func (state *cloneState) cloneSlice(v reflect.Value) reflect.Value <span class="cov8" title="1168313">{
        if v.IsNil() </span><span class="cov8" title="338683">{
                return reflect.Zero(v.Type())
        }</span>

        <span class="cov8" title="830826">t := v.Type()
        num := v.Len()

        if state.visited != nil </span><span class="cov8" title="345547">{
                vst := visit{
                        p:     v.Pointer(),
                        extra: num,
                        t:     t,
                }

                if val, ok := state.visited[vst]; ok </span><span class="cov0" title="0">{
                        return val
                }</span>
        }

        <span class="cov8" title="832653">c := v.Cap()
        nv := state.allocator.MakeSlice(t, num, c)

        if state.visited != nil </span><span class="cov8" title="341975">{
                vst := visit{
                        p:     v.Pointer(),
                        extra: num,
                        t:     t,
                }
                state.visited[vst] = nv
        }</span>

        // For scalar slice, copy underlying values directly.
        <span class="cov8" title="831357">if state.allocator.isScalar(t.Elem().Kind()) </span><span class="cov8" title="599405">{
                src := unsafe.Pointer(v.Pointer())
                dst := unsafe.Pointer(nv.Pointer())
                sz := int(t.Elem().Size())
                l := num * sz
                cc := c * sz
                copy((*[maxByteSize]byte)(dst)[:l:cc], (*[maxByteSize]byte)(src)[:l:cc])
        }</span> else<span class="cov7" title="234854"> {
                for i := 0; i &lt; num; i++ </span><span class="cov9" title="6199206">{
                        nv.Index(i).Set(state.clone(v.Index(i)))
                }</span>
        }

        <span class="cov8" title="830613">return nv</span>
}

func (state *cloneState) cloneStruct(v reflect.Value) reflect.Value <span class="cov7" title="323263">{
        t := v.Type()
        nv := state.allocator.New(t)
        state.copyStruct(v, nv)
        return nv.Elem()
}</span>

var typeOfByteSlice = reflect.TypeOf([]byte(nil))

func (state *cloneState) cloneString(v reflect.Value) reflect.Value <span class="cov0" title="0">{
        t := v.Type()
        l := v.Len()
        data := state.allocator.MakeSlice(typeOfByteSlice, l, l)

        // The v is an unexported struct field.
        if !v.CanInterface() </span><span class="cov0" title="0">{
                v = reflect.ValueOf(v.String())
        }</span>

        <span class="cov0" title="0">reflect.Copy(data, v)

        nv := state.allocator.New(t)
        slice := data.Interface().([]byte)
        *(*stringHeader)(unsafe.Pointer(nv.Pointer())) = *(*stringHeader)(unsafe.Pointer(&amp;slice))

        return nv.Elem()</span>
}

func (state *cloneState) copyStruct(src, nv reflect.Value) <span class="cov8" title="849831">{
        t := src.Type()
        st := state.allocator.loadStructType(t)
        ptr := unsafe.Pointer(nv.Pointer())

        if st.Init(state.allocator, src, nv, state.skipCustomFuncValue == src) </span><span class="cov7" title="253120">{
                return
        }</span>

        <span class="cov8" title="601648">for _, pf := range st.PointerFields </span><span class="cov8" title="1809672">{
                i := int(pf.Index)
                p := unsafe.Pointer(uintptr(ptr) + pf.Offset)
                field := src.Field(i)

                // This field can be referenced by a pointer or interface inside itself.
                // Put the pointer to this field to visited to avoid any error.
                //
                // See https://github.com/huandu/go-clone/issues/3.
                if state.visited != nil &amp;&amp; field.CanAddr() </span><span class="cov8" title="538668">{
                        ft := field.Type()
                        fp := field.Addr().Pointer()
                        vst := visit{
                                p: fp,
                                t: reflect.PtrTo(ft),
                        }
                        nv := reflect.NewAt(ft, p)

                        // The address of this field was visited, so fp must be a cycle pointer.
                        // As this field is not fully cloned, the val stored in visited[visit] must be wrong.
                        // It must be replaced by nv which will be the right value (it's incomplete right now).
                        //
                        // Unfortunately, if the val was used by previous clone routines,
                        // there is no easy way to fix wrong values - all pointers must be traversed and fixed.
                        if val, ok := state.visited[vst]; ok </span><span class="cov0" title="0">{
                                state.invalid[visit{
                                        p: val.Pointer(),
                                        t: vst.t,
                                }] = nv
                        }</span>

                        <span class="cov8" title="548063">state.visited[vst] = nv</span>
                }

                <span class="cov8" title="1813995">v := state.clone(field)
                shadowCopy(v, p)</span>
        }
}

var typeOfString = reflect.TypeOf("")

func shadowCopy(src reflect.Value, p unsafe.Pointer) <span class="cov9" title="2654370">{
        switch src.Kind() </span>{
        case reflect.Bool:<span class="cov3" title="62">
                *(*bool)(p) = src.Bool()</span>
        case reflect.Int:<span class="cov1" title="4">
                *(*int)(p) = int(src.Int())</span>
        case reflect.Int8:<span class="cov0" title="0">
                *(*int8)(p) = int8(src.Int())</span>
        case reflect.Int16:<span class="cov0" title="0">
                *(*int16)(p) = int16(src.Int())</span>
        case reflect.Int32:<span class="cov0" title="0">
                *(*int32)(p) = int32(src.Int())</span>
        case reflect.Int64:<span class="cov2" title="29">
                *(*int64)(p) = src.Int()</span>
        case reflect.Uint:<span class="cov0" title="0">
                *(*uint)(p) = uint(src.Uint())</span>
        case reflect.Uint8:<span class="cov2" title="29">
                *(*uint8)(p) = uint8(src.Uint())</span>
        case reflect.Uint16:<span class="cov0" title="0">
                *(*uint16)(p) = uint16(src.Uint())</span>
        case reflect.Uint32:<span class="cov0" title="0">
                *(*uint32)(p) = uint32(src.Uint())</span>
        case reflect.Uint64:<span class="cov0" title="0">
                *(*uint64)(p) = src.Uint()</span>
        case reflect.Uintptr:<span class="cov0" title="0">
                *(*uintptr)(p) = uintptr(src.Uint())</span>
        case reflect.Float32:<span class="cov0" title="0">
                *(*float32)(p) = float32(src.Float())</span>
        case reflect.Float64:<span class="cov0" title="0">
                *(*float64)(p) = src.Float()</span>
        case reflect.Complex64:<span class="cov0" title="0">
                *(*complex64)(p) = complex64(src.Complex())</span>
        case reflect.Complex128:<span class="cov0" title="0">
                *(*complex128)(p) = src.Complex()</span>

        case reflect.Array:<span class="cov4" title="588">
                t := src.Type()

                if src.CanAddr() </span><span class="cov4" title="588">{
                        srcPtr := unsafe.Pointer(src.UnsafeAddr())
                        sz := t.Size()
                        copy((*[maxByteSize]byte)(p)[:sz:sz], (*[maxByteSize]byte)(srcPtr)[:sz:sz])
                        return
                }</span>

                <span class="cov0" title="0">val := reflect.NewAt(t, p).Elem()

                if src.CanInterface() </span><span class="cov0" title="0">{
                        val.Set(src)
                        return
                }</span>

                <span class="cov0" title="0">sz := t.Elem().Size()
                num := src.Len()

                for i := 0; i &lt; num; i++ </span><span class="cov0" title="0">{
                        elemPtr := unsafe.Pointer(uintptr(p) + uintptr(i)*sz)
                        shadowCopy(src.Index(i), elemPtr)
                }</span>
        case reflect.Chan:<span class="cov0" title="0">
                *((*uintptr)(p)) = src.Pointer()</span>
        case reflect.Func:<span class="cov0" title="0">
                t := src.Type()
                src = copyScalarValue(src)
                val := reflect.NewAt(t, p).Elem()
                val.Set(src)</span>
        case reflect.Interface:<span class="cov6" title="9142">
                *((*interfaceData)(p)) = parseReflectValue(src)</span>
        case reflect.Map:<span class="cov7" title="282991">
                *((*uintptr)(p)) = src.Pointer()</span>
        case reflect.Ptr:<span class="cov7" title="286000">
                *((*uintptr)(p)) = src.Pointer()</span>
        case reflect.Slice:<span class="cov8" title="1147021">
                *(*sliceHeader)(p) = sliceHeader{
                        Data: src.Pointer(),
                        Len:  src.Len(),
                        Cap:  src.Cap(),
                }</span>
        case reflect.String:<span class="cov1" title="4">
                s := src.String()
                val := reflect.NewAt(typeOfString, p).Elem()
                val.SetString(s)</span>
        case reflect.Struct:<span class="cov8" title="945268">
                t := src.Type()
                val := reflect.NewAt(t, p).Elem()

                if src.CanInterface() </span><span class="cov8" title="947098">{
                        val.Set(src)
                        return
                }</span>

                <span class="cov2" title="33">num := t.NumField()

                for i := 0; i &lt; num; i++ </span><span class="cov3" title="128">{
                        field := t.Field(i)
                        fieldPtr := unsafe.Pointer(uintptr(p) + field.Offset)
                        shadowCopy(src.Field(i), fieldPtr)
                }</span>
        case reflect.UnsafePointer:<span class="cov0" title="0">
                // There is no way to copy unsafe.Pointer value.
                *((*uintptr)(p)) = src.Pointer()</span>

        default:<span class="cov0" title="0">
                panic(fmt.Errorf("go-clone: &lt;bug&gt; impossible type `%v` when cloning private field", src.Type()))</span>
        }
}

// fix tranverses v to update all pointer values in state.invalid.
func (state *cloneState) fix(v reflect.Value) <span class="cov4" title="711">{
        if state == nil || len(state.invalid) == 0 </span><span class="cov4" title="711">{
                return
        }</span>

        <span class="cov0" title="0">fix := &amp;fixState{
                allocator: state.allocator,
                fixed:     fixMap{},
                invalid:   state.invalid,
        }
        fix.fix(v)</span>
}

type fixState struct {
        allocator *Allocator
        fixed     fixMap
        invalid   invalidPointers
}

type fixMap map[visit]struct{}

func (fix *fixState) new(t reflect.Type) reflect.Value <span class="cov0" title="0">{
        return fix.allocator.New(t)
}</span>

func (fix *fixState) fix(v reflect.Value) (copied reflect.Value, changed int) <span class="cov0" title="0">{
        if fix.allocator.isScalar(v.Kind()) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch v.Kind() </span>{
        case reflect.Array:<span class="cov0" title="0">
                return fix.fixArray(v)</span>
        case reflect.Chan:<span class="cov0" title="0">
                // Do nothing.
                return</span>
        case reflect.Interface:<span class="cov0" title="0">
                return fix.fixInterface(v)</span>
        case reflect.Map:<span class="cov0" title="0">
                return fix.fixMap(v)</span>
        case reflect.Ptr:<span class="cov0" title="0">
                return fix.fixPtr(v)</span>
        case reflect.Slice:<span class="cov0" title="0">
                return fix.fixSlice(v)</span>
        case reflect.Struct:<span class="cov0" title="0">
                return fix.fixStruct(v)</span>
        case reflect.String:<span class="cov0" title="0">
                // Do nothing.
                return</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("go-clone: &lt;bug&gt; unsupported type `%v`", v.Type()))</span>
        }
}

func (fix *fixState) fixArray(v reflect.Value) (copied reflect.Value, changed int) <span class="cov0" title="0">{
        t := v.Type()
        et := t.Elem()
        kind := et.Kind()

        if fix.allocator.isScalar(kind) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l := v.Len()

        for i := 0; i &lt; l; i++ </span><span class="cov0" title="0">{
                elem := v.Index(i)

                if kind == reflect.Ptr </span><span class="cov0" title="0">{
                        vst := visit{
                                p: elem.Pointer(),
                                t: et,
                        }

                        if nv, ok := fix.invalid[vst]; ok </span><span class="cov0" title="0">{
                                // If elem cannot be set, v must be copied to make it settable.
                                // Don't do it unless there is no other choices.
                                if !elem.CanSet() </span><span class="cov0" title="0">{
                                        copied = fix.new(t).Elem()
                                        shadowCopy(v, unsafe.Pointer(copied.Addr().Pointer()))
                                        _, changed = fix.fixArray(copied)
                                        return
                                }</span>

                                <span class="cov0" title="0">elem.Set(nv)
                                changed++
                                continue</span>
                        }
                }

                <span class="cov0" title="0">fixed, c := fix.fix(elem)
                changed += c

                if fixed.IsValid() </span><span class="cov0" title="0">{
                        // If elem cannot be set, v must be copied to make it settable.
                        // Don't do it unless there is no other choices.
                        if !elem.CanSet() </span><span class="cov0" title="0">{
                                copied = fix.new(t).Elem()
                                shadowCopy(v, unsafe.Pointer(copied.Addr().Pointer()))
                                _, changed = fix.fixArray(copied)
                                return
                        }</span>

                        <span class="cov0" title="0">elem.Set(fixed)</span>
                }
        }

        <span class="cov0" title="0">return</span>
}

func (fix *fixState) fixInterface(v reflect.Value) (copied reflect.Value, changed int) <span class="cov0" title="0">{
        if v.IsNil() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">elem := v.Elem()
        t := elem.Type()
        kind := elem.Kind()

        if kind == reflect.Ptr </span><span class="cov0" title="0">{
                vst := visit{
                        p: elem.Pointer(),
                        t: t,
                }

                if nv, ok := fix.invalid[vst]; ok </span><span class="cov0" title="0">{
                        copied = nv.Convert(v.Type())
                        changed++
                        return
                }</span>
        }

        <span class="cov0" title="0">copied, changed = fix.fix(elem)

        if copied.IsValid() </span><span class="cov0" title="0">{
                copied = copied.Convert(v.Type())
        }</span>

        <span class="cov0" title="0">return</span>
}

func (fix *fixState) fixMap(v reflect.Value) (copied reflect.Value, changed int) <span class="cov0" title="0">{
        if v.IsNil() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">t := v.Type()
        vst := visit{
                p: v.Pointer(),
                t: t,
        }

        if _, ok := fix.fixed[vst]; ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fix.fixed[vst] = struct{}{}

        kt := t.Key()
        et := t.Elem()
        keyKind := kt.Kind()
        elemKind := et.Kind()

        if isScalar := fix.allocator.isScalar; isScalar(keyKind) &amp;&amp; isScalar(elemKind) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">invalidKeys := map[reflect.Value][2]reflect.Value{}

        for iter := mapIter(v); iter.Next(); </span><span class="cov0" title="0">{
                key := iter.Key()
                elem := iter.Value()
                var fixed reflect.Value
                c := 0

                if elemKind == reflect.Ptr </span><span class="cov0" title="0">{
                        vst := visit{
                                p: elem.Pointer(),
                                t: et,
                        }

                        if nv, ok := fix.invalid[vst]; ok </span><span class="cov0" title="0">{
                                fixed = nv
                                c++
                        }</span> else<span class="cov0" title="0"> {
                                fixed, c = fix.fixPtr(elem)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fixed, c = fix.fix(elem)
                }</span>

                <span class="cov0" title="0">changed += c
                c = 0

                if fixed.IsValid() </span><span class="cov0" title="0">{
                        v = forceSetMapIndex(v, key, fixed)
                        elem = fixed
                        fixed = reflect.Value{}
                }</span>

                <span class="cov0" title="0">if keyKind == reflect.Ptr </span><span class="cov0" title="0">{
                        vst := visit{
                                p: key.Pointer(),
                                t: kt,
                        }

                        if nv, ok := fix.invalid[vst]; ok </span><span class="cov0" title="0">{
                                fixed = nv
                                c++
                        }</span> else<span class="cov0" title="0"> {
                                fixed, c = fix.fixPtr(key)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fixed, c = fix.fix(key)
                }</span>

                <span class="cov0" title="0">changed += c

                // Key cannot be changed immediately inside map range iteration.
                // Do it later.
                if fixed.IsValid() </span><span class="cov0" title="0">{
                        invalidKeys[key] = [2]reflect.Value{fixed, elem}
                }</span>
        }

        <span class="cov0" title="0">for key, kv := range invalidKeys </span><span class="cov0" title="0">{
                v = forceSetMapIndex(v, key, reflect.Value{})
                v = forceSetMapIndex(v, kv[0], kv[1])
        }</span>

        <span class="cov0" title="0">return</span>
}

func forceSetMapIndex(v, key, elem reflect.Value) (nv reflect.Value) <span class="cov0" title="0">{
        nv = v

        if !v.CanInterface() </span><span class="cov0" title="0">{
                nv = forceClearROFlag(v)
        }</span>

        <span class="cov0" title="0">if !key.CanInterface() </span><span class="cov0" title="0">{
                key = forceClearROFlag(key)
        }</span>

        <span class="cov0" title="0">if elem.IsValid() &amp;&amp; !elem.CanInterface() </span><span class="cov0" title="0">{
                elem = forceClearROFlag(elem)
        }</span>

        <span class="cov0" title="0">nv.SetMapIndex(key, elem)
        return</span>
}

func (fix *fixState) fixPtr(v reflect.Value) (copied reflect.Value, changed int) <span class="cov0" title="0">{
        if v.IsNil() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">vst := visit{
                p: v.Pointer(),
                t: v.Type(),
        }

        if _, ok := fix.invalid[vst]; ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("go-clone: &lt;bug&gt; invalid pointers must have been fixed in other methods"))</span>
        }

        <span class="cov0" title="0">if _, ok := fix.fixed[vst]; ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fix.fixed[vst] = struct{}{}

        elem := v.Elem()
        _, changed = fix.fix(elem)
        return</span>
}

func (fix *fixState) fixSlice(v reflect.Value) (copied reflect.Value, changed int) <span class="cov0" title="0">{
        if v.IsNil() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">t := v.Type()
        et := t.Elem()
        kind := et.Kind()

        if fix.allocator.isScalar(kind) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l := v.Len()
        p := unsafe.Pointer(v.Pointer())
        vst := visit{
                p:     uintptr(p),
                extra: l,
                t:     t,
        }

        if _, ok := fix.fixed[vst]; ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fix.fixed[vst] = struct{}{}

        for i := 0; i &lt; l; i++ </span><span class="cov0" title="0">{
                elem := v.Index(i)
                var fixed reflect.Value
                c := 0

                if kind == reflect.Ptr </span><span class="cov0" title="0">{
                        vst := visit{
                                p: elem.Pointer(),
                                t: et,
                        }

                        if nv, ok := fix.invalid[vst]; ok </span><span class="cov0" title="0">{
                                fixed = nv
                        }</span> else<span class="cov0" title="0"> {
                                fixed, c = fix.fixPtr(elem)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fixed, c = fix.fix(elem)
                }</span>

                <span class="cov0" title="0">changed += c

                if fixed.IsValid() </span><span class="cov0" title="0">{
                        sz := et.Size()
                        elemPtr := unsafe.Pointer(uintptr(p) + sz*uintptr(i))
                        shadowCopy(fixed, elemPtr)
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

func (fix *fixState) fixStruct(v reflect.Value) (copied reflect.Value, changed int) <span class="cov0" title="0">{
        t := v.Type()
        st := fix.allocator.loadStructType(t)

        if len(st.PointerFields) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, pf := range st.PointerFields </span><span class="cov0" title="0">{
                i := int(pf.Index)
                field := v.Field(i)

                ft := field.Type()

                if ft.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        vst := visit{
                                p: field.Pointer(),
                                t: ft,
                        }

                        if nv, ok := fix.invalid[vst]; ok </span><span class="cov0" title="0">{
                                // If v is not addressable, a new struct must be allocated.
                                // Don't do it unless there is no other choices.
                                if !v.CanAddr() </span><span class="cov0" title="0">{
                                        copied = fix.new(t).Elem()
                                        shadowCopy(v, unsafe.Pointer(copied.Addr().Pointer()))
                                        _, changed = fix.fixStruct(copied)
                                        return
                                }</span>

                                <span class="cov0" title="0">ptr := unsafe.Pointer(v.Addr().Pointer())
                                p := unsafe.Pointer(uintptr(ptr) + pf.Offset)
                                shadowCopy(nv, p)
                                continue</span>
                        }
                }

                <span class="cov0" title="0">fixed, c := fix.fix(field)
                changed += c

                if fixed.IsValid() </span><span class="cov0" title="0">{
                        // If v is not addressable, a new struct must be allocated.
                        // Don't do it unless there is no other choices.
                        if !v.CanAddr() </span><span class="cov0" title="0">{
                                copied = fix.new(t).Elem()
                                shadowCopy(v, unsafe.Pointer(copied.Addr().Pointer()))
                                _, changed = fix.fixStruct(copied)
                                return
                        }</span>

                        <span class="cov0" title="0">ptr := unsafe.Pointer(v.Addr().Pointer())
                        p := unsafe.Pointer(uintptr(ptr) + pf.Offset)
                        shadowCopy(fixed, p)</span>
                }
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2023 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package clone

// Cloner implements clone API with given allocator.
type Cloner struct {
        allocator *Allocator
}

// MakeCloner creates a cloner with given allocator.
func MakeCloner(allocator *Allocator) Cloner <span class="cov3" title="14">{
        return Cloner{
                allocator: allocator,
        }
}</span>

// Clone clones v with given allocator.
func (c Cloner) Clone(v interface{}) interface{} <span class="cov10" title="51098">{
        return clone(c.allocator, v)
}</span>

// CloneSlowly clones v with given allocator.
// It can clone v with cycle pointer.
func (c Cloner) CloneSlowly(v interface{}) interface{} <span class="cov6" title="711">{
        return cloneSlowly(c.allocator, v)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package clone

import (
        "reflect"
        "unsafe"
)

const sizeOfPointers = unsafe.Sizeof((interface{})(0)) / unsafe.Sizeof(uintptr(0))

// interfaceData is the underlying data of an interface.
// As the reflect.Value's interfaceData method is deprecated,
// it may be broken in any Go release.
// It's better to create a custom to hold the data.
//
// The type of interfaceData fields must be poniters.
// It's a way to cheat Go compile to generate calls to write barrier
// when copying interfaces.
type interfaceData struct {
        _ [sizeOfPointers]unsafe.Pointer
}

var reflectValuePtrOffset uintptr

func init() <span class="cov3" title="14">{
        t := reflect.TypeOf(reflect.Value{})
        found := false
        fields := t.NumField()

        for i := 0; i &lt; fields; i++ </span><span class="cov4" title="28">{
                field := t.Field(i)

                if field.Type.Kind() == reflect.UnsafePointer </span><span class="cov3" title="14">{
                        found = true
                        reflectValuePtrOffset = field.Offset
                        break</span>
                }
        }

        <span class="cov3" title="14">if !found </span><span class="cov0" title="0">{
                panic("go-clone: fail to find internal ptr field in reflect.Value")</span>
        }
}

// parseReflectValue returns the underlying interface data in a reflect value.
// It assumes that v is an interface value.
func parseReflectValue(v reflect.Value) interfaceData <span class="cov10" title="9468">{
        pv := (unsafe.Pointer)(uintptr(unsafe.Pointer(&amp;v)) + reflectValuePtrOffset)
        ptr := *(*unsafe.Pointer)(pv)
        return *(*interfaceData)(ptr)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2019 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

//go:build go1.12
// +build go1.12

package clone

import (
        "reflect"
)

func mapIter(m reflect.Value) *reflect.MapIter <span class="cov10" title="95604">{
        return m.MapRange()
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2019 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package clone

import (
        "crypto/elliptic"
        "fmt"
        "reflect"
        "sync"
        "sync/atomic"
        "time"
        "unsafe"
)

type structType struct {
        PointerFields []structFieldType
        fn            Func
}

type structFieldType struct {
        Offset uintptr // The offset from the beginning of the struct.
        Index  int     // The index of the field.
}

var zeroStructType = structType{}

func init() <span class="cov2" title="14">{
        // Some well-known scalar-like structs.
        MarkAsScalar(reflect.TypeOf(time.Time{}))
        MarkAsScalar(reflect.TypeOf(reflect.Value{}))

        // Special case for elliptic.Curve which is used by TLS ECC certificate.
        // Package crypto/tls uses elliptic.Curve as enum values
        // so that they should be treated as opaque pointers.
        //
        // As elliptic.Curve is an interface, it can be *elliptic.CurveParam or elliptic.p256Curve.
        MarkAsOpaquePointer(reflect.TypeOf(&amp;elliptic.CurveParams{}))
        curves := []elliptic.Curve{
                elliptic.P224(),
                elliptic.P256(),
                elliptic.P384(),
                elliptic.P521(),
        }

        for _, curve := range curves </span><span class="cov3" title="56">{
                MarkAsOpaquePointer(reflect.ValueOf(curve).Type())
        }</span>

        // Special case for reflect.Type (actually *reflect.rtype):
        // The *reflect.rtype should not be copied as it is immutable and
        // may point to a variable that actual type is not reflect.rtype,
        // e.g. *reflect.arrayType or *reflect.chanType.
        <span class="cov2" title="14">MarkAsOpaquePointer(reflect.TypeOf(reflect.TypeOf(0)))

        // Some well-known no-copy structs.
        //
        // Almost all structs defined in package "sync" and "go.uber.org/atomic" are set
        // except `sync.Once` which can be safely cloned with a correct done value.
        SetCustomFunc(reflect.TypeOf(sync.Mutex{}), emptyCloneFunc)
        SetCustomFunc(reflect.TypeOf(sync.RWMutex{}), emptyCloneFunc)
        SetCustomFunc(reflect.TypeOf(sync.WaitGroup{}), emptyCloneFunc)
        SetCustomFunc(reflect.TypeOf(sync.Cond{}), func(allocator *Allocator, old, new reflect.Value) </span><span class="cov0" title="0">{
                // Copy the New func from old value.
                oldL := old.FieldByName("L")
                newL := allocator.Clone(oldL)
                new.FieldByName("L").Set(newL)
        }</span>)
        <span class="cov2" title="14">SetCustomFunc(reflect.TypeOf(sync.Pool{}), func(allocator *Allocator, old, new reflect.Value) </span><span class="cov0" title="0">{
                // Copy the New func from old value.
                oldFn := old.FieldByName("New")
                newFn := allocator.Clone(oldFn)
                new.FieldByName("New").Set(newFn)
        }</span>)
        <span class="cov2" title="14">SetCustomFunc(reflect.TypeOf(sync.Map{}), func(allocator *Allocator, old, new reflect.Value) </span><span class="cov0" title="0">{
                if !old.CanAddr() </span><span class="cov0" title="0">{
                        return
                }</span>

                // Clone all values inside sync.Map.
                <span class="cov0" title="0">oldMap := old.Addr().Interface().(*sync.Map)
                newMap := new.Addr().Interface().(*sync.Map)
                oldMap.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                        k := clone(allocator, key)
                        v := clone(allocator, value)
                        newMap.Store(k, v)
                        return true
                }</span>)
        })
        <span class="cov2" title="14">SetCustomFunc(reflect.TypeOf(atomic.Value{}), func(allocator *Allocator, old, new reflect.Value) </span><span class="cov0" title="0">{
                if !old.CanAddr() </span><span class="cov0" title="0">{
                        return
                }</span>

                // Clone value inside atomic.Value.
                <span class="cov0" title="0">oldValue := old.Addr().Interface().(*atomic.Value)
                newValue := new.Addr().Interface().(*atomic.Value)
                v := oldValue.Load()
                cloned := clone(allocator, v)
                newValue.Store(cloned)</span>
        })
}

// MarkAsScalar marks t as a scalar type in heap allocator,
// so that all clone methods will copy t by value.
// If t is not struct or pointer to struct, MarkAsScalar ignores t.
//
// In the most cases, it's not necessary to call it explicitly.
// If a struct type contains scalar type fields only, the struct will be marked as scalar automatically.
//
// Here is a list of types marked as scalar by default:
//   - time.Time
//   - reflect.Value
func markAsScalar(t reflect.Type) <span class="cov2" title="28">{
        defaultAllocator.MarkAsScalar(t)
}</span>

// MarkAsOpaquePointer marks t as an opaque pointer in heap allocator,
// so that all clone methods will copy t by value.
// If t is not a pointer, MarkAsOpaquePointer ignores t.
//
// Here is a list of types marked as opaque pointers by default:
//   - `elliptic.Curve`, which is `*elliptic.CurveParam` or `elliptic.p256Curve`;
//   - `reflect.Type`, which is `*reflect.rtype` defined in `runtime`.
func markAsOpaquePointer(t reflect.Type) <span class="cov3" title="84">{
        defaultAllocator.MarkAsOpaquePointer(t)
}</span>

// Func is a custom func to clone value from old to new.
// The new is a zero value
// which `new.CanSet()` and `new.CanAddr()` is guaranteed to be true.
//
// Func must update the new to return result.
type Func func(allocator *Allocator, old, new reflect.Value)

// emptyCloneFunc is used to disable shadow copy.
// It's useful when cloning sync.Mutex as cloned value must be a zero value.
func emptyCloneFunc(allocator *Allocator, old, new reflect.Value) {<span class="cov0" title="0">}</span>

// SetCustomFunc sets a custom clone function for type t in heap allocator.
// If t is not struct or pointer to struct, SetCustomFunc ignores t.
//
// If fn is nil, remove the custom clone function for type t.
func setCustomFunc(t reflect.Type, fn Func) <span class="cov3" title="98">{
        defaultAllocator.SetCustomFunc(t, fn)
}</span>

// Init creates a new value of src.Type() and shadow copies all content from src.
// If noCustomFunc is set to true, custom clone function will be ignored.
//
// Init returns true if the value is cloned by a custom func.
// Caller should skip cloning struct fields in depth.
func (st *structType) Init(allocator *Allocator, src, nv reflect.Value, noCustomFunc bool) (done bool) <span class="cov8" title="852570">{
        dst := nv.Elem()

        if !noCustomFunc &amp;&amp; st.fn != nil </span><span class="cov0" title="0">{
                if !src.CanInterface() </span><span class="cov0" title="0">{
                        src = forceClearROFlag(src)
                }</span>

                <span class="cov0" title="0">st.fn(allocator, src, dst)
                done = true
                return</span>
        }

        <span class="cov8" title="853434">ptr := unsafe.Pointer(nv.Pointer())
        shadowCopy(src, ptr)
        done = len(st.PointerFields) == 0
        return</span>
}

func (st *structType) CanShadowCopy() bool <span class="cov3" title="128">{
        return len(st.PointerFields) == 0 &amp;&amp; st.fn == nil
}</span>

// IsScalar returns true if k should be considered as a scalar type.
//
// For the sake of performance, string is considered as a scalar type unless arena is enabled.
// If we need to deep copy string value in some cases, we can create a new allocator with custom isScalar function
// in which we can return false when k is reflect.String.
//
//        // Create a new allocator which treats string as non-scalar type.
//        allocator := NewAllocator(nil, &amp;AllocatorMethods{
//                IsScalar: func(k reflect.Kind) bool {
//                        return k != reflect.String &amp;&amp; IsScalar(k)
//                },
//        })
func IsScalar(k reflect.Kind) bool <span class="cov10" title="12881750">{
        switch k </span>{
        case reflect.Bool,
                reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
                reflect.Float32, reflect.Float64,
                reflect.Complex64, reflect.Complex128,
                reflect.Func,
                reflect.UnsafePointer,
                reflect.Invalid:<span class="cov9" title="5363835">
                return true</span>

        case reflect.String:<span class="cov8" title="1295201">
                // If arena is not enabled, string can be copied as scalar safely
                // as it's immutable by design.
                return !arenaIsEnabled</span>
        }

        <span class="cov9" title="7866864">return false</span>
}

func copyScalarValue(src reflect.Value) reflect.Value <span class="cov9" title="5948881">{
        if src.CanInterface() </span><span class="cov9" title="6061000">{
                return src
        }</span>

        // src is an unexported field value. Copy its value.
        <span class="cov4" title="326">switch src.Kind() </span>{
        case reflect.Bool:<span class="cov0" title="0">
                return reflect.ValueOf(src.Bool())</span>

        case reflect.Int:<span class="cov1" title="1">
                return reflect.ValueOf(int(src.Int()))</span>
        case reflect.Int8:<span class="cov0" title="0">
                return reflect.ValueOf(int8(src.Int()))</span>
        case reflect.Int16:<span class="cov0" title="0">
                return reflect.ValueOf(int16(src.Int()))</span>
        case reflect.Int32:<span class="cov0" title="0">
                return reflect.ValueOf(int32(src.Int()))</span>
        case reflect.Int64:<span class="cov0" title="0">
                return reflect.ValueOf(src.Int())</span>

        case reflect.Uint:<span class="cov0" title="0">
                return reflect.ValueOf(uint(src.Uint()))</span>
        case reflect.Uint8:<span class="cov0" title="0">
                return reflect.ValueOf(uint8(src.Uint()))</span>
        case reflect.Uint16:<span class="cov0" title="0">
                return reflect.ValueOf(uint16(src.Uint()))</span>
        case reflect.Uint32:<span class="cov0" title="0">
                return reflect.ValueOf(uint32(src.Uint()))</span>
        case reflect.Uint64:<span class="cov0" title="0">
                return reflect.ValueOf(src.Uint())</span>
        case reflect.Uintptr:<span class="cov0" title="0">
                return reflect.ValueOf(uintptr(src.Uint()))</span>

        case reflect.Float32:<span class="cov0" title="0">
                return reflect.ValueOf(float32(src.Float()))</span>
        case reflect.Float64:<span class="cov0" title="0">
                return reflect.ValueOf(src.Float())</span>

        case reflect.Complex64:<span class="cov0" title="0">
                return reflect.ValueOf(complex64(src.Complex()))</span>
        case reflect.Complex128:<span class="cov0" title="0">
                return reflect.ValueOf(src.Complex())</span>

        case reflect.String:<span class="cov0" title="0">
                return reflect.ValueOf(src.String())</span>
        case reflect.Func:<span class="cov4" title="325">
                t := src.Type()

                if src.IsNil() </span><span class="cov0" title="0">{
                        return reflect.Zero(t)
                }</span>

                // Don't use this trick unless we have no choice.
                <span class="cov4" title="325">return forceClearROFlag(src)</span>
        case reflect.UnsafePointer:<span class="cov0" title="0">
                return reflect.ValueOf(unsafe.Pointer(src.Pointer()))</span>
        }

        <span class="cov0" title="0">panic(fmt.Errorf("go-clone: &lt;bug&gt; impossible type `%v` when cloning private field", src.Type()))</span>
}

var typeOfInterface = reflect.TypeOf((*interface{})(nil)).Elem()

// forceClearROFlag clears all RO flags in v to make v accessible.
// It's a hack based on the fact that InterfaceData is always available on RO data.
// This hack can be broken in any Go version.
// Don't use it unless we have no choice, e.g. copying func in some edge cases.
func forceClearROFlag(v reflect.Value) reflect.Value <span class="cov4" title="325">{
        var i interface{}
        indirect := 0

        // Save flagAddr.
        for v.CanAddr() </span><span class="cov0" title="0">{
                v = v.Addr()
                indirect++
        }</span>

        <span class="cov4" title="325">v = v.Convert(typeOfInterface)
        nv := reflect.ValueOf(&amp;i)
        *(*interfaceData)(unsafe.Pointer(nv.Pointer())) = parseReflectValue(v)
        cleared := nv.Elem().Elem()

        for indirect &gt; 0 </span><span class="cov0" title="0">{
                cleared = cleared.Elem()
                indirect--
        }</span>

        <span class="cov4" title="325">return cleared</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2019 Huan Du. All rights reserved.
// Licensed under the MIT license that can be found in the LICENSE file.

package clone

import (
        "encoding/binary"
        "hash/crc64"
        "reflect"
        "sync"
        "unsafe"
)

var (
        sizeOfChecksum = unsafe.Sizeof(uint64(0))

        crc64Table = crc64.MakeTable(crc64.ECMA)

        cachedWrapperTypes sync.Map
)

// Wrap creates a wrapper of v, which must be a pointer.
// If v is not a pointer, Wrap simply returns v and do nothing.
//
// The wrapper is a deep clone of v's value. It holds a shadow copy to v internally.
//
//        t := &amp;T{Foo: 123}
//        v := Wrap(t).(*T)               // v is a clone of t.
//        reflect.DeepEqual(t, v) == true // v equals t.
//        v.Foo = 456                     // v.Foo is changed, but t.Foo doesn't change.
//        orig := Unwrap(v)               // Use `Unwrap` to discard wrapper and return original value, which is t.
//        orig.(*T) == t                  // orig and t is exactly the same.
//        Undo(v)                         // Use `Undo` to discard any change on v.
//        v.Foo == t.Foo                  // Now, the value of v and t are the same again.
func wrap(v interface{}) interface{} <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">val := reflect.ValueOf(v)
        pt := val.Type()

        if val.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">t := pt.Elem()
        elem := val.Elem()
        ptr := unsafe.Pointer(val.Pointer())
        cache, ok := cachedWrapperTypes.Load(t)

        if !ok </span><span class="cov0" title="0">{
                cache = reflect.StructOf([]reflect.StructField{
                        {
                                Name:      "T",
                                Type:      t,
                                Anonymous: true,
                        },
                        {
                                Name: "Checksum",
                                Type: reflect.TypeOf(uint64(0)),
                        },
                        {
                                Name: "Origin",
                                Type: pt,
                        },
                })
                cachedWrapperTypes.Store(t, cache)
        }</span>

        <span class="cov0" title="0">wrapperType := cache.(reflect.Type)
        pw := defaultAllocator.New(wrapperType)

        wrapperPtr := unsafe.Pointer(pw.Pointer())
        wrapper := pw.Elem()

        // Equivalent code: wrapper.T = Clone(v)
        field := wrapper.Field(0)
        field.Set(heapCloneState.clone(elem))

        // Equivalent code: wrapper.Checksum = makeChecksum(v)
        checksumPtr := unsafe.Pointer(uintptr(wrapperPtr) + t.Size())
        *(*uint64)(checksumPtr) = makeChecksum(t, uintptr(wrapperPtr), uintptr(ptr))

        // Equivalent code: wrapper.Origin = v
        originPtr := unsafe.Pointer(uintptr(wrapperPtr) + t.Size() + sizeOfChecksum)
        *(*uintptr)(originPtr) = uintptr(ptr)

        return field.Addr().Interface()</span>
}

func validateChecksum(t reflect.Type, ptr unsafe.Pointer) bool <span class="cov0" title="0">{
        pw := uintptr(ptr)
        orig := uintptr(getOrigin(t, ptr))
        checksum := *(*uint64)(unsafe.Pointer(uintptr(ptr) + t.Size()))
        expected := makeChecksum(t, pw, orig)

        return checksum == expected
}</span>

func makeChecksum(t reflect.Type, pw uintptr, orig uintptr) uint64 <span class="cov0" title="0">{
        var data [binary.MaxVarintLen64 * 2]byte
        binary.PutUvarint(data[:binary.MaxVarintLen64], uint64(pw))
        binary.PutUvarint(data[binary.MaxVarintLen64:], uint64(orig))
        return crc64.Checksum(data[:], crc64Table)
}</span>

func getOrigin(t reflect.Type, ptr unsafe.Pointer) unsafe.Pointer <span class="cov0" title="0">{
        return *(*unsafe.Pointer)(unsafe.Pointer(uintptr(ptr) + t.Size() + sizeOfChecksum))
}</span>

// Unwrap returns v's original value if v is a wrapped value.
// Otherwise, simply returns v itself.
func unwrap(v interface{}) interface{} <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">val := reflect.ValueOf(v)

        if !isWrapped(val) </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov0" title="0">origVal := origin(val)
        return origVal.Interface()</span>
}

func origin(val reflect.Value) reflect.Value <span class="cov0" title="0">{
        pt := val.Type()
        t := pt.Elem()
        ptr := unsafe.Pointer(val.Pointer())
        orig := getOrigin(t, ptr)
        origVal := reflect.NewAt(t, orig)
        return origVal
}</span>

// Undo discards any change made in wrapped value.
// If v is not a wrapped value, nothing happens.
func undo(v interface{}) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">val := reflect.ValueOf(v)

        if !isWrapped(val) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">origVal := origin(val)
        elem := val.Elem()
        elem.Set(heapCloneState.clone(origVal.Elem()))</span>
}

func isWrapped(val reflect.Value) bool <span class="cov0" title="0">{
        pt := val.Type()

        if pt.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">t := pt.Elem()
        ptr := unsafe.Pointer(val.Pointer())
        return validateChecksum(t, ptr)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package cmp

import (
        "fmt"
        "reflect"
        "time"

        "github.com/shopspring/decimal"
        "gorm.io/gorm"

        "github.com/wfusion/gofusion/common/utils"
)

func ComparablePtr[T comparable](a, b *T) bool <span class="cov10" title="44">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov10" title="44">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov10" title="44">return *a == *b</span>
}
func SliceComparable[T comparable, TS ~[]T](a, b TS) bool <span class="cov3" title="3">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov3" title="3">if a == nil || b == nil || len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="3">for i := 0; i &lt; len(a); i++ </span><span class="cov6" title="9">{
                if a[i] != b[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov3" title="3">return true</span>
}
func SliceComparablePtr[T comparable, TS ~[]*T](a, b TS) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil || len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; len(a); i++ </span><span class="cov0" title="0">{
                if deref(a[i]) != deref(b[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func TimePtr(a, b *time.Time) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return a.Equal(*b) &amp;&amp; TimeLocationPtr(a.Location(), b.Location())</span>
}

func TimeLocationPtr(a, b *time.Location) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return a.String() == b.String()</span>
}

func DecimalPtr(a, b *decimal.Decimal) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return a.Equal(*b)</span>
}

func GormModelPtr(a, b *gorm.Model) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return a.ID == b.ID &amp;&amp;
                TimePtr(&amp;a.CreatedAt, &amp;b.CreatedAt) &amp;&amp;
                TimePtr(&amp;a.UpdatedAt, &amp;b.UpdatedAt) &amp;&amp;
                a.DeletedAt.Valid == b.DeletedAt.Valid &amp;&amp;
                TimePtr(&amp;a.DeletedAt.Time, &amp;b.DeletedAt.Time)</span>
}

type _comparable[T any] interface {
        Equals(other T) bool
}

func Slice[T _comparable[T], TS ~[]T](a, b TS, sortFn func(i, j T) int) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil || len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if sortFn != nil </span><span class="cov0" title="0">{
                utils.SortStable(a, sortFn)
                utils.SortStable(b, sortFn)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(a); i++ </span><span class="cov0" title="0">{
                if !a[i].Equals(b[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func SliceAny[T any, TS ~[]T](a, b TS, sortFn func(i, j T) int) bool <span class="cov1" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov1" title="1">if a == nil || b == nil || len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov1" title="1">if sortFn != nil </span><span class="cov0" title="0">{
                utils.SortStable(a, sortFn)
                utils.SortStable(b, sortFn)
        }</span>

        <span class="cov1" title="1">for i := 0; i &lt; len(a); i++ </span><span class="cov4" title="4">{
                if !anything(a[i], b[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov1" title="1">return true</span>
}

func Map[T _comparable[T], K comparable](a, b map[K]T) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil || len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for ak, av := range a </span><span class="cov0" title="0">{
                bv, ok := b[ak]
                if !ok || !av.Equals(bv) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func MapAny[K comparable, T any](a, b map[K]T) bool <span class="cov5" title="6">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov5" title="6">if a == nil || b == nil || len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="6">for ak, av := range a </span><span class="cov6" title="12">{
                bv, ok := b[ak]
                if !ok || !anything(av, bv) </span><span class="cov3" title="3">{
                        return false
                }</span>

        }
        <span class="cov3" title="3">return true</span>
}

func anything(a, b any) bool <span class="cov7" title="17">{
        switch av := a.(type) </span>{
        case
                        bool,
                        string, uintptr,
                        int, int8, int16, int32, int64,
                        uint, uint8, uint16, uint32, uint64,
                        float32, float64,
                        complex64, complex128:<span class="cov5" title="8">
                return a == b</span>
        case
                        *bool,
                        *string, *uintptr,
                        *int, *int8, *int16, *int32, *int64,
                        *uint, *uint8, *uint16, *uint32, *uint64,
                        *float32, *float64,
                        *complex64, *complex128:<span class="cov1" title="1">
                if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov1" title="1">if a == nil || b == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov1" title="1">return anything(deref(a), deref(b))</span>
        case decimal.Decimal:<span class="cov0" title="0">
                bv := b.(decimal.Decimal)
                return DecimalPtr(&amp;av, &amp;bv)</span>
        case *decimal.Decimal:<span class="cov0" title="0">
                bv := b.(*decimal.Decimal)
                return DecimalPtr(av, bv)</span>
        case time.Time:<span class="cov0" title="0">
                bv := b.(time.Time)
                return TimePtr(&amp;av, &amp;bv)</span>
        case *time.Time:<span class="cov0" title="0">
                bv := b.(*time.Time)
                return TimePtr(av, bv)</span>
        case time.Location:<span class="cov0" title="0">
                bv := b.(time.Location)
                return TimeLocationPtr(&amp;av, &amp;bv)</span>
        case *time.Location:<span class="cov0" title="0">
                bv := b.(*time.Location)
                return TimeLocationPtr(av, bv)</span>
        case []bool:<span class="cov0" title="0">
                return SliceComparable(a.([]bool), b.([]bool))</span>
        case []string:<span class="cov0" title="0">
                return SliceComparable(a.([]string), b.([]string))</span>
        case []uintptr:<span class="cov0" title="0">
                return SliceComparable(a.([]uintptr), b.([]uintptr))</span>
        case []int:<span class="cov1" title="1">
                return SliceComparable(a.([]int), b.([]int))</span>
        case []int8:<span class="cov0" title="0">
                return SliceComparable(a.([]int8), b.([]int8))</span>
        case []int16:<span class="cov0" title="0">
                return SliceComparable(a.([]int16), b.([]int16))</span>
        case []int32:<span class="cov0" title="0">
                return SliceComparable(a.([]int32), b.([]int32))</span>
        case []int64:<span class="cov0" title="0">
                return SliceComparable(a.([]int64), b.([]int64))</span>
        case []uint:<span class="cov0" title="0">
                return SliceComparable(a.([]uint), b.([]uint))</span>
        case []uint8:<span class="cov2" title="2">
                return SliceComparable(a.([]uint8), b.([]uint8))</span>
        case []uint16:<span class="cov0" title="0">
                return SliceComparable(a.([]uint16), b.([]uint16))</span>
        case []uint32:<span class="cov0" title="0">
                return SliceComparable(a.([]uint32), b.([]uint32))</span>
        case []uint64:<span class="cov0" title="0">
                return SliceComparable(a.([]uint64), b.([]uint64))</span>
        case []float32:<span class="cov0" title="0">
                return SliceComparable(a.([]float32), b.([]float32))</span>
        case []float64:<span class="cov0" title="0">
                return SliceComparable(a.([]float64), b.([]float64))</span>
        case []complex64:<span class="cov0" title="0">
                return SliceComparable(a.([]complex64), b.([]complex64))</span>
        case []complex128:<span class="cov0" title="0">
                return SliceComparable(a.([]complex128), b.([]complex128))</span>
        case []any:<span class="cov1" title="1">
                return SliceAny(a.([]any), b.([]any), nil)</span>
        case []map[string]any:<span class="cov0" title="0">
                return SliceAny(a.([]map[string]any), b.([]map[string]any), nil)</span>
        case map[string]any:<span class="cov4" title="4">
                return MapAny(av, b.(map[string]any))</span>
        default:<span class="cov0" title="0">
                return reflect.DeepEqual(a, b)</span>
        }
}

func deref(p any) (v any) <span class="cov2" title="2">{
        switch pp := p.(type) </span>{
        case *bool:<span class="cov0" title="0">
                v = *pp</span>
        case *string:<span class="cov2" title="2">
                v = *pp</span>
        case *int:<span class="cov0" title="0">
                v = *pp</span>
        case *int8:<span class="cov0" title="0">
                v = *pp</span>
        case *int16:<span class="cov0" title="0">
                v = *pp</span>
        case *int32:<span class="cov0" title="0">
                v = *pp</span>
        case *int64:<span class="cov0" title="0">
                v = *pp</span>
        case *uint:<span class="cov0" title="0">
                v = *pp</span>
        case *uint8:<span class="cov0" title="0">
                v = *pp</span>
        case *uint16:<span class="cov0" title="0">
                v = *pp</span>
        case *uint32:<span class="cov0" title="0">
                v = *pp</span>
        case *uint64:<span class="cov0" title="0">
                v = *pp</span>
        case *float32:<span class="cov0" title="0">
                v = *pp</span>
        case *float64:<span class="cov0" title="0">
                v = *pp</span>
        case *complex64:<span class="cov0" title="0">
                v = *pp</span>
        case *complex128:<span class="cov0" title="0">
                v = *pp</span>
        case *uintptr:<span class="cov0" title="0">
                v = *pp</span>
        case *[]byte:<span class="cov0" title="0">
                v = *pp</span>
        case *any:<span class="cov0" title="0">
                v = *pp</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("unsupported type %T", pp))</span>
        }
        <span class="cov2" title="2">return</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package utils

import (
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/constraint"
)

var (
        ErrEmptyArray = errors.New("empty array")
)

func Max[T constraint.Sortable](arr ...T) T <span class="cov2" title="37">{
        if len(arr) == 0 </span><span class="cov0" title="0">{
                panic(ErrEmptyArray)</span>
        }

        <span class="cov2" title="37">max := arr[0]
        for i := 1; i &lt; len(arr); i++ </span><span class="cov2" title="37">{
                if arr[i] &gt; max </span><span class="cov0" title="0">{
                        max = arr[i]
                }</span>
        }

        <span class="cov2" title="37">return max</span>
}

func Min[T constraint.Sortable](arr ...T) T <span class="cov9" title="60353760">{
        if len(arr) == 0 </span><span class="cov0" title="0">{
                panic(ErrEmptyArray)</span>
        }

        <span class="cov10" title="60354533">min := arr[0]
        for i := 1; i &lt; len(arr); i++ </span><span class="cov9" title="60354106">{
                if arr[i] &lt; min </span><span class="cov8" title="5391433">{
                        min = arr[i]
                }</span>
        }

        <span class="cov9" title="60354519">return min</span>
}

func IsInRange[T constraint.Sortable](num, min, max T) bool <span class="cov0" title="0">{
        if num &lt; min || num &gt; max </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package compress

import (
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
)

//go:generate stringer -type=Algorithm -trimprefix=Algorithm
type Algorithm uint8

const (
        AlgorithmUnknown Algorithm = iota
        AlgorithmZSTD
        AlgorithmZLib
        AlgorithmS2
        AlgorithmGZip
        AlgorithmDeflate
)

var (
        algorithmEnum = utils.NewEnumString[Algorithm, []Algorithm](
                map[Algorithm]string{
                        AlgorithmZSTD:    "zstd",
                        AlgorithmZLib:    "zlib",
                        AlgorithmS2:      "s2",
                        AlgorithmGZip:    "gzip",
                        AlgorithmDeflate: "deflate",
                },
        )
)

func (e Algorithm) Value() uint8 <span class="cov7" title="5910">{
        return uint8(e)
}</span>

func (e Algorithm) String() string <span class="cov4" title="166">{
        return algorithmEnum.String(e)
}</span>

func (e Algorithm) IsValid() bool <span class="cov10" title="177845">{
        return algorithmEnum.IsValid(e)
}</span>

func ParseAlgorithm(s any) Algorithm <span class="cov7" title="5711">{
        switch v := s.(type) </span>{
        case string:<span class="cov7" title="3417">
                if enumList := algorithmEnum.Enum(v); len(enumList) &gt; 0 </span><span class="cov7" title="3300">{
                        return enumList[0]
                }</span>
        case Algorithm:<span class="cov6" title="2295">
                return v</span>
        default:<span class="cov0" title="0">
                return Algorithm(cast.ToInt(s))</span>
        }
        <span class="cov4" title="117">return AlgorithmUnknown</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package compress

import (
        "io"

        "github.com/wfusion/gofusion/common/utils"
)

type decodable interface {
        io.Reader
        Reset(r io.Reader) error
}

func DecodeBytesFunc(algo Algorithm) func(src []byte) (dst []byte, err error) <span class="cov6" title="18942">{
        return func(src []byte) (dst []byte, err error) </span><span class="cov6" title="18942">{
                var (
                        dec      decodable
                        recycles []func()
                )
                defer func() </span><span class="cov6" title="18942">{
                        for _, cb := range recycles </span><span class="cov7" title="56826">{
                                if cb != nil </span><span class="cov7" title="56826">{
                                        cb()
                                }</span>
                        }
                }()

                <span class="cov6" title="18942">srcBuffer, bufferCb := utils.BytesBufferPool.Get(nil)
                recycles = append(recycles, bufferCb)
                srcBuffer.Write(src)
                _, err = utils.Catch(func() </span><span class="cov6" title="18942">{
                        var cb func()
                        dec, cb = getDecoder(algo, srcBuffer)
                        recycles = append(recycles, cb)
                }</span>)
                <span class="cov6" title="18942">if err != nil || dec == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov6" title="18942">dstBuffer, bufferCb := utils.BytesBufferPool.Get(nil)
                recycles = append(recycles, bufferCb)
                if _, err = io.Copy(dstBuffer, dec); err != nil </span><span class="cov6" title="15280">{
                        if err = utils.ErrIgnore(err, eofErrs...); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov6" title="18942">dst = make([]byte, dstBuffer.Len())
                copy(dst, dstBuffer.Bytes())
                return</span>
        }
}

func DecodeStreamFunc(algo Algorithm) func(dst io.Writer, src io.Reader) (err error) <span class="cov0" title="0">{
        return func(dst io.Writer, src io.Reader) (err error) </span><span class="cov0" title="0">{
                var (
                        dec decodable
                        cb  func()
                )
                defer func() </span><span class="cov0" title="0">{
                        if cb != nil </span><span class="cov0" title="0">{
                                cb()
                        }</span>
                }()

                <span class="cov0" title="0">if _, err = utils.Catch(func() </span><span class="cov0" title="0">{ dec, cb = getDecoder(algo, src) }</span>); err != nil <span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">_, err = io.Copy(dst, dec)
                return utils.ErrIgnore(err, eofErrs...)</span>
        }
}

func getDecoder(algo Algorithm, src io.Reader) (dec decodable, recycle func()) <span class="cov6" title="29212">{
        p, ok := decoderPools[algo]
        if !algo.IsValid() || !ok </span><span class="cov0" title="0">{
                panic(ErrUnknownAlgorithm)</span>
        }

        <span class="cov6" title="29212">sealer, recycle := p.Get(src)
        dec = sealer.decodable
        return</span>
}

type decoder struct {
        dec decodable
        r   io.Reader
        cb  func()
}

func NewDecFunc(algo Algorithm) func(r io.Reader) io.ReadCloser <span class="cov6" title="10270">{
        return func(r io.Reader) io.ReadCloser </span><span class="cov6" title="10270">{
                dec, cb := getDecoder(algo, r)
                return &amp;decoder{
                        dec: dec,
                        r:   r,
                        cb:  cb,
                }
        }</span>
}

func (e *decoder) Reset(r io.Reader) error          <span class="cov0" title="0">{ return e.dec.Reset(r) }</span>
func (e *decoder) Read(p []byte) (n int, err error) <span class="cov10" title="5863087">{ return e.dec.Read(p) }</span>
func (e *decoder) Close() (err error)               <span class="cov6" title="10270">{ defer e.cb(); utils.CloseAnyway(e.r); return }</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package compress

import (
        "io"

        "github.com/wfusion/gofusion/common/utils"
)

type encodable interface {
        io.WriteCloser
        Flush() error
        Reset(w io.Writer)
}

func EncodeBytesFunc(algo Algorithm) func(src []byte) (dst []byte, err error) <span class="cov6" title="22241">{
        return func(src []byte) (dst []byte, err error) </span><span class="cov6" title="22239">{
                var (
                        enc      encodable
                        recycles []func()
                )
                defer func() </span><span class="cov6" title="22242">{
                        for _, cb := range recycles </span><span class="cov7" title="66725">{
                                if cb != nil </span><span class="cov7" title="66725">{
                                        cb()
                                }</span>
                        }
                }()

                <span class="cov6" title="22240">dstBuffer, bufferCb := utils.BytesBufferPool.Get(nil)
                recycles = append(recycles, bufferCb)

                _, err = utils.Catch(func() </span><span class="cov6" title="22241">{
                        var cb func()
                        enc, cb = getEncoder(algo, dstBuffer)
                        recycles = append(recycles, cb)
                }</span>)
                <span class="cov6" title="22242">if err != nil || enc == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov6" title="22242">srcBuffer, bufferCb := utils.BytesBufferPool.Get(nil)
                recycles = append(recycles, bufferCb)
                srcBuffer.Write(src)
                if _, err = io.Copy(enc, srcBuffer); err != nil </span><span class="cov0" title="0">{
                        if err = utils.ErrIgnore(err, eofErrs...); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov6" title="22242">if err = enc.Flush(); err != nil </span><span class="cov0" title="0">{
                        if err = utils.ErrIgnore(err, eofErrs...); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov6" title="22242">dst = make([]byte, dstBuffer.Len())
                copy(dst, dstBuffer.Bytes())
                return</span>
        }
}

func EncodeStreamFunc(algo Algorithm) func(dst io.Writer, src io.Reader) (err error) <span class="cov0" title="0">{
        return func(dst io.Writer, src io.Reader) (err error) </span><span class="cov0" title="0">{
                var (
                        enc encodable
                        cb  func()
                )
                if _, err = utils.Catch(func() </span><span class="cov0" title="0">{ enc, cb = getEncoder(algo, dst) }</span>); err != nil <span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if cb != nil </span><span class="cov0" title="0">{
                                cb()
                        }</span>
                }()

                <span class="cov0" title="0">if _, err = io.Copy(enc, src); err != nil </span><span class="cov0" title="0">{
                        if err = utils.ErrIgnore(err, eofErrs...); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">err = enc.Flush()
                return utils.ErrIgnore(err, eofErrs...)</span>
        }
}

func getEncoder(algo Algorithm, dst io.Writer) (enc encodable, recycle func()) <span class="cov7" title="32512">{
        p, ok := encoderPools[algo]
        if !algo.IsValid() || !ok </span><span class="cov0" title="0">{
                panic(ErrUnknownAlgorithm)</span>
        }

        <span class="cov7" title="32510">sealer, recycle := p.Get(dst)
        enc = sealer.encodable
        return</span>
}

type encoder struct {
        enc encodable
        w   io.Writer
        cb  func()
}

func NewEncFunc(algo Algorithm) func(w io.Writer) encodable <span class="cov6" title="10270">{
        return func(w io.Writer) encodable </span><span class="cov6" title="10270">{
                enc, cb := getEncoder(algo, w)
                if enc == nil </span><span class="cov0" title="0">{
                        panic(ErrUnknownAlgorithm)</span>
                }
                <span class="cov6" title="10269">return &amp;encoder{
                        enc: enc,
                        w:   w,
                        cb:  cb,
                }</span>
        }
}

func (e *encoder) Write(p []byte) (n int, err error) <span class="cov10" title="5721275">{ return e.enc.Write(p) }</span>
func (e *encoder) Reset(w io.Writer)                 <span class="cov0" title="0">{ e.enc.Reset(w) }</span>
func (e *encoder) Flush() (err error)                <span class="cov6" title="13720">{ defer utils.FlushAnyway(e.w); return e.enc.Flush() }</span>
func (e *encoder) Close() (err error) <span class="cov6" title="10270">{
        defer e.cb()
        defer utils.CloseAnyway(e.w)
        return e.Flush()
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package compress

import (
        "errors"
        "io"

        "github.com/klauspost/compress/flate"
        "github.com/klauspost/compress/gzip"
        "github.com/klauspost/compress/s2"
        "github.com/klauspost/compress/zlib"
        "github.com/klauspost/compress/zstd"

        "github.com/wfusion/gofusion/common/utils"
)

const (
        RndSeed int64 = 9009760027768254931
)

var (
        ErrUnknownAlgorithm = errors.New("unknown compress algorithm")

        encoderPools = map[Algorithm]utils.Poolable[*writerPoolSealer]{
                AlgorithmZSTD: utils.NewPool(func() *writerPoolSealer <span class="cov6" title="674">{
                        return &amp;writerPoolSealer{utils.Must(zstd.NewWriter(nil))}
                }</span>),
                AlgorithmZLib: utils.NewPool(func() *writerPoolSealer <span class="cov6" title="473">{
                        return &amp;writerPoolSealer{zlib.NewWriter(nil)}
                }</span>),
                AlgorithmS2: utils.NewPool(func() *writerPoolSealer <span class="cov6" title="521">{
                        return &amp;writerPoolSealer{s2.NewWriter(nil)}
                }</span>),
                AlgorithmGZip: utils.NewPool(func() *writerPoolSealer <span class="cov6" title="530">{
                        return &amp;writerPoolSealer{gzip.NewWriter(nil)}
                }</span>),
                AlgorithmDeflate: utils.NewPool(func() *writerPoolSealer <span class="cov6" title="539">{
                        return &amp;writerPoolSealer{utils.Must(flate.NewWriter(nil, flate.DefaultCompression))}
                }</span>),
        }

        decoderPools = map[Algorithm]utils.Poolable[*readerPoolSealer]{
                AlgorithmZSTD: utils.NewPool(func() *readerPoolSealer <span class="cov6" title="458">{
                        return &amp;readerPoolSealer{utils.Must(zstd.NewReader(nil))}
                }</span>),
                AlgorithmZLib: utils.NewPool(func() *readerPoolSealer <span class="cov6" title="406">{
                        return &amp;readerPoolSealer{new(zlibDecodable)} // init when call reset method
                }</span>),
                AlgorithmS2: utils.NewPool(func() *readerPoolSealer <span class="cov6" title="439">{
                        return &amp;readerPoolSealer{&amp;s2Decodable{s2.NewReader(nil)}}
                }</span>),
                AlgorithmGZip: utils.NewPool(func() *readerPoolSealer <span class="cov6" title="408">{
                        return &amp;readerPoolSealer{new(gzipDecodable)} // init when call reset method
                }</span>),
                AlgorithmDeflate: utils.NewPool(func() *readerPoolSealer <span class="cov6" title="421">{
                        return &amp;readerPoolSealer{new(deflateDecodable)} // init when call reset method
                }</span>),
        }

        eofErrs = []error{io.EOF, io.ErrUnexpectedEOF}
)

type readerPoolSealer struct{ decodable }

func (r *readerPoolSealer) Reset(obj any) error <span class="cov9" title="29212">{
        return r.decodable.Reset(obj.(io.Reader))
}</span>

type writerPoolSealer struct{ encodable }

func (w *writerPoolSealer) Reset(obj any) <span class="cov10" title="32509">{
        w.encodable.Reset(obj.(io.Writer))
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package compress

import (
        "io"
        
        "github.com/klauspost/compress/flate"
        "github.com/klauspost/compress/gzip"
        "github.com/klauspost/compress/s2"
        "github.com/klauspost/compress/zlib"
)

type s2Decodable struct {
        *s2.Reader
}

func (s *s2Decodable) Read(p []byte) (n int, err error) <span class="cov9" title="1184121">{ return s.Reader.Read(p) }</span>
func (s *s2Decodable) Reset(r io.Reader) (err error)    <span class="cov6" title="5716">{ s.Reader.Reset(r); return }</span>

type gzipDecodable struct {
        io.ReadCloser
}

func (g *gzipDecodable) Read(p []byte) (n int, err error) <span class="cov10" title="1218687">{ return g.ReadCloser.Read(p) }</span>
func (g *gzipDecodable) Reset(r io.Reader) (err error)    <span class="cov6" title="5715">{ g.ReadCloser, err = gzip.NewReader(r); return }</span>

type deflateDecodable struct {
        io.ReadCloser
}

func (d *deflateDecodable) Read(p []byte) (n int, err error) <span class="cov9" title="1218675">{ return d.ReadCloser.Read(p) }</span>
func (d *deflateDecodable) Reset(r io.Reader) (err error)    <span class="cov6" title="5716">{ d.ReadCloser = flate.NewReader(r); return }</span>

type zlibDecodable struct {
        io.ReadCloser
}

func (z *zlibDecodable) Read(p []byte) (n int, err error) <span class="cov9" title="1218526">{ return z.ReadCloser.Read(p) }</span>
func (z *zlibDecodable) Reset(r io.Reader) (err error)    <span class="cov6" title="5716">{ z.ReadCloser, err = zlib.NewReader(r); return }</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package utils

import (
        "context"
        "reflect"
)

// GetCtxAny with a default value
func GetCtxAny[T any](ctx context.Context, key string, args ...T) (val T) <span class="cov10" title="77095">{
        if v := ctx.Value(key); v != nil </span><span class="cov6" title="725">{
                return v.(T)
        }</span>
        <span class="cov9" title="76400">if len(args) == 0 </span><span class="cov9" title="76048">{
                return
        }</span>
        <span class="cov5" title="353">return args[0]</span>
}

// SetCtxAny with any value
func SetCtxAny[T any](ctx context.Context, key string, val T) context.Context <span class="cov6" title="529">{
        return context.WithValue(ctx, key, val)
}</span>

// TravelCtx context parent traversal
func TravelCtx(child context.Context, fn func(ctx context.Context) bool) <span class="cov2" title="5">{
        v := reflect.ValueOf(child)
        for p := v; p.IsValid() &amp;&amp; p.CanInterface(); p = p.FieldByName("Context") </span><span class="cov2" title="5">{
                parent, ok := p.Interface().(context.Context)
                if !ok || parent == nil || fn(parent) </span><span class="cov2" title="5">{
                        break</span>
                }
                <span class="cov0" title="0">if p = reflect.Indirect(p); p.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package utils

import (
        "reflect"
        "unsafe"

        "github.com/pkg/errors"
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/constraint"
)

// SliceMapping Mapping slice convert go1.18 version
func SliceMapping[T, K any](s []T, mapFn func(t T) K) (d []K) <span class="cov8" title="1895115">{
        if s == nil </span><span class="cov6" title="55738">{
                return
        }</span>
        <span class="cov8" title="1839567">d = make([]K, 0, len(s))
        for _, item := range s </span><span class="cov9" title="67410316">{
                d = append(d, mapFn(item))
        }</span>
        <span class="cov8" title="1838776">return</span>
}

// SortableToGeneric convert sortable type to generic type
func SortableToGeneric[T, K constraint.Sortable](s T) (d K) <span class="cov5" title="6263">{
        switch any(d).(type) </span>{
        case int:<span class="cov0" title="0">
                return any(cast.ToInt(s)).(K)</span>
        case int8:<span class="cov0" title="0">
                return any(cast.ToInt8(s)).(K)</span>
        case int16:<span class="cov0" title="0">
                return any(cast.ToInt16(s)).(K)</span>
        case int32:<span class="cov0" title="0">
                return any(cast.ToInt32(s)).(K)</span>
        case int64:<span class="cov0" title="0">
                return any(cast.ToInt64(s)).(K)</span>
        case *int:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToInt(s))).(K)</span>
        case *int8:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToInt8(s))).(K)</span>
        case *int16:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToInt16(s))).(K)</span>
        case *int32:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToInt32(s))).(K)</span>
        case *int64:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToInt64(s))).(K)</span>
        case uint:<span class="cov0" title="0">
                return any(cast.ToUint(s)).(K)</span>
        case uint8:<span class="cov0" title="0">
                return any(cast.ToUint8(s)).(K)</span>
        case uint16:<span class="cov0" title="0">
                return any(cast.ToUint16(s)).(K)</span>
        case uint32:<span class="cov0" title="0">
                return any(cast.ToUint32(s)).(K)</span>
        case uint64:<span class="cov0" title="0">
                return any(cast.ToUint64(s)).(K)</span>
        case *uint:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToUint(s))).(K)</span>
        case *uint8:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToUint8(s))).(K)</span>
        case *uint16:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToUint16(s))).(K)</span>
        case *uint32:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToUint32(s))).(K)</span>
        case *uint64:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToUint64(s))).(K)</span>
        case float32:<span class="cov0" title="0">
                return any(cast.ToFloat32(s)).(K)</span>
        case float64:<span class="cov0" title="0">
                return any(cast.ToFloat64(s)).(K)</span>
        case *float32:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToFloat32(s))).(K)</span>
        case *float64:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToFloat64(s))).(K)</span>
        case string:<span class="cov5" title="6263">
                return any(cast.ToString(s)).(K)</span>
        case *string:<span class="cov0" title="0">
                return any(AnyPtr(cast.ToString(s))).(K)</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("cannot mapping %T", d))</span>
        }
}

var sortableReflectType = []reflect.Type{
        constant.IntType,
        constant.UintType,
        constant.StringType,
        constant.Float32Type,
        constant.Float64Type,
        constant.BoolType,
}

// ComparableToSortable convert generic type to sortable type
func ComparableToSortable[T comparable](s T) (d any) <span class="cov1" title="1">{
        val := reflect.ValueOf(s)
        typ := val.Type()
        for _, sortableType := range sortableReflectType </span><span class="cov1" title="1">{
                if typ.ConvertibleTo(sortableType) </span><span class="cov1" title="1">{
                        return val.Convert(sortableType).Interface()
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

// SliceConvert &gt;= go1.18 recommend to use SliceMapping
func SliceConvert(src any, dstType reflect.Type) any <span class="cov5" title="6012">{
        srcVal := reflect.ValueOf(src)
        srcType := reflect.TypeOf(src)
        dstVal := reflect.Indirect(reflect.New(dstType))
        if srcType.Kind() != reflect.Slice || dstType.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                panic(errors.Errorf("src or dst type is invalid [src[%s] dst[%s]]", srcType.Kind(), dstType.Kind()))</span>
        }

        <span class="cov5" title="6012">isInterfaceSlice := false
        srcElemType := srcType.Elem()
        if srcType == constant.AnySliceType </span><span class="cov0" title="0">{
                if srcVal.Len() == 0 </span><span class="cov0" title="0">{
                        return dstVal.Interface()
                }</span>
                <span class="cov0" title="0">srcElemType = reflect.TypeOf(srcVal.Index(0).Interface())
                isInterfaceSlice = true</span>
        }

        <span class="cov5" title="6012">dstElemType := dstType.Elem()
        if !srcElemType.ConvertibleTo(dstElemType) </span><span class="cov0" title="0">{
                panic(errors.Errorf("src elem is not convertible to dst elem [src[%s] dst[%s]]",
                        srcElemType.Kind(), dstElemType.Kind()))</span>
        }

        <span class="cov5" title="6017">length := srcVal.Len()
        for i := 0; i &lt; length; i++ </span><span class="cov5" title="6017">{
                srcElem := srcVal.Index(i)
                if isInterfaceSlice </span><span class="cov0" title="0">{
                        srcElem = reflect.ValueOf(srcVal.Index(i).Interface())
                }</span>
                <span class="cov5" title="6017">dstVal = reflect.Append(dstVal, srcElem.Convert(dstElemType))</span>
        }

        <span class="cov5" title="6016">return dstVal.Interface()</span>
}

func AnyPtr[T any](s T) *T <span class="cov10" title="68483515">{ return &amp;s }</span>

// UnsafeStringToBytes converts string to byte slice without a memory allocation.
// Fork from github.com/gin-gonic/gin@v1.7.7/internal/bytesconv/bytesconv.go
func UnsafeStringToBytes(s string) []byte <span class="cov0" title="0">{
        return *(*[]byte)(unsafe.Pointer(
                &amp;struct {
                        string
                        Cap int
                }{s, len(s)},
        ))
}</span>

// UnsafeBytesToString converts byte slice to string without a memory allocation.
// Fork from github.com/gin-gonic/gin@v1.7.7/internal/bytesconv/bytesconv.go
func UnsafeBytesToString(b []byte) string <span class="cov0" title="0">{
        return *(*string)(unsafe.Pointer(&amp;b))
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package encode

import (
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
)

//go:generate stringer -type=Algorithm -trimprefix=Algorithm
type Algorithm uint8

const (
        AlgorithmUnknown Algorithm = iota
        AlgorithmHex
        AlgorithmBase32Std
        AlgorithmBase32Hex
        AlgorithmBase64Std
        AlgorithmBase64URL
        AlgorithmBase64RawStd // without padding
        AlgorithmBase64RawURL // without padding
)

var (
        algorithmEnum = utils.NewEnumString[Algorithm, []Algorithm](
                map[Algorithm]string{
                        AlgorithmHex:          "hex",
                        AlgorithmBase32Std:    "base32",
                        AlgorithmBase32Hex:    "base32-hex",
                        AlgorithmBase64Std:    "base64",
                        AlgorithmBase64URL:    "base64-url",
                        AlgorithmBase64RawStd: "base64-raw",
                        AlgorithmBase64RawURL: "base64-raw-url",
                },
        )
)

func (e Algorithm) Value() uint8 <span class="cov0" title="0">{
        return uint8(e)
}</span>

func (e Algorithm) String() string <span class="cov5" title="231">{
        return algorithmEnum.String(e)
}</span>

func (e Algorithm) IsValid() bool <span class="cov10" title="45788">{
        return algorithmEnum.IsValid(e)
}</span>

func ParseAlgorithm(s any) Algorithm <span class="cov3" title="35">{
        switch v := s.(type) </span>{
        case string:<span class="cov3" title="35">
                if enumList := algorithmEnum.Enum(v); len(enumList) &gt; 0 </span><span class="cov3" title="35">{
                        return enumList[0]
                }</span>
        case Algorithm:<span class="cov0" title="0">
                return v</span>
        default:<span class="cov0" title="0">
                return Algorithm(cast.ToInt(s))</span>
        }
        <span class="cov0" title="0">return AlgorithmUnknown</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package encode

import (
        "bytes"
        "runtime"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/cipher"
        "github.com/wfusion/gofusion/common/utils/compress"
)

type codec struct {
        buf              *bytes.Buffer
        encOpts, decOpts []utils.OptionExtender

        queue   [][2]int
        release func()
}

// From a byte slice or a string, not concurrent safe
func From[T ~[]byte | ~string](src T) (c Codecable) <span class="cov9" title="34348">{
        buf, cb := utils.BytesBufferPool.Get(nil)

        switch v := any(src).(type) </span>{
        case []byte:<span class="cov9" title="34304">
                buf.Write(v)</span>
        case string:<span class="cov3" title="43">
                buf.WriteString(v)</span>
        default:<span class="cov0" title="0">
                buf.Write([]byte(src))</span>
        }

        <span class="cov9" title="34346">c = &amp;codec{
                buf:     buf,
                release: cb,
        }

        runtime.SetFinalizer(c, func(c *codec) </span><span class="cov9" title="34342">{ c.release() }</span>)
        <span class="cov9" title="34348">return</span>
}

func (c *codec) Encode(opts ...utils.OptionExtender) Codecable <span class="cov8" title="23426">{
        for i, p := 0, len(c.encOpts); i &lt; len(opts); i++ </span><span class="cov9" title="58198">{
                c.queue = append(c.queue, [2]int{p + i, 0})
        }</span>
        <span class="cov8" title="23426">c.encOpts = append(c.encOpts, opts...)
        return c</span>
}
func (c *codec) Decode(opts ...utils.OptionExtender) Codecable <span class="cov9" title="37555">{
        for i, p := 0, len(c.decOpts); i &lt; len(opts); i++ </span><span class="cov9" title="54984">{
                c.queue = append(c.queue, [2]int{p + i, 1})
        }</span>
        <span class="cov9" title="37555">c.decOpts = append(c.decOpts, opts...)
        return c</span>
}
func (c *codec) ToBytes() (dst []byte, err error) <span class="cov8" title="25058">{
        if err = c.transform(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="25058">dst = make([]byte, c.buf.Len())
        copy(dst, c.buf.Bytes())
        return</span>
}
func (c *codec) ToString() (dst string, err error) <span class="cov8" title="9290">{
        if err = c.transform(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="9290">dst = c.buf.String()
        return</span>
}

func (c *codec) transform() (err error) <span class="cov9" title="34348">{
        for _, elem := range c.queue </span><span class="cov10" title="113182">{
                idx, isEnc := elem[0], elem[1] == 0
                if isEnc </span><span class="cov9" title="58198">{
                        if err = c.encode(c.encOpts[idx]); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                } else<span class="cov9" title="54984"> {
                        if err = c.decode(c.decOpts[idx]); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                }
        }

        <span class="cov9" title="34348">return</span>
}
func (c *codec) encode(opt utils.OptionExtender) (err error) <span class="cov9" title="58198">{
        var enc func([]byte) ([]byte, error)

        switch option := utils.ApplyOptions[option](opt); parseEncodedType(opt) </span>{
        case EncodedTypeCompress:<span class="cov8" title="22239">
                enc = compress.EncodeBytesFunc(option.compressAlgo)</span>
        case EncodedTypeCipher:<span class="cov8" title="18330">
                enc, err = cipher.EncryptBytesFunc(option.cipherAlgo, option.cipherMode, option.key, option.iv)</span>
        case EncodedTypeEncode:<span class="cov8" title="17626">
                enc = NewEncodeFunc(option.printableAlgo)</span>
        default:<span class="cov0" title="0">
                return ErrEncodeMethodNotFound</span>
        }
        <span class="cov9" title="58194">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="58194">dst, err := enc(c.buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="58198">c.buf.Reset()
        c.buf.Write(dst)
        return</span>
}
func (c *codec) decode(opt utils.OptionExtender) (err error) <span class="cov9" title="54984">{
        var dec func([]byte) ([]byte, error)

        switch option := utils.ApplyOptions[option](opt); parseEncodedType(opt) </span>{
        case EncodedTypeCompress:<span class="cov8" title="18942">
                dec = compress.DecodeBytesFunc(option.compressAlgo)</span>
        case EncodedTypeCipher:<span class="cov8" title="18373">
                dec, err = cipher.DecryptBytesFunc(option.cipherAlgo, option.cipherMode, option.key, option.iv)</span>
        case EncodedTypeEncode:<span class="cov8" title="17669">
                dec = NewDecodeFunc(option.printableAlgo)</span>
        default:<span class="cov0" title="0">
                return ErrEncodeMethodNotFound</span>
        }
        <span class="cov9" title="54984">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="54984">dst, err := dec(c.buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="54984">c.buf.Reset()
        c.buf.Write(dst)
        return</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package encode

import (
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
)

type EncodedType int8

const (
        EncodedTypeUnknown EncodedType = iota
        EncodedTypeCipher
        EncodedTypeCompress
        EncodedTypeEncode
)

var (
        encodeTypeEnum = utils.NewEnumString[EncodedType, []EncodedType](
                map[EncodedType]string{
                        EncodedTypeCipher:   "cipher",
                        EncodedTypeCompress: "compress",
                        EncodedTypeEncode:   "encode",
                },
        )
)

func (e EncodedType) Value() uint8 <span class="cov0" title="0">{
        return uint8(e)
}</span>

func (e EncodedType) String() string <span class="cov0" title="0">{
        return encodeTypeEnum.String(e)
}</span>

func (e EncodedType) IsValid() bool <span class="cov8" title="31531">{
        return encodeTypeEnum.IsValid(e)
}</span>

func ParseEncodedType(s any) EncodedType <span class="cov0" title="0">{
        switch v := s.(type) </span>{
        case string:<span class="cov0" title="0">
                if enumList := encodeTypeEnum.Enum(v); len(enumList) &gt; 0 </span><span class="cov0" title="0">{
                        return enumList[0]
                }</span>
        case EncodedType:<span class="cov0" title="0">
                return v</span>
        default:<span class="cov0" title="0">
                return EncodedType(cast.ToInt(s))</span>
        }
        <span class="cov0" title="0">return EncodedTypeUnknown</span>
}

func parseEncodedType(one utils.OptionExtender) EncodedType <span class="cov10" title="144686">{
        opts := utils.ApplyOptions[option](one)
        switch </span>{
        case opts.cipherAlgo.IsValid():<span class="cov9" title="47511">
                return EncodedTypeCipher</span>
        case opts.compressAlgo.IsValid():<span class="cov9" title="51453">
                return EncodedTypeCompress</span>
        case opts.printableAlgo.IsValid():<span class="cov9" title="45753">
                return EncodedTypeEncode</span>
        default:<span class="cov0" title="0">
                return EncodedTypeUnknown</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package encode

import (
        "encoding/base32"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "io"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/cipher"
        "github.com/wfusion/gofusion/common/utils/compress"
)

func NewCodecStream(opts ...utils.OptionExtender) Streamable <span class="cov6" title="10587">{
        encodeOrder := make([]EncodedType, 0, len(opts))
        for _, opt := range opts </span><span class="cov6" title="31509">{
                if encType := parseEncodedType(opt); encType.IsValid() </span><span class="cov6" title="31534">{
                        encodeOrder = append(encodeOrder, encType)
                }</span>
        }
        <span class="cov6" title="10973">if len(encodeOrder) == 0 </span><span class="cov0" title="0">{
                panic(ErrEncodeMethodNotFound)</span>
        }
        <span class="cov6" title="10973">return &amp;codecStream{
                o:           utils.ApplyOptions[option](opts...),
                encodeOrder: encodeOrder,
        }</span>
}

type codecStream struct {
        o           *option
        encodeOrder []EncodedType
}

func (w *codecStream) Encode(dst io.Writer, src io.Reader) (n int64, err error) <span class="cov6" title="10972">{
        for i := len(w.encodeOrder) - 1; i &gt;= 0; i-- </span><span class="cov6" title="31535">{
                switch w.encodeOrder[i] </span>{
                case EncodedTypeCompress:<span class="cov6" title="10270">
                        dst = compress.NewEncFunc(w.o.compressAlgo)(dst)</span>
                case EncodedTypeCipher:<span class="cov6" title="10810">
                        dst = cipher.NewEncFunc(w.o.cipherAlgo, w.o.cipherMode, w.o.key, w.o.iv)(dst)</span>
                case EncodedTypeEncode:<span class="cov6" title="10458">
                        dst = NewWriter(w.o.printableAlgo, dst)</span>
                }
        }

        <span class="cov6" title="10974">buf, cb := utils.BytesPool.Get(defaultBufferSize)
        defer cb()

        defer utils.CloseAnyway(dst)
        n, err = io.CopyBuffer(dst, src, buf)
        if errors.Is(err, io.ErrUnexpectedEOF) || errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                err = nil
        }</span>
        <span class="cov6" title="10974">return</span>
}

func (w *codecStream) Decode(dst io.Writer, src io.Reader) (n int64, err error) <span class="cov6" title="10974">{
        for i := len(w.encodeOrder) - 1; i &gt;= 0; i-- </span><span class="cov6" title="31536">{
                switch w.encodeOrder[i] </span>{
                case EncodedTypeCompress:<span class="cov6" title="10270">
                        src = compress.NewDecFunc(w.o.compressAlgo)(src)</span>
                case EncodedTypeCipher:<span class="cov6" title="10809">
                        src = cipher.NewDecFunc(w.o.cipherAlgo, w.o.cipherMode, w.o.key, w.o.iv)(src)</span>
                case EncodedTypeEncode:<span class="cov6" title="10458">
                        src = NewReader(w.o.printableAlgo, src)</span>
                }
        }

        <span class="cov6" title="10974">buf, cb := utils.BytesPool.Get(defaultBufferSize)
        defer cb()
        defer utils.CloseAnyway(src)
        n, err = io.CopyBuffer(dst, src, buf)
        if errors.Is(err, io.ErrUnexpectedEOF) || errors.Is(err, io.EOF) </span><span class="cov5" title="4168">{
                err = nil
        }</span>
        <span class="cov6" title="10974">return</span>
}

func NewWriter(algo Algorithm, w io.Writer) io.Writer <span class="cov6" title="10458">{
        switch algo </span>{
        case AlgorithmHex:<span class="cov4" title="1494">
                return newEncoder(hex.NewEncoder(w), w)</span>
        case AlgorithmBase32Std:<span class="cov4" title="1494">
                return newEncoder(base32.NewEncoder(base32.StdEncoding, w), w)</span>
        case AlgorithmBase32Hex:<span class="cov4" title="1494">
                return newEncoder(base32.NewEncoder(base32.HexEncoding, w), w)</span>
        case AlgorithmBase64Std:<span class="cov4" title="1494">
                return newEncoder(base64.NewEncoder(base64.StdEncoding, w), w)</span>
        case AlgorithmBase64URL:<span class="cov4" title="1494">
                return newEncoder(base64.NewEncoder(base64.URLEncoding, w), w)</span>
        case AlgorithmBase64RawStd:<span class="cov4" title="1494">
                return newEncoder(base64.NewEncoder(base64.RawStdEncoding, w), w)</span>
        case AlgorithmBase64RawURL:<span class="cov4" title="1494">
                return newEncoder(base64.NewEncoder(base64.RawURLEncoding, w), w)</span>
        default:<span class="cov0" title="0">
                panic(ErrUnknownAlgorithm)</span>
        }
}

func NewEncodeFunc(algo Algorithm) func([]byte) ([]byte, error) <span class="cov6" title="17626">{
        var (
                encodeFunc     func(src, dst []byte)
                encodedLenFunc func(int) int
        )
        switch algo </span>{
        case AlgorithmHex:<span class="cov5" title="2518">
                encodeFunc = func(src, dst []byte) </span><span class="cov5" title="2518">{ hex.Encode(src, dst) }</span>
                <span class="cov5" title="2518">encodedLenFunc = hex.EncodedLen</span>
        case AlgorithmBase32Std:<span class="cov5" title="2518">
                encodeFunc = base32.StdEncoding.Encode
                encodedLenFunc = base32.StdEncoding.EncodedLen</span>
        case AlgorithmBase32Hex:<span class="cov5" title="2518">
                encodeFunc = base32.HexEncoding.Encode
                encodedLenFunc = base32.HexEncoding.EncodedLen</span>
        case AlgorithmBase64Std:<span class="cov5" title="2518">
                encodeFunc = base64.StdEncoding.Encode
                encodedLenFunc = base64.StdEncoding.EncodedLen</span>
        case AlgorithmBase64URL:<span class="cov5" title="2518">
                encodeFunc = base64.URLEncoding.Encode
                encodedLenFunc = base64.URLEncoding.EncodedLen</span>
        case AlgorithmBase64RawStd:<span class="cov5" title="2518">
                encodeFunc = base64.RawStdEncoding.Encode
                encodedLenFunc = base64.RawStdEncoding.EncodedLen</span>
        case AlgorithmBase64RawURL:<span class="cov5" title="2518">
                encodeFunc = base64.RawURLEncoding.Encode
                encodedLenFunc = base64.RawURLEncoding.EncodedLen</span>
        default:<span class="cov0" title="0">
                panic(ErrUnknownAlgorithm)</span>
        }

        <span class="cov6" title="17626">return func(src []byte) (dst []byte, err error) </span><span class="cov6" title="17626">{
                dst = make([]byte, encodedLenFunc(len(src)))
                encodeFunc(dst, src)
                return
        }</span>
}

func NewReader(algo Algorithm, r io.Reader) io.Reader <span class="cov6" title="10458">{
        switch algo </span>{
        case AlgorithmHex:<span class="cov4" title="1494">
                return newDecoder(hex.NewDecoder(r), r)</span>
        case AlgorithmBase32Std:<span class="cov4" title="1494">
                return newDecoder(base32.NewDecoder(base32.StdEncoding, r), r)</span>
        case AlgorithmBase32Hex:<span class="cov4" title="1494">
                return newDecoder(base32.NewDecoder(base32.HexEncoding, r), r)</span>
        case AlgorithmBase64Std:<span class="cov4" title="1494">
                return newDecoder(base64.NewDecoder(base64.StdEncoding, r), r)</span>
        case AlgorithmBase64URL:<span class="cov4" title="1494">
                return newDecoder(base64.NewDecoder(base64.URLEncoding, r), r)</span>
        case AlgorithmBase64RawStd:<span class="cov4" title="1494">
                return newDecoder(base64.NewDecoder(base64.RawStdEncoding, r), r)</span>
        case AlgorithmBase64RawURL:<span class="cov4" title="1494">
                return newDecoder(base64.NewDecoder(base64.RawURLEncoding, r), r)</span>
        default:<span class="cov0" title="0">
                panic(ErrUnknownAlgorithm)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func NewDecodeFunc(algo Algorithm) func([]byte) ([]byte, error) <span class="cov6" title="17669">{
        var (
                decodeFunc     func(src, dst []byte) (int, error)
                decodedLenFunc func(int) int
        )
        switch algo </span>{
        case AlgorithmHex:<span class="cov5" title="2518">
                decodeFunc = hex.Decode
                decodedLenFunc = hex.DecodedLen</span>
        case AlgorithmBase32Std:<span class="cov5" title="2518">
                decodeFunc = base32.StdEncoding.Decode
                decodedLenFunc = base32.StdEncoding.DecodedLen</span>
        case AlgorithmBase32Hex:<span class="cov5" title="2518">
                decodeFunc = base32.HexEncoding.Decode
                decodedLenFunc = base32.HexEncoding.DecodedLen</span>
        case AlgorithmBase64Std:<span class="cov5" title="2561">
                decodeFunc = base64.StdEncoding.Decode
                decodedLenFunc = base64.StdEncoding.DecodedLen</span>
        case AlgorithmBase64URL:<span class="cov5" title="2518">
                decodeFunc = base64.URLEncoding.Decode
                decodedLenFunc = base64.URLEncoding.DecodedLen</span>
        case AlgorithmBase64RawStd:<span class="cov5" title="2518">
                decodeFunc = base64.RawStdEncoding.Decode
                decodedLenFunc = base64.RawStdEncoding.DecodedLen</span>
        case AlgorithmBase64RawURL:<span class="cov5" title="2518">
                decodeFunc = base64.RawURLEncoding.Decode
                decodedLenFunc = base64.RawURLEncoding.DecodedLen</span>
        default:<span class="cov0" title="0">
                panic(ErrUnknownAlgorithm)</span>
        }

        <span class="cov6" title="17669">return func(src []byte) (dst []byte, err error) </span><span class="cov6" title="17669">{
                dst = make([]byte, decodedLenFunc(len(src)))
                n, err := decodeFunc(dst, src)
                if err == nil </span><span class="cov6" title="17669">{
                        dst = dst[:n]
                }</span>
                <span class="cov6" title="17669">return</span>
        }
}

type decoder struct {
        dec, r io.Reader
}

func newDecoder(dec, r io.Reader) io.Reader <span class="cov6" title="10458">{
        return &amp;decoder{dec: dec, r: r}
}</span>

func (e *decoder) Read(p []byte) (n int, err error) <span class="cov10" title="16410255">{ return e.dec.Read(p) }</span>
func (e *decoder) Close()                           <span class="cov6" title="10457">{ utils.CloseAnyway(e.r); utils.CloseAnyway(e.dec) }</span>

type encoder struct {
        enc, w io.Writer
}

func newEncoder(enc, w io.Writer) io.Writer <span class="cov6" title="10458">{
        return &amp;encoder{enc: enc, w: w}
}</span>

func (e *encoder) Write(p []byte) (n int, err error) <span class="cov7" title="318767">{ return e.enc.Write(p) }</span>
func (e *encoder) Close()                            <span class="cov6" title="10458">{ utils.CloseAnyway(e.enc); utils.CloseAnyway(e.w) }</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package encode

import (
        "errors"
        "io"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/cipher"
        "github.com/wfusion/gofusion/common/utils/clone"
        "github.com/wfusion/gofusion/common/utils/compress"
)

const (
        RndSeed int64 = -6544809196299914340
)

var (
        ErrUnknownAlgorithm     = errors.New("unknown encode algorithm")
        ErrEncodeMethodNotFound = errors.New("not found encode method")

        defaultBufferSize = 4 * 1024 // 4kb
)

type Streamable interface {
        Encode(dst io.Writer, src io.Reader) (n int64, err error)
        Decode(dst io.Writer, src io.Reader) (n int64, err error)
}

type Codecable interface {
        Encode(opts ...utils.OptionExtender) Codecable
        Decode(opts ...utils.OptionExtender) Codecable
        ToBytes() (dst []byte, err error)
        ToString() (dst string, err error)
}

type option struct {
        key, iv    []byte
        cipherMode cipher.Mode
        cipherAlgo cipher.Algorithm

        compressAlgo  compress.Algorithm
        printableAlgo Algorithm
}

func Cipher(algo cipher.Algorithm, mode cipher.Mode, key, iv []byte) utils.OptionFunc[option] <span class="cov6" title="953">{
        return func(o *option) </span><span class="cov9" title="95022">{
                o.cipherAlgo = algo
                o.cipherMode = mode
                o.key = clone.SliceComparable(key)
                o.iv = clone.SliceComparable(iv)
        }</span>
}

func Compress(algo compress.Algorithm) utils.OptionFunc[option] <span class="cov7" title="6729">{
        return func(o *option) </span><span class="cov10" title="102900">{
                o.compressAlgo = algo
        }</span>
}

func Encode(algo Algorithm) utils.OptionFunc[option] <span class="cov5" title="249">{
        return func(o *option) </span><span class="cov9" title="91503">{
                o.printableAlgo = algo
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package utils

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/pkg/errors"
        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

type Enumerable[T comparable, TS ~[]T] interface {
        Enum(s string) TS
        String(k any) string
        IsValid(t T) bool
}

type enumStringOption struct {
        ignoreCaseSensitivity bool
}

type enumStringOptFn func(*enumStringOption)

func IgnoreEnumStringCase() enumStringOptFn <span class="cov0" title="0">{
        return func(e *enumStringOption) </span><span class="cov0" title="0">{
                e.ignoreCaseSensitivity = true
        }</span>
}

func NewEnumString[T comparable, TS ~[]T](mapping map[T]string, opts ...OptionExtender) Enumerable[T, TS] <span class="cov4" title="84">{
        opt := ApplyOptions[enumStringOption](opts...)
        if len(mapping) == 0 </span><span class="cov0" title="0">{
                panic(errors.New("enum mapping is empty"))</span>
        }
        <span class="cov4" title="84">return (&amp;enumString[T, TS]{
                mapping:    mapping,
                ignoreCase: opt.ignoreCaseSensitivity,
        }).init()</span>
}

type enumString[T comparable, TS ~[]T] struct {
        ignoreCase      bool
        elemType        reflect.Type
        elemSliceType   reflect.Type
        prefix          string
        mapping         map[T]string
        reversedMapping map[string]TS
}

func (e *enumString[T, TS]) Enum(s string) TS <span class="cov7" title="6145">{
        s = e.caseSensitivityConv(s)
        if v, ok := e.reversedMapping[s]; ok </span><span class="cov7" title="6012">{
                return SliceConvert(v, e.elemSliceType).(TS)
        }</span>
        <span class="cov4" title="130">return nil</span>
}

func (e *enumString[T, TS]) String(k any) string <span class="cov6" title="2342">{
        if reflect.TypeOf(k).ConvertibleTo(e.elemType) </span><span class="cov6" title="2342">{
                k = reflect.ValueOf(k).Convert(e.elemType).Interface().(T)
        }</span>
        <span class="cov6" title="2342">if t, ok := k.(T); !ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s(%v)", e.prefix, k)
        }</span> else<span class="cov6" title="2342"> {
                if v, ok := e.mapping[t]; ok </span><span class="cov6" title="2341">{
                        return v
                }</span>
                // avoid stack overflow for Stringer implement
                <span class="cov1" title="1">sortable := ComparableToSortable(t)
                if sortable != nil </span><span class="cov1" title="1">{
                        return fmt.Sprintf("%s(%+v)", e.prefix, sortable)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Sprintf("%s(N/A)", e.prefix)
                }</span>
        }
}

func (e *enumString[T, TS]) IsValid(t T) bool <span class="cov10" title="414052">{
        _, ok := e.mapping[t]
        return ok
}</span>

func (e *enumString[T, TS]) init() Enumerable[T, TS] <span class="cov4" title="84">{
        // get key
        var key any
        for k := range e.mapping </span><span class="cov4" title="84">{
                key = k
                break</span>
        }
        <span class="cov4" title="84">e.elemType = reflect.TypeOf(key)
        e.elemSliceType = reflect.SliceOf(e.elemType)

        // get prefix name
        e.prefix = cases.Title(language.English, cases.NoLower).String(e.elemType.Name())

        // get reversed mapping
        e.reversedMapping = make(map[string]TS, len(e.mapping))
        for k, v := range e.mapping </span><span class="cov5" title="462">{
                v = e.caseSensitivityConv(v)
                e.reversedMapping[v] = append(e.reversedMapping[v], k)
        }</span>

        <span class="cov4" title="84">return e</span>
}

func (e *enumString[T, TS]) caseSensitivityConv(s string) string <span class="cov7" title="6607">{
        if e.ignoreCase </span><span class="cov0" title="0">{
                return strings.ToLower(s)
        }</span>
        <span class="cov7" title="6607">return s</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package utils

type Error string

func (e Error) Error() string <span class="cov0" title="0">{
        return string(e)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package utils

import (
        "reflect"
        "regexp"
        "runtime"

        "github.com/gobwas/glob"
        "github.com/mitchellh/mapstructure"
)

func GetFuncName(fn any) string <span class="cov5" title="959">{
        return runtime.FuncForPC(reflect.ValueOf(fn).Pointer()).Name()
}</span>

func WrapFunc(fn any) func(...any) <span class="cov3" title="48">{
        return func(a ...any) </span><span class="cov8" title="139944">{
                runVariadicFunc(fn, a...)
        }</span>
}

func WrapFuncAny(fn any) func(...any) []any <span class="cov0" title="0">{
        return func(a ...any) (b []any) </span><span class="cov0" title="0">{
                ret := runVariadicFunc(fn, a...)
                b = make([]any, 0, len(b))
                for i := 0; i &lt; len(ret); i++ </span><span class="cov0" title="0">{
                        b = append(b, ret[i].Interface())
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

func WrapFunc1[T any](fn any) func(...any) T <span class="cov5" title="854">{
        return func(a ...any) (t T) </span><span class="cov6" title="8332">{
                ret := runVariadicFunc(fn, a...)
                return ParseVariadicFuncResult[T](ret, 0)
        }</span>
}

// WrapFunc2 wrap a function with any number inputs and 2 generic type return,
// return nothing if function has 0 outputs
// return T1 if function only has 1 output
// return function first output and last output if function has more than 2 outputs
func WrapFunc2[T1, T2 any](fn any) func(...any) (T1, T2) <span class="cov5" title="558">{
        return func(a ...any) (t1 T1, t2 T2) </span><span class="cov5" title="556">{
                ret := runVariadicFunc(fn, a...)
                t1 = ParseVariadicFuncResult[T1](ret, 0)
                t2 = ParseVariadicFuncResult[T2](ret, 1)
                return
        }</span>
}

func WrapFunc3[T1, T2, T3 any](fn any) func(...any) (T1, T2, T3) <span class="cov0" title="0">{
        return func(a ...any) (t1 T1, t2 T2, t3 T3) </span><span class="cov0" title="0">{
                ret := runVariadicFunc(fn, a...)
                t1 = ParseVariadicFuncResult[T1](ret, 0)
                t2 = ParseVariadicFuncResult[T2](ret, 1)
                t3 = ParseVariadicFuncResult[T3](ret, 2)
                return
        }</span>
}

func WrapFunc4[T1, T2, T3, T4 any](fn any) func(...any) (T1, T2, T3, T4) <span class="cov0" title="0">{
        return func(a ...any) (t1 T1, t2 T2, t3 T3, t4 T4) </span><span class="cov0" title="0">{
                ret := runVariadicFunc(fn, a...)
                t1 = ParseVariadicFuncResult[T1](ret, 0)
                t2 = ParseVariadicFuncResult[T2](ret, 1)
                t3 = ParseVariadicFuncResult[T3](ret, 2)
                t4 = ParseVariadicFuncResult[T4](ret, 3)
                return
        }</span>
}

func WrapFunc5[T1, T2, T3, T4, T5 any](fn any) func(...any) (T1, T2, T3, T4, T5) <span class="cov0" title="0">{
        return func(a ...any) (t1 T1, t2 T2, t3 T3, t4 T4, t5 T5) </span><span class="cov0" title="0">{
                ret := runVariadicFunc(fn, a...)
                t1 = ParseVariadicFuncResult[T1](ret, 0)
                t2 = ParseVariadicFuncResult[T2](ret, 1)
                t3 = ParseVariadicFuncResult[T3](ret, 2)
                t4 = ParseVariadicFuncResult[T4](ret, 3)
                t5 = ParseVariadicFuncResult[T5](ret, 4)
                return
        }</span>
}

func WrapFunc6[T1, T2, T3, T4, T5, T6 any](fn any) func(...any) (T1, T2, T3, T4, T5, T6) <span class="cov0" title="0">{
        return func(a ...any) (t1 T1, t2 T2, t3 T3, t4 T4, t5 T5, t6 T6) </span><span class="cov0" title="0">{
                ret := runVariadicFunc(fn, a...)
                t1 = ParseVariadicFuncResult[T1](ret, 0)
                t2 = ParseVariadicFuncResult[T2](ret, 1)
                t3 = ParseVariadicFuncResult[T3](ret, 2)
                t4 = ParseVariadicFuncResult[T4](ret, 3)
                t5 = ParseVariadicFuncResult[T5](ret, 4)
                t6 = ParseVariadicFuncResult[T6](ret, 5)
                return
        }</span>
}

func WrapFunc7[T1, T2, T3, T4, T5, T6, T7 any](fn any) func(...any) (T1, T2, T3, T4, T5, T6, T7) <span class="cov0" title="0">{
        return func(a ...any) (t1 T1, t2 T2, t3 T3, t4 T4, t5 T5, t6 T6, t7 T7) </span><span class="cov0" title="0">{
                ret := runVariadicFunc(fn, a...)
                t1 = ParseVariadicFuncResult[T1](ret, 0)
                t2 = ParseVariadicFuncResult[T2](ret, 1)
                t3 = ParseVariadicFuncResult[T3](ret, 2)
                t4 = ParseVariadicFuncResult[T4](ret, 3)
                t5 = ParseVariadicFuncResult[T5](ret, 4)
                t6 = ParseVariadicFuncResult[T6](ret, 5)
                t7 = ParseVariadicFuncResult[T7](ret, 6)
                return
        }</span>
}

func runVariadicFunc(fn any, a ...any) []reflect.Value <span class="cov8" title="148845">{
        var (
                variadic   []reflect.Value
                typ        = reflect.TypeOf(fn)
                val        = reflect.ValueOf(fn)
                numIn      = typ.NumIn()
                isVariadic = typ.IsVariadic()
        )

        if isVariadic </span><span class="cov8" title="139977">{
                b := a[numIn-1:]
                bt := typ.In(numIn - 1).Elem()
                variadic = make([]reflect.Value, 0, len(b))
                for _, param := range b </span><span class="cov9" title="358740">{
                        paramVal := reflect.ValueOf(param)
                        if paramVal.CanConvert(bt) </span><span class="cov9" title="360155">{
                                variadic = append(variadic, paramVal.Convert(bt))
                        }</span> else<span class="cov0" title="0"> {
                                bo := reflect.New(bt).Elem().Interface()
                                MustSuccess(mapstructure.Decode(param, &amp;bo))
                                variadic = append(variadic, reflect.ValueOf(bo))
                        }</span>
                }
                <span class="cov8" title="140166">a = a[:numIn-1]</span>
        }

        <span class="cov8" title="149051">in := make([]reflect.Value, 0, len(a)+len(variadic))
        for idx, param := range a </span><span class="cov9" title="428761">{
                pt := typ.In(idx)
                paramVal := reflect.ValueOf(param)
                if paramVal.CanConvert(pt) </span><span class="cov9" title="429243">{
                        in = append(in, paramVal.Convert(pt))
                }</span> else<span class="cov3" title="81"> {
                        po := reflect.New(pt).Elem().Interface()
                        MustSuccess(mapstructure.Decode(param, &amp;po))
                        in = append(in, reflect.ValueOf(po))
                }</span>
        }
        <span class="cov8" title="149138">in = append(in, variadic...)

        return val.Call(in)</span>
}

func ParseVariadicFuncResult[T any](rs []reflect.Value, idx int) (t T) <span class="cov7" title="9693">{
        var (
                ok  bool
                typ = reflect.TypeOf(t)
        )
        for i := idx; i &lt; len(rs); i++ </span><span class="cov7" title="8941">{
                r := rs[i]
                if !r.IsValid() || r.Type() == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="8941">if v := r.Interface(); v != nil </span><span class="cov6" title="8522">{
                        if t, ok = v.(T); !ok &amp;&amp; typ != nil &amp;&amp; reflect.TypeOf(v).ConvertibleTo(typ) </span><span class="cov0" title="0">{
                                t = r.Convert(typ).Interface().(T)
                        }</span>
                }
        }
        <span class="cov7" title="9688">return</span>
}

type getCallerOption struct {
        skipRegList        []*regexp.Regexp
        skipGlobList       []glob.Glob
        minimumCallerDepth int
}

func SkipRegexps(patterns ...string) OptionFunc[getCallerOption] <span class="cov2" title="14">{
        return func(o *getCallerOption) </span><span class="cov7" title="12649">{
                for _, pattern := range patterns </span><span class="cov8" title="101185">{
                        o.skipRegList = append(o.skipRegList, regexp.MustCompile(pattern))
                }</span>
        }
}

func SkipGlobs(patterns ...string) OptionFunc[getCallerOption] <span class="cov3" title="52">{
        return func(o *getCallerOption) </span><span class="cov7" title="12633">{
                for _, pattern := range patterns </span><span class="cov9" title="202259">{
                        o.skipGlobList = append(o.skipGlobList, glob.MustCompile(pattern))
                }</span>
        }
}

func SkipKnownDepth(minimumCallerDepth int) OptionFunc[getCallerOption] <span class="cov2" title="14">{
        return func(o *getCallerOption) </span><span class="cov7" title="12649">{
                o.minimumCallerDepth = minimumCallerDepth
        }</span>
}

// GetCaller retrieves the name after stack skip
func GetCaller(maximumCallerDepth int, opts ...OptionExtender) (frame *runtime.Frame) <span class="cov7" title="12647">{
        opt := ApplyOptions[getCallerOption](opts...)
        pcs := make([]uintptr, maximumCallerDepth)
        depth := runtime.Callers(opt.minimumCallerDepth, pcs)
        frames := runtime.CallersFrames(pcs[:depth])
outer:
        for f, hasMore := frames.Next(); hasMore; f, hasMore = frames.Next() </span><span class="cov8" title="74684">{
                frame = &amp;f

                // If the caller isn't part of this package, we're done
                for _, skipGlob := range opt.skipGlobList </span><span class="cov10" title="828053">{
                        if skipGlob.Match(f.File) </span><span class="cov7" title="28403">{
                                continue outer</span>
                        }
                }
                <span class="cov8" title="46310">for _, s := range opt.skipRegList </span><span class="cov8" title="179953">{
                        if s.MatchString(f.File) </span><span class="cov7" title="33656">{
                                continue outer</span>
                        }
                }
                <span class="cov7" title="12649">break</span>
        }

        <span class="cov7" title="12649">return</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package utils

import (
        "container/heap"
        "errors"
)

var (
        ErrOutOfRange = errors.New("out of range")
)

type _heap[E any] struct {
        d   []E
        cmp func(e1, e2 E) int
}

func (h *_heap[E]) Len() int           <span class="cov0" title="0">{ return len(h.d) }</span>
func (h *_heap[E]) Less(i, j int) bool <span class="cov0" title="0">{ v := h.cmp(h.d[i], h.d[j]); return v &lt; 0 }</span>
func (h *_heap[E]) Swap(i, j int)      <span class="cov0" title="0">{ h.d[i], h.d[j] = h.d[j], h.d[i] }</span>
func (h *_heap[E]) Push(x any)         <span class="cov0" title="0">{ v := append(h.d, x.(E)); h.d = v }</span>
func (h *_heap[E]) Pop() (x any)       <span class="cov0" title="0">{ x, h.d = h.d[len(h.d)-1], h.d[0:len(h.d)-1]; return x }</span>

// Heap base on generics to build a heap tree for any type
type Heap[E any] struct {
        data *_heap[E]
}

// Push pushes the element x onto the heap.
// The complexity is O(log n) where n = h.Len().
func (h *Heap[E]) Push(v E) <span class="cov0" title="0">{ heap.Push(h.data, v) }</span>

// Pop removes and returns the minimum element (according to Less) from the heap.
// The complexity is O(log n) where n = h.Len().
// Pop is equivalent to Remove(h, 0).
func (h *Heap[E]) Pop() E <span class="cov0" title="0">{ return heap.Pop(h.data).(E) }</span>

func (h *Heap[E]) Element(index int) (e E, err error) <span class="cov0" title="0">{
        if index &lt; 0 || index &gt;= h.data.Len() </span><span class="cov0" title="0">{
                return e, ErrOutOfRange
        }</span>
        <span class="cov0" title="0">return h.data.d[index], nil</span>
}

// Remove removes and returns the element at index i from the heap.
// The complexity is O(log n) where n = h.Len().
func (h *Heap[E]) Remove(index int) E <span class="cov0" title="0">{ return heap.Remove(h.data, index).(E) }</span>
func (h *Heap[E]) Len() int           <span class="cov0" title="0">{ return len(h.data.d) }</span>

// Copy heap
func (h *Heap[E]) Copy() *Heap[E] <span class="cov0" title="0">{
        ret := &amp;_heap[E]{cmp: h.data.cmp}
        ret.d = make([]E, len(h.data.d))
        copy(ret.d, h.data.d)
        heap.Init(ret)
        return &amp;Heap[E]{data: ret}
}</span>

// NewHeap return an initial Heap pointer
func NewHeap[E any](t []E, cmp func(e1, e2 E) int) *Heap[E] <span class="cov0" title="0">{
        ret := &amp;_heap[E]{d: t, cmp: cmp}
        heap.Init(ret)
        return &amp;Heap[E]{data: ret}
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">// Inspired by github.com/chenzhuoyu/go-inspect

package inspect

import (
        "errors"
        "reflect"
        "unsafe"
)

type Field struct {
        t *rtype
        p unsafe.Pointer
}

// Get returns the value of the referenced field, even if it's private.
func (f Field) Get() reflect.Value <span class="cov6" title="33">{
        if f.t == nil </span><span class="cov0" title="0">{
                panic(errors.New("inspect: invalid field"))</span>
        }
        <span class="cov6" title="33">return reflect.ValueOf(f.read().pack())</span>
}

// Set updates the value of the referenced field, even if it's private.
func (f Field) Set(v reflect.Value) <span class="cov9" title="382">{
        if f.t == nil </span><span class="cov0" title="0">{
                panic(errors.New("inspect: invalid field"))</span>
        }

        <span class="cov9" title="382">v = v.Convert(packType(f.t))
        typedmemmove(f.t, f.p, f.addr(v))</span>
}

func (f Field) read() eface <span class="cov6" title="33">{
        if ifaceIndir(f.t) </span><span class="cov4" title="8">{
                return eface{_type: f.t, data: f.p}
        }</span> else<span class="cov5" title="25"> {
                return eface{_type: f.t, data: *(*unsafe.Pointer)(f.p)}
        }</span>
}

func (f Field) addr(v reflect.Value) unsafe.Pointer <span class="cov9" title="382">{
        if ifaceIndir(f.t) </span><span class="cov8" title="128">{
                return (*eface)(unsafe.Pointer(&amp;v)).data
        }</span> else<span class="cov9" title="254"> {
                return unsafe.Pointer(&amp;((*eface)(unsafe.Pointer(&amp;v)).data))
        }</span>
}

func newField(v reflect.Value, fv reflect.StructField) Field <span class="cov10" title="415">{
        return Field{
                t: unpackType(fv.Type),
                p: unsafe.Pointer(uintptr((*eface)(unsafe.Pointer(&amp;v)).data) + fv.Offset),
        }
}</span>

func derefType(t reflect.Type) reflect.Type <span class="cov0" title="0">{
        for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov0" title="0">return t</span>
}

func derefValue(t reflect.Value) reflect.Value <span class="cov10" title="415">{
        for t.Kind() == reflect.Ptr </span><span class="cov10" title="415">{
                t = t.Elem()
        }</span>
        <span class="cov10" title="415">return t</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">//go:build go1.18
// +build go1.18

// Inspired by github.com/chenzhuoyu/go-inspect

package inspect

import (
        "reflect"
        "unsafe"
)

// FieldByName locates a field with name.
func FieldByName(v reflect.Value, name string) (Field, bool) <span class="cov10" title="415">{
        if fv, ok := v.Type().FieldByName(name); !ok </span><span class="cov0" title="0">{
                return Field{}, false
        }</span> else<span class="cov10" title="415"> {
                return newField(v, fv), true
        }</span>
}

// FieldAt locates a field with index.
func FieldAt(v reflect.Value, idx int) (Field, bool) <span class="cov0" title="0">{
        if idx &lt; 0 || idx &gt;= v.NumField() </span><span class="cov0" title="0">{
                return Field{}, false
        }</span> else<span class="cov0" title="0"> {
                return newField(v, v.Type().Field(idx)), true
        }</span>
}

func SetField[T any](obj any, fieldName string, val T) <span class="cov9" title="382">{
        mustOk(FieldByName(derefValue(reflect.ValueOf(obj)), fieldName)).Set(reflect.ValueOf(val))
}</span>

func GetField[T any](obj any, fieldName string) (r T) <span class="cov6" title="33">{
        r, _ = mustOk(FieldByName(derefValue(reflect.ValueOf(obj)), fieldName)).Get().Interface().(T)
        return
}</span>

// deprecated
func setField[T any](obj any, fieldName string, val T) <span class="cov0" title="0">{
        v := reflect.ValueOf(obj)
        t := reflect.Indirect(v).Type()
        *(*T)(unsafe.Pointer(v.Pointer() + mustOk(t.FieldByName(fieldName)).Offset)) = val
}</span>

// deprecated
func getField[T any](obj any, fieldName string) (r T) <span class="cov0" title="0">{
        v := reflect.Indirect(reflect.ValueOf(obj))
        r, _ = valueInterface(v.FieldByName(fieldName), false).(T)
        return
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">//go:build go1.18
// +build go1.18

package inspect

import (
        "reflect"
        "runtime"
        "unsafe"
)

func enumerateTypes(cb func(reflect.Type) bool) <span class="cov2" title="14">{
        t0 := reflect.TypeOf(struct{}{})
        sections, typeLinks := typelinks()
        for i, typeLink := range typeLinks </span><span class="cov2" title="14">{
                for _, link := range typeLink </span><span class="cov9" title="207334">{
                        (*eface)(unsafe.Pointer(&amp;t0)).data = resolveTypeOff(sections[i], link)
                        if t0.Kind() != reflect.Ptr || !supportTypes[t0.Elem().Kind()] </span><span class="cov8" title="103663">{
                                continue</span>
                        }
                        <span class="cov8" title="103671">typ := t0.Elem()
                        if typ.PkgPath() == "" || typ.Name() == "" </span><span class="cov6" title="4134">{
                                continue</span>
                        }
                        <span class="cov8" title="99537">if !cb(typ) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

func enumerateFuncs(cb func(*runtime.Func, uintptr) bool) <span class="cov2" title="14">{
        for _, md := range activeModules() </span><span class="cov2" title="14">{
                for _, tab := range md.ftab </span><span class="cov10" title="848475">{
                        f := tab // should not take from &amp;tab.entry because go syntax
                        absoluteAddr := textAddr(md, f.entry)
                        if fn := runtime.FuncForPC(absoluteAddr); fn != nil </span><span class="cov9" title="848461">{
                                if !cb(fn, absoluteAddr) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Inspired by github.com/chenzhuoyu/go-inspect

package inspect

import (
        "reflect"
        "runtime"
        "sync"
        "unsafe"
)

var (
        lock    sync.RWMutex
        structs = make(map[string]reflect.Type)
        funcs   = make(map[string]unsafe.Pointer)

        supportTypes = map[reflect.Kind]bool{
                reflect.Bool:       true,
                reflect.Int:        true,
                reflect.Int8:       true,
                reflect.Int16:      true,
                reflect.Int32:      true,
                reflect.Int64:      true,
                reflect.Uint:       true,
                reflect.Uint8:      true,
                reflect.Uint16:     true,
                reflect.Uint32:     true,
                reflect.Uint64:     true,
                reflect.Uintptr:    true,
                reflect.Float32:    true,
                reflect.Float64:    true,
                reflect.Complex64:  true,
                reflect.Complex128: true,
                reflect.Array:      true,
                reflect.Chan:       true,
                reflect.Map:        true,
                reflect.Slice:      true,
                reflect.String:     true,
                reflect.Struct:     true,
                reflect.Interface:  true,
        }
)

// TypeOf find the type by package path and name
func TypeOf(typeName string) reflect.Type <span class="cov6" title="2594">{
        lock.RLock()
        defer lock.RUnlock()
        if typ, ok := structs[typeName]; ok </span><span class="cov6" title="2593">{
                return typ
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RuntimeTypeOf find the type by package path and name in runtime
func RuntimeTypeOf(typeName string) (r reflect.Type) <span class="cov0" title="0">{
        enumerateTypes(func(typ reflect.Type) bool </span><span class="cov0" title="0">{
                if typ.PkgPath()+"."+typ.Name() == typeName </span><span class="cov0" title="0">{
                        r = typ
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">return</span>
}

// FuncOf find the function entry by package path and name,
// the function should be linked and should not be inlined
func FuncOf(funcName string) unsafe.Pointer <span class="cov4" title="395">{
        lock.RLock()
        defer lock.RUnlock()
        if entry, ok := funcs[funcName]; ok </span><span class="cov4" title="395">{
                return unsafe.Pointer(&amp;entry)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RuntimeFuncOf find the function entry by package path and name in runtime,
// the function should be linked and should not be inlined
func RuntimeFuncOf(funcName string) (r unsafe.Pointer) <span class="cov0" title="0">{
        enumerateFuncs(func(fn *runtime.Func, addr uintptr) bool </span><span class="cov0" title="0">{
                if fn.Name() == funcName </span><span class="cov0" title="0">{
                        r = unsafe.Pointer(&amp;addr)
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">return</span>
}

func init() <span class="cov2" title="14">{
        lock.Lock()
        defer lock.Unlock()

        // inspect structs
        enumerateTypes(func(typ reflect.Type) bool </span><span class="cov8" title="99537">{
                pkgName := typ.PkgPath()
                typeName := typ.Name()
                if pkgName != "" &amp;&amp; typeName != "" </span><span class="cov8" title="99537">{
                        structs[pkgName+"."+typeName] = typ
                }</span>

                <span class="cov8" title="99537">return true</span>
        })

        // inspect function
        <span class="cov2" title="14">enumerateFuncs(func(fn *runtime.Func, addr uintptr) bool </span><span class="cov10" title="848461">{
                if funcName := fn.Name(); funcName != "" </span><span class="cov9" title="848447">{
                        funcs[funcName] = unsafe.Pointer(&amp;addr)
                }</span>
                <span class="cov10" title="848461">return true</span>
        })
}
</pre>
		
		<pre class="file" id="file67" style="display: none">//go:build go1.18
// +build go1.18

package inspect

import "github.com/pkg/errors"

func mustOk[T any](out T, ok bool) T <span class="cov10" title="415">{
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("get %T with ok is false", out))</span>
        }
        <span class="cov10" title="415">return out</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package inspect

import (
        "reflect"
        "unsafe"
)

type tflag uint8
type nameOff int32 // offset to a name
type typeOff int32 // offset to an *rtype
type textOff int32 // offset from top of text section

// iface runtime.iface
type iface struct {
        tab  *itab
        data unsafe.Pointer
}

// eface runtime.eface
type eface struct {
        _type *rtype
        data  unsafe.Pointer
}

func (e eface) pack() (r interface{}) <span class="cov6" title="33">{ *(*eface)(unsafe.Pointer(&amp;r)) = e; return }</span>

// rtype reflect.rtype, declare in internal/api.Type after go1.21
type rtype struct {
        size       uintptr
        ptrdata    uintptr // number of bytes in the type that can contain pointers
        hash       uint32  // hash of type; avoids computation in hash tables
        tflag      tflag   // extra type information flags, reflect.tflag
        align      uint8   // alignment of variable with this type
        fieldAlign uint8   // alignment of struct field with this type
        kind       uint8   // enumeration for C
        // function for comparing objects of this type
        // (ptr to object A, ptr to object B) -&gt; ==?
        equal func(unsafe.Pointer, unsafe.Pointer) bool
        // gcdata stores the GC type data for the garbage collector.
        // If the KindGCProg bit is set in kind, gcdata is a GC program.
        // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
        gcdata    *byte   // garbage collection data
        str       nameOff // string form
        ptrToThis typeOff // type for pointer to this type, may be zero
}

type itab struct {
        inter *interfaceType
        _type *rtype
        hash  uint32 // copy of _type.hash. Used for type switches.
        _     [4]byte
        fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}

type interfaceType struct {
        typ     rtype
        pkgpath name
        mhdr    []iMethod
}

type name struct {
        bytes *byte
}

type iMethod struct {
        name nameOff
        typ  typeOff
}

var (
        itabRtype = func(v interface{}) *itab <span class="cov4" title="14">{
                t := reflect.TypeOf(v).Elem()
                return (*iface)(unsafe.Pointer(&amp;t)).tab
        }</span>(new(reflect.Type))
)

func unpackType(t reflect.Type) *rtype <span class="cov10" title="415">{
        return (*rtype)((*eface)(unsafe.Pointer(&amp;t)).data)
}</span>

func packType(t *rtype) (r reflect.Type) <span class="cov9" title="382">{
        (*iface)(unsafe.Pointer(&amp;r)).tab = itabRtype
        (*iface)(unsafe.Pointer(&amp;r)).data = unsafe.Pointer(t)
        return
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package utils

import (
        "net"
)

func ClientIP() (ip string) <span class="cov8" title="139985">{
        addrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="139983">for _, address := range addrs </span><span class="cov10" title="1674706">{
                if addr, ok := address.(*net.IPNet); ok &amp;&amp; !addr.IP.IsLoopback() </span><span class="cov9" title="1395834">{
                        if addr.IP.To4() != nil </span><span class="cov8" title="140124">{
                                return addr.IP.String()
                        }</span>

                }
        }

        <span class="cov0" title="0">return</span>
}

func HostIPInDocker() (ip string) <span class="cov1" title="2">{
        addrs, err := net.LookupIP("host.docker.internal")
        if err != nil </span><span class="cov1" title="2">{
                return
        }</span>

        <span class="cov0" title="0">for _, addr := range addrs </span><span class="cov0" title="0">{
                if addr.To4() != nil </span><span class="cov0" title="0">{
                        return addr.String()
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

type localIP struct {
        _     func()
        bytes []byte
        str   string
}

func (l *localIP) Bytes() (d []byte) <span class="cov3" title="107">{
        if l.bytes == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="107">d = make([]byte, len(l.bytes), cap(l.bytes))
        copy(d, l.bytes)
        return</span>
}

func (l *localIP) String() string <span class="cov1" title="1">{
        return l.str
}</span>

var LocalIP = &amp;localIP{
        str: ClientIP(),
        bytes: func() []byte <span class="cov2" title="14">{
                reverse := func(bs []byte) </span><span class="cov2" title="14">{
                        i, j := 0, len(bs)-1
                        for i &lt; j </span><span class="cov3" title="84">{
                                bs[i], bs[j] = bs[j], bs[i]
                                i++
                                j--
                        }</span>
                }

                <span class="cov2" title="14">if ipAddr := ClientIP(); ipAddr != "" </span><span class="cov2" title="14">{
                        realIP := []byte("000000000000")
                        idx := 0
                        for i := len(ipAddr) - 1; i &gt;= 0; i-- </span><span class="cov4" title="168">{
                                c := ipAddr[i]
                                if c == '.' </span><span class="cov3" title="42">{
                                        idx = (((idx - 1) / 3) + 1) * 3
                                        continue</span>
                                }
                                <span class="cov4" title="126">realIP[idx] = c
                                idx++</span>
                        }
                        <span class="cov2" title="14">reverse(realIP)
                        return realIP</span>
                }
                <span class="cov0" title="0">return []byte("000000000000")</span>
        }(),
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package utils

func MapKeys[T comparable, K any](m map[T]K) (keys []T) <span class="cov9" title="2312">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="2312">keys = make([]T, 0, len(m))
        for key := range m </span><span class="cov9" title="2380">{
                keys = append(keys, key)
        }</span>
        <span class="cov9" title="2311">return</span>
}

func MapValues[T comparable, K any](m map[T]K) (vals []K) <span class="cov6" title="148">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="148">vals = make([]K, 0, len(m))
        for _, val := range m </span><span class="cov6" title="151">{
                vals = append(vals, val)
        }</span>
        <span class="cov6" title="148">return</span>
}

func MapValuesByKeys[T comparable, K any, TS ~[]T](m map[T]K, keys TS) (vals []K) <span class="cov3" title="15">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="15">vals = make([]K, 0, len(keys))
        for _, key := range keys </span><span class="cov4" title="29">{
                val, ok := m[key]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="29">vals = append(vals, val)</span>
        }
        <span class="cov3" title="15">return</span>
}

func MapMerge[T comparable, K any](a, b map[T]K) (r map[T]K) <span class="cov8" title="1312">{
        r = make(map[T]K, len(a)+len(b))
        for k, v := range a </span><span class="cov8" title="1303">{
                r[k] = v
        }</span>
        <span class="cov8" title="1312">for k, v := range b </span><span class="cov10" title="3921">{
                r[k] = v
        }</span>
        <span class="cov8" title="1312">return</span>
}

func MapSliceToMap[T comparable, K any](s []map[T]K) (d map[T]K) <span class="cov0" title="0">{
        d = make(map[T]K, len(s))
        for _, kv := range s </span><span class="cov0" title="0">{
                for k, v := range kv </span><span class="cov0" title="0">{
                        d[k] = v
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func SliceToMap[K comparable, V any](s []V, groupFn func(v V) K) (d map[K]V) <span class="cov4" title="32">{
        d = make(map[K]V)
        for _, i := range s </span><span class="cov6" title="160">{
                d[groupFn(i)] = i
        }</span>
        <span class="cov4" title="32">return</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package utils

import (
        "encoding/gob"
        "reflect"

        "github.com/BurntSushi/toml"
        "github.com/mitchellh/mapstructure"
        "gopkg.in/yaml.v3"

        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

// JsonStringify for k8s ConfigMap, Secret
type JsonStringify[T any] struct {
        Value T
}

func (j *JsonStringify[T]) MarshalJSON() (output []byte, err error) <span class="cov0" title="0">{
        var buf []byte
        if buf, err = json.Marshal(j.Value); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if output, err = json.Marshal(buf); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

func (j *JsonStringify[T]) UnmarshalJSON(input []byte) (err error) <span class="cov0" title="0">{
        var buf string
        if err = json.Unmarshal(input, &amp;buf); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err = json.Unmarshal(UnsafeStringToBytes(buf), &amp;j.Value); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

func MustJsonMarshal(s any) []byte             <span class="cov6" title="161">{ return Must(json.Marshal(s)) }</span>
func MustJsonMarshalString(s any) string       <span class="cov0" title="0">{ return string(MustJsonMarshal(s)) }</span>
func MustJsonUnmarshal[T any](s []byte) (t *T) <span class="cov6" title="90">{ MustSuccess(json.Unmarshal(s, &amp;t)); return }</span>

type unmarshalType string

const (
        UnmarshalTypeJson unmarshalType = "json"
        UnmarshalTypeYaml unmarshalType = "yaml"
        UnmarshalTypeToml unmarshalType = "toml"
)

// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
// (The argument to Unmarshal must be a non-nil pointer.)
type InvalidUnmarshalError struct {
        Type reflect.Type
}

func (e *InvalidUnmarshalError) Error() string <span class="cov0" title="0">{
        if e.Type == nil </span><span class="cov0" title="0">{
                return "common/utils: Unmarshal(nil)"
        }</span>

        <span class="cov0" title="0">if e.Type.Kind() != reflect.Pointer </span><span class="cov0" title="0">{
                return "common/utils: Unmarshal(non-pointer " + e.Type.String() + ")"
        }</span>
        <span class="cov0" title="0">return "common/utils: Unmarshal(nil " + e.Type.String() + ")"</span>
}

func Unmarshal(s, d any, tag unmarshalType) (err error) <span class="cov10" title="2516">{
        switch s.(type) </span>{
        case string, []byte:<span class="cov10" title="2516">
                bs, cb := BytesBufferPool.Get(nil)
                defer cb()
                if ss, ok := s.(string); ok </span><span class="cov9" title="2510">{
                        bs.WriteString(ss)
                }</span> else<span class="cov3" title="6"> {
                        bs.Write(s.([]byte))
                }</span>

                <span class="cov10" title="2516">switch tag </span>{
                case UnmarshalTypeJson:<span class="cov0" title="0">
                        return json.NewDecoder(bs).Decode(d)</span>
                case UnmarshalTypeYaml:<span class="cov9" title="2510">
                        err = yaml.NewDecoder(bs).Decode(d)
                        return</span>
                case UnmarshalTypeToml:<span class="cov0" title="0">
                        _, err = toml.NewDecoder(bs).Decode(d)
                        return</span>
                default:<span class="cov3" title="6">
                        err = gob.NewDecoder(bs).Decode(d)
                        return</span>
                }
        default:<span class="cov0" title="0">
                cfg := &amp;mapstructure.DecoderConfig{Result: d}
                if tag != "" </span><span class="cov0" title="0">{
                        cfg.TagName = string(tag)
                }</span>

                <span class="cov0" title="0">var dec *mapstructure.Decoder
                if dec, err = mapstructure.NewDecoder(cfg); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">err = dec.Decode(s)
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package utils

import (
        "math"
        "strconv"
        "strings"
)

func DecimalPlaces(num float64) int <span class="cov0" title="0">{
        str := strconv.FormatFloat(num, 'f', -1, 64)
        if i := strings.LastIndex(str, "."); i &gt;= 0 </span><span class="cov0" title="0">{
                return len(str[i+1:])
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func IntNarrow(num int) (result any) <span class="cov0" title="0">{
        IfAny(
                func() bool </span><span class="cov0" title="0">{ result = int8(num); return IsInRange(num, math.MinInt8, math.MaxInt8) }</span>,
                func() bool <span class="cov0" title="0">{ result = int16(num); return IsInRange(num, math.MinInt16, math.MaxInt16) }</span>,
                func() bool <span class="cov0" title="0">{ result = int32(num); return IsInRange(num, math.MinInt32, math.MaxInt32) }</span>,
                func() bool <span class="cov0" title="0">{ result = int64(num); return IsInRange(num, math.MinInt64, math.MaxInt64) }</span>,
        )
        <span class="cov0" title="0">return</span>
}

func UintNarrow(num uint) (result any) <span class="cov0" title="0">{
        IfAny(
                func() bool </span><span class="cov0" title="0">{ result = uint8(num); return IsInRange(num, 0, math.MaxUint8) }</span>,
                func() bool <span class="cov0" title="0">{ result = uint16(num); return IsInRange(num, 0, math.MaxUint16) }</span>,
                func() bool <span class="cov0" title="0">{ result = uint32(num); return IsInRange(num, 0, math.MaxUint32) }</span>,
                func() bool <span class="cov0" title="0">{ result = uint64(num); return IsInRange(num, 0, math.MaxUint64) }</span>,
        )
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package utils

type OptionExtender interface {
        applyOption(t any)
}

type OptionFunc[T any] func(*T)

func (o OptionFunc[T]) applyOption(a any) <span class="cov9" title="1503452">{
        if t, ok := a.(*T); ok </span><span class="cov9" title="1256601">{
                o(t)
        }</span>
}

func ApplyOptions[T any](opts ...OptionExtender) (t *T) <span class="cov9" title="985099">{
        t = new(T)
        for _, optional := range opts </span><span class="cov10" title="1504839">{
                if optional != nil </span><span class="cov9" title="1503901">{
                        optional.applyOption(t)
                }</span>
        }
        <span class="cov9" title="987393">return</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package utils

import (
        "bytes"
        "github.com/spf13/cast"
        "sync"
)

const (
        maxBytesPoolable = 16*1024 + 512 // 16.5kb
)

var (
        // BytesBufferPool 64 is bytes.Buffer smallBufferSize, which is an initial allocation minimal capacity.
        BytesBufferPool = NewPool(
                func() *bytes.Buffer <span class="cov9" title="1625494">{ return bytes.NewBuffer(make([]byte, 0, 64)) }</span>,
                PoolableEvictFunc(poolBytesBufferEvict),
        )
        BytesPool = NewPool(
                func() poolBytes <span class="cov9" title="2950910">{ return make([]byte, 0, 64) }</span>,
                PoolableEvictFunc(poolBytesEvict),
        )
)

type Poolable[T any] interface {
        Get(initialized any) (T, func())
        Put(obj T)
}

type poolableOption[T any] struct {
        evict func(obj T) bool
}

func PoolableEvictFunc[T any](fn func(obj T) bool) OptionFunc[poolableOption[T]] <span class="cov2" title="28">{
        return func(o *poolableOption[T]) </span><span class="cov2" title="28">{
                o.evict = fn
        }</span>
}

type poolResettableA[T any] interface{ Reset(obj any) T }
type poolResettableB interface{ Reset() }
type poolResettableC interface{ Reset() error }
type poolResettableD interface{ Reset(obj any) }
type poolResettableE interface{ Reset(obj any) error }
type poolResettableF[T any] interface{ Reset() T }

func NewPool[T any](newFn func() T, opts ...OptionExtender) Poolable[T] <span class="cov3" title="168">{
        opt := ApplyOptions[poolableOption[T]](opts...)
        return &amp;poolSealer[T]{
                option: opt,
                newFn:  newFn,
                inner: &amp;sync.Pool{
                        New: func() any </span><span class="cov9" title="4576122">{
                                return any(newFn())
                        }</span>,
                },
        }
}

type poolSealer[T any] struct {
        option *poolableOption[T]
        inner  *sync.Pool
        newFn  func() T
}

func (p *poolSealer[T]) Get(initialized any) (T, func()) <span class="cov10" title="7385356">{
        obj, ok := p.inner.Get().(T)
        if !ok </span><span class="cov0" title="0">{
                obj = p.newFn()
        }</span>

        <span class="cov9" title="7376858">switch resettable := any(obj).(type) </span>{
        case poolResettableA[T]:<span class="cov9" title="4896174">
                obj = resettable.Reset(initialized)</span>
        case poolResettableB:<span class="cov9" title="2446160">
                resettable.Reset()</span>
        case poolResettableC:<span class="cov0" title="0">
                MustSuccess(resettable.Reset())</span>
        case poolResettableD:<span class="cov6" title="32509">
                resettable.Reset(initialized)</span>
        case poolResettableE:<span class="cov6" title="29212">
                MustSuccess(resettable.Reset(initialized))</span>
        case poolResettableF[T]:<span class="cov0" title="0">
                obj = resettable.Reset()</span>
        }

        <span class="cov9" title="7382090">once := new(sync.Once)
        return obj, func() </span><span class="cov9" title="3002557">{
                once.Do(func() </span><span class="cov9" title="3005702">{
                        if p.option.evict == nil || !p.option.evict(obj) </span><span class="cov9" title="2833507">{
                                p.Put(obj)
                        }</span>
                })
        }
}

func (p *poolSealer[T]) Put(obj T) <span class="cov9" title="2833380">{ p.inner.Put(obj) }</span>

type poolBytes []byte

func (p poolBytes) Reset(initLen any) poolBytes <span class="cov9" title="4895950">{
        iLen := cast.ToInt(initLen)
        pp := p
        if cap(p) &lt; cast.ToInt(iLen) </span><span class="cov9" title="2942991">{
                pp = make([]byte, iLen)
        }</span>

        <span class="cov9" title="4889507">return pp[:iLen]</span>
}

func poolBytesBufferEvict(b *bytes.Buffer) bool <span class="cov8" title="979012">{
        return b.Cap() &gt;= maxBytesPoolable
}</span>

func poolBytesEvict(p poolBytes) bool <span class="cov9" title="1965392">{
        return cap(p) &gt;= maxBytesPoolable
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package utils

import (
        cryptoRand "crypto/rand"
        "encoding/ascii85"
        "encoding/base64"
        "encoding/hex"
        "math/rand"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/lithammer/shortuuid/v4"
        "github.com/oklog/ulid/v2"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils/inspect"
)

func UUID() string <span class="cov6" title="1542">{
        return uuid.New().String()
}</span>

// UUID_
//nolint: revive // uuid without hyphen function issue
func UUID_() string <span class="cov0" title="0">{
        return strings.Replace(uuid.New().String(), constant.Hyphen, "", -1)
}</span>

// ShortUUID returns a new short UUID with base57
func ShortUUID() string <span class="cov3" title="26">{
        return shortuuid.New()
}</span>

// ULID returns a new ULID.
func ULID() string <span class="cov4" title="103">{
        return ulid.MustNew(ulid.Now(), cryptoRand.Reader).String()
}</span>

func UUID20() string <span class="cov5" title="299">{
        id := uuid.New()
        t := make([]byte, ascii85.MaxEncodedLen(len(id)))
        n := ascii85.Encode(t, id[:])
        return string(t[:n])
}</span>

func UUID22() string <span class="cov0" title="0">{
        id := uuid.New()
        return base64.RawURLEncoding.EncodeToString(id[:])
}</span>

const (
        randomChars       = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        randomCharsLength = len(randomChars)
)

func CryptoRandom(b []byte) (n int, err error) <span class="cov10" title="197012">{
        return cryptoRand.Read(b)
}</span>

func CryptoRandomBytes(size int) ([]byte, error) <span class="cov0" title="0">{
        b := make([]byte, size)
        if _, err := cryptoRand.Read(b); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return b, nil</span>
}

func CryptoRandomLetterAndNumber(n int) (string, error) <span class="cov0" title="0">{
        b, err := CryptoRandomBytes(n)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">random := make([]byte, 0, n)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                random = append(random, randomChars[b[i]%uint8(randomCharsLength)])
        }</span>
        <span class="cov0" title="0">return string(random), nil</span>
}

func RandomLetterAndNumber(n int) string <span class="cov0" title="0">{
        random := make([]byte, 0, n)
        rand.Seed(time.Now().UnixNano())
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                random = append(random, randomChars[rand.Intn(randomCharsLength)])
        }</span>

        <span class="cov0" title="0">return string(random)</span>
}

func Random(b []byte, seed int64) (n int, err error) <span class="cov5" title="334">{
        if seed == 0 </span><span class="cov3" title="17">{
                rand.Seed(time.Now().UnixNano())
        }</span> else<span class="cov5" title="317"> {
                rand.Seed(seed)
        }</span>
        <span class="cov5" title="334">return rand.Read(b)</span>
}

func RandomNumbers(n int) string <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())
        ret := ""
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                ret += strconv.Itoa(rand.Intn(10))
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func CryptoRandomNumbers(n int) (string, error) <span class="cov0" title="0">{
        b, err := CryptoRandomBytes(n)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">random := make([]byte, 0, n)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                random = append(random, randomChars[b[i]%uint8(10)])
        }</span>
        <span class="cov0" title="0">return string(random), nil</span>
}

func NginxID() string <span class="cov4" title="107">{
        upper := func(c byte) byte </span><span class="cov5" title="428">{
                val := c
                if val &gt;= 97 &amp;&amp; val &lt;= 122 </span><span class="cov4" title="173">{
                        return val - 32
                }</span>
                <span class="cov5" title="255">return c</span>
        }
        <span class="cov4" title="107">int2byte := func(bs []byte, val int) </span><span class="cov5" title="749">{
                size := 10
                l := len(bs) - 1
                for idx := l; idx &gt;= 0; idx-- </span><span class="cov6" title="1819">{
                        bs[idx] = byte(uint(val%size) + uint('0'))
                        val = val / size
                }</span>
        }

        <span class="cov4" title="107">ret := [33]byte{}
        t := time.Now()
        year, month, day := t.Date()
        hour, minute, second := t.Clock()
        int2byte(ret[:4], year)
        int2byte(ret[4:6], int(month))
        int2byte(ret[6:8], day)
        int2byte(ret[8:10], hour)
        int2byte(ret[10:12], minute)
        int2byte(ret[12:14], second)
        copy(ret[14:26], LocalIP.Bytes())
        ms := t.UnixNano() / 1e6 % 1000
        int2byte(ret[26:29], int(ms))
        u32 := rand.Uint32()
        u32 &gt;&gt;= 16
        src := []byte{byte(u32 &amp; 0xff), byte((u32 &gt;&gt; 8) &amp; 0xff)}
        hex.Encode(ret[29:33], src)
        for idx := 29; idx &lt; 33; idx++ </span><span class="cov5" title="428">{
                ret[idx] = upper(ret[idx])
        }</span>
        <span class="cov4" title="107">return string(ret[:])</span>
}

func NewSafeRand(seed int64) *rand.Rand <span class="cov0" title="0">{
        return rand.New(newBuiltinLockedSource(seed))
}</span>

func newBuiltinLockedSource(seed int64) rand.Source64 <span class="cov2" title="14">{
        t := inspect.TypeOf("math/rand.lockedSource")
        source := reflect.New(t).Interface()

        var err error
        IfAny(
                // go1.16 - go1.19
                func() bool </span><span class="cov2" title="14">{
                        _, err = Catch(func() </span><span class="cov2" title="14">{ inspect.SetField(source, "src", rand.NewSource(seed)) }</span>)
                        <span class="cov2" title="14">return err == nil</span>
                },
                // go1.20 - go1.21, source is renamed and set seed when calling rather than constructing stage
                func() bool <span class="cov0" title="0">{
                        _, err = Catch(func() </span><span class="cov0" title="0">{ inspect.SetField(source, "s", rand.NewSource(seed)) }</span>)
                        <span class="cov0" title="0">return err == nil</span>
                },
        )
        <span class="cov2" title="14">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov2" title="14">return source.(rand.Source64)</span>
}

func init() <span class="cov2" title="14">{
        rand.Seed(time.Now().Unix())

        // assert if rand.lockedSource struct is not changed
        newBuiltinLockedSource(1).Int63()
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package utils

import (
        "container/list"
        "reflect"
        "regexp"
        "strings"

        "gorm.io/gorm/schema"
)

// IsBlank gets whether the specified object is considered empty or not.
// fork from: github.com/stretchr/testify@v1.8.0/assert/assertions.go
func IsBlank(object any) bool <span class="cov9" title="24592">{
        // get nil case out of the way
        if object == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov9" title="24592">objVal, ok := object.(reflect.Value)
        if !ok </span><span class="cov8" title="16514">{
                objVal = reflect.ValueOf(object)
        }</span>
        <span class="cov9" title="24594">switch objVal.Kind() </span>{
        // collection types are empty when they have no element
        case reflect.Chan, reflect.Map, reflect.Slice:<span class="cov7" title="1735">
                return objVal.Len() == 0</span>
        // pointers are empty if nil or if the value they point to is empty
        case reflect.Ptr:<span class="cov1" title="1">
                if objVal.IsNil() </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">deref := objVal.Elem().Interface()
                return IsBlank(deref)</span>
        // for all other types, compare against the zero value
        // array types are empty when they match their zero-initialized state
        default:<span class="cov9" title="22859">
                zero := reflect.Zero(objVal.Type())
                return reflect.DeepEqual(objVal.Interface(), zero.Interface())</span>
        }
}

func TraverseValue(data any, indirect bool, handler func(reflect.StructField, reflect.Value) (end, stepIn bool)) <span class="cov6" title="877">{
        v, ok := data.(reflect.Value)
        if !ok </span><span class="cov5" title="277">{
                v = reflect.ValueOf(data)
        }</span>
        <span class="cov6" title="877">v = IndirectValue(v)
        l := list.New()
        l.PushBack(v)
TraverseStruct:
        for l.Len() &gt; 0 </span><span class="cov8" title="16754">{
                e := IndirectValue(l.Remove(l.Front()).(reflect.Value))
                if !e.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="16753">t := IndirectType(e.Type())
                switch e.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov7" title="3334">
                        for i, num := 0, e.Len(); i &lt; num; i++ </span><span class="cov8" title="5445">{
                                l.PushBack(e.Index(i))
                        }</span>
                case reflect.Map:<span class="cov6" title="1478">
                        for iter := e.MapRange(); iter.Next(); </span><span class="cov6" title="1226">{
                                l.PushBack(iter.Key())
                                l.PushBack(iter.Value())
                        }</span>
                case reflect.Struct:<span class="cov8" title="6194">
                        for i, num := 0, e.NumField(); i &lt; num; i++ </span><span class="cov9" title="40682">{
                                ff := t.Field(i)
                                fv := e.Field(i)
                                if !fv.IsValid() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov9" title="40682">if indirect </span><span class="cov8" title="6344">{
                                        fv = IndirectValue(fv)
                                        ff.Type = IndirectType(ff.Type)
                                }</span>
                                <span class="cov9" title="40682">end, stepIn := handler(ff, fv)
                                if end </span><span class="cov6" title="600">{
                                        break TraverseStruct</span>
                                }
                                <span class="cov9" title="40082">if stepIn </span><span class="cov8" title="9524">{
                                        l.PushBack(fv)
                                }</span>
                        }
                default:<span class="cov8" title="5748"></span>
                        // do nothing
                }
        }
}

func GetFieldByTag(data any, tag, key string) (r reflect.Value, e error) <span class="cov0" title="0">{
        TraverseValue(data, true, func(field reflect.StructField, value reflect.Value) (end, stepIn bool) </span><span class="cov0" title="0">{
                if !value.IsValid() </span><span class="cov0" title="0">{
                        return false, false
                }</span>
                <span class="cov0" title="0">if value.Type().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        return false, true
                }</span>
                <span class="cov0" title="0">tagV := field.Tag.Get(tag)
                if tagV == key </span><span class="cov0" title="0">{
                        r = value
                        end = true
                        return
                }</span>
                <span class="cov0" title="0">return</span>
        })
        <span class="cov0" title="0">return</span>
}

func GetFieldByTagWithKeys(data any, tag string, keys []string) (r reflect.Value, e error) <span class="cov0" title="0">{
        keySet := NewSet[string](keys...)
        TraverseValue(data, true, func(field reflect.StructField, value reflect.Value) (end, stepIn bool) </span><span class="cov0" title="0">{
                if !value.IsValid() </span><span class="cov0" title="0">{
                        return false, false
                }</span>
                <span class="cov0" title="0">if value.Type().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        return false, true
                }</span>
                <span class="cov0" title="0">if keySet.Contains(field.Tag.Get(tag)) </span><span class="cov0" title="0">{
                        r = value
                        end = true
                        return
                }</span>
                <span class="cov0" title="0">return</span>
        })
        <span class="cov0" title="0">return</span>
}

func GetFieldTagValue(data any, tag string, pattern *regexp.Regexp) (tagValue string, e error) <span class="cov0" title="0">{
        TraverseValue(data, true, func(field reflect.StructField, value reflect.Value) (end, stepIn bool) </span><span class="cov0" title="0">{
                if !value.IsValid() </span><span class="cov0" title="0">{
                        return false, false
                }</span>
                <span class="cov0" title="0">if value.Type().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        return false, true
                }</span>
                <span class="cov0" title="0">tagV := field.Tag.Get(tag)
                if pattern.Match([]byte(tagV)) </span><span class="cov0" title="0">{
                        tagValue = tagV
                        end = true
                        return
                }</span>
                <span class="cov0" title="0">return</span>
        })
        <span class="cov0" title="0">return</span>
}

func GetGormColumnValue(data any, column string) (columnVal reflect.Value, ok bool) <span class="cov6" title="600">{
        tagKey := strings.ToUpper(column)
        TraverseValue(data, true, func(field reflect.StructField, value reflect.Value) (end, stepIn bool) </span><span class="cov8" title="6344">{
                if !value.IsValid() </span><span class="cov0" title="0">{
                        return false, false
                }</span>
                <span class="cov8" title="6344">if value.Type().Kind() == reflect.Struct </span><span class="cov7" title="2744">{
                        return false, true
                }</span>
                <span class="cov7" title="3600">tagSetting := schema.ParseTagSetting(field.Tag.Get("gorm"), ";")
                if _, ok := tagSetting[tagKey]; ok || tagSetting["COLUMN"] == column </span><span class="cov6" title="600">{
                        columnVal = value
                        end = true
                        return
                }</span>
                <span class="cov7" title="3000">return</span>
        })
        <span class="cov6" title="600">return</span>
}

// EmbedsType Returns true if t embeds e or if any of the types embedded by t embed e.
// Forked from go.uber.org/dig@v1.16.1/inout.embedsType
func EmbedsType(i any, e reflect.Type) bool <span class="cov6" title="533">{
        // given `type A foo { *In }`, this function would return false for
        // embedding dig.In, which makes for some extra error checking in places
        // that call this function. Might be worthwhile to consider reflect.Indirect
        // usage to clean up the callers.

        if i == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // maybe it's already a reflect.Type
        <span class="cov6" title="533">t, ok := i.(reflect.Type)
        if !ok </span><span class="cov0" title="0">{
                // take the type if it's not
                t = IndirectType(reflect.TypeOf(i))
        }</span>

        // We are going to do a breadth-first search of all embedded fields.
        <span class="cov6" title="533">types := list.New()
        types.PushBack(t)
        for types.Len() &gt; 0 </span><span class="cov6" title="597">{
                t := types.Remove(types.Front()).(reflect.Type)

                if t == e </span><span class="cov1" title="1">{
                        return true
                }</span>

                <span class="cov6" title="596">if t.Kind() != reflect.Struct </span><span class="cov6" title="509">{
                        continue</span>
                }

                <span class="cov4" title="87">for i := 0; i &lt; t.NumField(); i++ </span><span class="cov6" title="446">{
                        f := t.Field(i)
                        if f.Anonymous </span><span class="cov4" title="64">{
                                types.PushBack(f.Type)
                        }</span>
                }
        }

        <span class="cov6" title="532">return false</span>
}

func IndirectValue(s reflect.Value) (d reflect.Value) <span class="cov9" title="57710">{
        if !s.IsValid() </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov9" title="57713">d = s
        for d.Kind() == reflect.Ptr </span><span class="cov9" title="32783">{
                d = d.Elem()
        }</span>
        <span class="cov10" title="57715">return</span>
}

func IndirectType(s reflect.Type) (d reflect.Type) <span class="cov9" title="23293">{
        if s == nil </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov9" title="23293">d = s
        for d.Kind() == reflect.Ptr </span><span class="cov4" title="98">{
                d = d.Elem()
        }</span>
        <span class="cov9" title="23294">return</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package serialize

import (
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
)

//go:generate stringer -type=Algorithm -trimprefix=Algorithm
type Algorithm uint8

const (
        AlgorithmUnknown Algorithm = iota
        AlgorithmGob
        AlgorithmJson
        AlgorithmMsgpack
        AlgorithmCbor
)

var (
        algorithmEnum = utils.NewEnumString[Algorithm, []Algorithm](
                map[Algorithm]string{
                        AlgorithmGob:     "gob",
                        AlgorithmJson:    "json",
                        AlgorithmMsgpack: "msgpack",
                        AlgorithmCbor:    "cbor",
                },
        )
)

func (e Algorithm) Value() uint8 <span class="cov9" title="5912">{
        return uint8(e)
}</span>

func (e Algorithm) String() string <span class="cov2" title="8">{
        return algorithmEnum.String(e)
}</span>

func (e Algorithm) IsValid() bool <span class="cov10" title="14148">{
        return algorithmEnum.IsValid(e)
}</span>

func ParseAlgorithm(s any) Algorithm <span class="cov9" title="4918">{
        switch v := s.(type) </span>{
        case string:<span class="cov8" title="2623">
                if enumList := algorithmEnum.Enum(v); len(enumList) &gt; 0 </span><span class="cov8" title="2612">{
                        return enumList[0]
                }</span>
        case Algorithm:<span class="cov8" title="2295">
                return v</span>
        default:<span class="cov0" title="0">
                return Algorithm(cast.ToInt(s))</span>
        }
        <span class="cov3" title="13">return AlgorithmUnknown</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package serialize

import (
        "fmt"
        "io"

        "github.com/wfusion/gofusion/common/utils"
)

func MarshalFunc(algo Algorithm, opts ...utils.OptionExtender) func(src any) ([]byte, error) <span class="cov2" title="4">{
        fn, ok := marshalFuncMap[algo]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("unknown serialize algorithm type %+v", algo))</span>
        }
        <span class="cov2" title="4">opt := utils.ApplyOptions[marshalOption](opts...)
        return func(src any) (dst []byte, err error) </span><span class="cov3" title="8">{
                bs, cb := utils.BytesBufferPool.Get(nil)
                defer cb()

                if err = fn(bs, src, opt); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov3" title="8">dst = make([]byte, bs.Len())
                copy(dst, bs.Bytes())
                return</span>
        }
}

func MarshalStreamFunc(algo Algorithm, opts ...utils.OptionExtender) func(dst io.Writer, src any) error <span class="cov9" title="5920">{
        fn, ok := marshalFuncMap[algo]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("unknown serialize algorithm type %+v", algo))</span>
        }
        <span class="cov9" title="5921">opt := utils.ApplyOptions[marshalOption](opts...)
        return func(dst io.Writer, src any) error </span><span class="cov10" title="5923">{
                return fn(dst, src, opt)
        }</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package serialize

import (
        "encoding/gob"
        "io"

        "github.com/fxamacker/cbor/v2"
        "github.com/vmihailenco/msgpack/v5"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

var (
        marshalFuncMap = map[Algorithm]func(dst io.Writer, src any, opt *marshalOption) (err error){
                AlgorithmGob: func(dst io.Writer, src any, opt *marshalOption) (err error) <span class="cov9" title="4119">{
                        return gob.NewEncoder(dst).Encode(src)
                }</span>,
                AlgorithmJson: func(dst io.Writer, src any, opt *marshalOption) (err error) <span class="cov8" title="1803">{
                        enc := json.NewEncoder(dst)
                        if !opt.jsonEscapeHTML </span><span class="cov8" title="1803">{
                                enc.SetEscapeHTML(false)
                        }</span>
                        <span class="cov8" title="1803">enc.SetIndent(opt.jsonIndentPrefix, opt.jsonIndent)
                        return enc.Encode(src)</span>
                },
                AlgorithmMsgpack: func(dst io.Writer, src any, opt *marshalOption) (err error) <span class="cov2" title="4">{
                        enc := msgpack.NewEncoder(dst)
                        enc.UseCompactInts(opt.msgpackUseCompactInts)
                        enc.UseCompactFloats(opt.msgpackUseCompactFloats)
                        return enc.Encode(src)
                }</span>,
                AlgorithmCbor: func(dst io.Writer, src any, opt *marshalOption) (err error) <span class="cov2" title="4">{
                        return cbor.NewEncoder(dst).Encode(src)
                }</span>,
        }

        unmarshalFuncMap = map[Algorithm]func(dst any, src io.Reader, opt *unmarshalOption) (err error){
                AlgorithmGob: func(dst any, src io.Reader, opt *unmarshalOption) (err error) <span class="cov8" title="1099">{
                        return gob.NewDecoder(src).Decode(dst)
                }</span>,
                AlgorithmJson: func(dst any, src io.Reader, opt *unmarshalOption) (err error) <span class="cov8" title="1203">{
                        dec := json.NewDecoder(src)
                        if opt.jsonNumber </span><span class="cov0" title="0">{
                                dec.UseNumber()
                        }</span>
                        <span class="cov8" title="1202">if opt.disallowUnknownFields </span><span class="cov0" title="0">{
                                dec.DisallowUnknownFields()
                        }</span>
                        <span class="cov8" title="1202">return dec.Decode(dst)</span>
                },
                AlgorithmMsgpack: func(dst any, src io.Reader, opt *unmarshalOption) (err error) <span class="cov2" title="4">{
                        dec := msgpack.NewDecoder(src)
                        dec.DisallowUnknownFields(opt.disallowUnknownFields)
                        return dec.Decode(dst)
                }</span>,
                AlgorithmCbor: func(dst any, src io.Reader, opt *unmarshalOption) (err error) <span class="cov2" title="4">{
                        return cbor.NewDecoder(src).Decode(dst)
                }</span>,
        }
)

type marshalOption struct {
        jsonEscapeHTML               bool
        jsonIndent, jsonIndentPrefix string
        msgpackUseCompactInts        bool
        msgpackUseCompactFloats      bool
}

func MsgpackUseCompactInts(on bool) utils.OptionFunc[marshalOption] <span class="cov0" title="0">{
        return func(o *marshalOption) </span><span class="cov0" title="0">{
                o.msgpackUseCompactInts = on
        }</span>
}

func MsgpackUseCompactFloats(on bool) utils.OptionFunc[marshalOption] <span class="cov0" title="0">{
        return func(o *marshalOption) </span><span class="cov0" title="0">{
                o.msgpackUseCompactFloats = on
        }</span>
}

func JsonEscapeHTML(on bool) utils.OptionFunc[marshalOption] <span class="cov10" title="5916">{
        return func(o *marshalOption) </span><span class="cov9" title="5913">{
                o.jsonEscapeHTML = on
        }</span>
}

func JsonIndent(prefix, indent string) utils.OptionFunc[marshalOption] <span class="cov0" title="0">{
        return func(o *marshalOption) </span><span class="cov0" title="0">{
                o.jsonIndentPrefix, o.jsonIndent = prefix, indent
        }</span>
}

type unmarshalOption struct {
        jsonNumber            bool
        disallowUnknownFields bool
}

func JsonNumber() utils.OptionFunc[unmarshalOption] <span class="cov0" title="0">{
        return func(o *unmarshalOption) </span><span class="cov0" title="0">{
                o.jsonNumber = true
        }</span>
}

func DisallowUnknownFields() utils.OptionFunc[unmarshalOption] <span class="cov0" title="0">{
        return func(o *unmarshalOption) </span><span class="cov0" title="0">{
                o.disallowUnknownFields = true
        }</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package serialize

import (
        "fmt"
        "io"
        "reflect"

        "github.com/wfusion/gofusion/common/utils"
)

func UnmarshalFunc[T any](algo Algorithm, opts ...utils.OptionExtender) func(src []byte) (T, error) <span class="cov3" title="8">{
        fn, ok := unmarshalFuncMap[algo]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("unknown serialize algorithm type %+v", algo))</span>
        }
        <span class="cov3" title="8">opt := utils.ApplyOptions[unmarshalOption](opts...)
        return func(src []byte) (dst T, err error) </span><span class="cov3" title="8">{
                bs, cb := utils.BytesBufferPool.Get(nil)
                defer cb()

                bs.Write(src)
                err = fn(&amp;dst, bs, opt)
                return
        }</span>
}

func UnmarshalFuncByType(algo Algorithm, dst any, opts ...utils.OptionExtender) func([]byte) (any, error) <span class="cov0" title="0">{
        fn, ok := unmarshalFuncMap[algo]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("unknown serialize algorithm type %+v", algo))</span>
        }
        <span class="cov0" title="0">dstType, ok := dst.(reflect.Type)
        if !ok </span><span class="cov0" title="0">{
                dstType = reflect.TypeOf(dst)
        }</span>
        <span class="cov0" title="0">opt := utils.ApplyOptions[unmarshalOption](opts...)
        return func(src []byte) (dst any, err error) </span><span class="cov0" title="0">{
                dst = reflect.New(dstType).Interface()

                bs, cb := utils.BytesBufferPool.Get(nil)
                defer cb()

                bs.Write(src)
                err = fn(dst, bs, opt)
                return
        }</span>
}

func UnmarshalStreamFunc[T any](algo Algorithm, opts ...utils.OptionExtender) func(io.Reader) (T, error) <span class="cov10" title="2209">{
        fn, ok := unmarshalFuncMap[algo]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("unknown serialize algorithm type %+v", algo))</span>
        }
        <span class="cov10" title="2209">opt := utils.ApplyOptions[unmarshalOption](opts...)
        return func(src io.Reader) (dst T, err error) </span><span class="cov9" title="2208">{
                err = fn(&amp;dst, src, opt)
                return
        }</span>
}

func UnmarshalStreamFuncByType(algo Algorithm, dst any, opts ...utils.OptionExtender) func(io.Reader) (any, error) <span class="cov6" title="94">{
        fn, ok := unmarshalFuncMap[algo]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("unknown serialize algorithm type %+v", algo))</span>
        }
        <span class="cov6" title="94">dstType, ok := dst.(reflect.Type)
        if !ok </span><span class="cov0" title="0">{
                dstType = reflect.TypeOf(dst)
        }</span>
        <span class="cov6" title="94">opt := utils.ApplyOptions[unmarshalOption](opts...)
        return func(src io.Reader) (dst any, err error) </span><span class="cov6" title="94">{
                d := reflect.New(dstType).Interface()
                if err = fn(d, src, opt); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov6" title="94">dst = reflect.Indirect(reflect.ValueOf(d)).Interface()
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package utils

import (
        "sync"
)

type Set[T comparable] struct {
        m       *sync.RWMutex
        storage map[T]struct{}
}

func NewSet[T comparable](arr ...T) (s *Set[T]) <span class="cov7" title="98968">{
        s = &amp;Set[T]{
                m:       new(sync.RWMutex),
                storage: make(map[T]struct{}, len(arr)),
        }
        for _, item := range arr </span><span class="cov8" title="258548">{
                s.storage[item] = struct{}{}
        }</span>
        <span class="cov7" title="98949">return</span>
}

func (s *Set[T]) Size() int <span class="cov0" title="0">{
        s.m.RLock()
        defer s.m.RUnlock()
        return len(s.storage)
}</span>

func (s *Set[T]) Items() []T <span class="cov5" title="875">{
        s.m.RLock()
        defer s.m.RUnlock()

        i := 0
        ret := make([]T, len(s.storage))
        for key := range s.storage </span><span class="cov6" title="16683">{
                ret[i] = key
                i++
        }</span>
        <span class="cov5" title="875">return ret</span>
}

func (s *Set[T]) Insert(val ...T) *Set[T] <span class="cov6" title="8891">{
        s.m.Lock()
        defer s.m.Unlock()

        for _, v := range val </span><span class="cov7" title="26390">{
                s.storage[v] = struct{}{}
        }</span>
        <span class="cov6" title="8895">return s</span>
}

func (s *Set[T]) Remove(val ...T) *Set[T] <span class="cov3" title="36">{
        s.m.Lock()
        defer s.m.Unlock()

        for _, v := range val </span><span class="cov6" title="6296">{
                delete(s.storage, v)
        }</span>
        <span class="cov3" title="36">return s</span>
}

func (s *Set[T]) Contains(val T) bool <span class="cov10" title="4090362">{
        s.m.RLock()
        defer s.m.RUnlock()

        _, ok := s.storage[val]
        return ok
}</span>

func (s *Set[T]) IsSubsetOf(set *Set[T]) bool <span class="cov0" title="0">{
        s.m.RLock()
        defer s.m.RUnlock()

        for val := range s.storage </span><span class="cov0" title="0">{
                // The empty set is a subset of all sets, but in common business use,
                // there is rarely such a mathematical interpretation of the empty set being considered as
                // a subset relationship, so false is chosen here.
                if set == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if _, ok := set.storage[val]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (s *Set[T]) IntersectsWith(set *Set[T]) bool <span class="cov0" title="0">{
        s.m.RLock()
        defer s.m.RUnlock()

        src := set.storage
        dst := s.storage
        if len(src) &gt; len(dst) </span><span class="cov0" title="0">{
                src, dst = dst, src
        }</span>
        <span class="cov0" title="0">for val := range src </span><span class="cov0" title="0">{
                if dst == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if _, ok := dst[val]; ok </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (s *Set[T]) Reject(fn func(T) bool) *Set[T] <span class="cov0" title="0">{
        s.m.Lock()
        defer s.m.Unlock()

        for key := range s.storage </span><span class="cov0" title="0">{
                if fn(key) </span><span class="cov0" title="0">{
                        delete(s.storage, key)
                }</span>
        }
        <span class="cov0" title="0">return s</span>
}

func (s *Set[T]) Filter(fn func(T) bool) *Set[T] <span class="cov0" title="0">{
        s.m.Lock()
        defer s.m.Unlock()

        for key := range s.storage </span><span class="cov0" title="0">{
                if !fn(key) </span><span class="cov0" title="0">{
                        delete(s.storage, key)
                }</span>
        }
        <span class="cov0" title="0">return s</span>
}

func (s *Set[T]) Equals(o *Set[T]) bool <span class="cov0" title="0">{
        s.m.RLock()
        defer s.m.RUnlock()

        if s == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if s == nil || o == nil || s.Size() != o.Size() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for item := range s.storage </span><span class="cov0" title="0">{
                if _, ok := o.storage[item]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">for item := range o.storage </span><span class="cov0" title="0">{
                if _, ok := s.storage[item]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (s *Set[T]) Clone() (r *Set[T]) <span class="cov0" title="0">{
        s.m.RLock()
        defer s.m.RUnlock()
        return NewSet(s.Items()...)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package utils

func SliceRemove[T any, TS ~[]T](s TS, filter func(t T) bool) (d TS) <span class="cov0" title="0">{
        for i, item := range s </span><span class="cov0" title="0">{
                if filter(item) </span><span class="cov0" title="0">{
                        s = append(s[i:], s[i+1:]...)
                }</span>
        }
        <span class="cov0" title="0">return s</span>
}

func SliceReverse[T any, TS ~[]T](s TS) <span class="cov10" title="18">{
        for i := len(s)/2 - 1; i &gt;= 0; i-- </span><span class="cov10" title="18">{
                opp := len(s) - 1 - i
                s[i], s[opp] = s[opp], s[i]
        }</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package utils

import "sort"

func Sort[E any](data []E, cmp func(e1, e2 E) int) <span class="cov0" title="0">{
        sortObj := sortable[E]{data: data, cmp: cmp}
        sort.Sort(sortObj)
}</span>

func SortStable[E any](data []E, cmp func(e1, e2 E) int) <span class="cov0" title="0">{
        sortObj := sortable[E]{data: data, cmp: cmp}
        sort.Stable(sortObj)
}</span>

type sortable[E any] struct {
        data []E
        cmp  func(e1, e2 E) int
}

func (s sortable[E]) Len() int           <span class="cov0" title="0">{ return len(s.data) }</span>
func (s sortable[E]) Swap(i, j int)      <span class="cov0" title="0">{ s.data[i], s.data[j] = s.data[j], s.data[i] }</span>
func (s sortable[E]) Less(i, j int) bool <span class="cov0" title="0">{ return s.cmp(s.data[i], s.data[j]) &lt; 0 }</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package utils

import (
        "strings"
        "unicode"

        "github.com/iancoleman/strcase"
        "github.com/wfusion/gofusion/common/constant"
)

func IsStrBlank(s string) bool <span class="cov10" title="130894">{
        return strings.IndexFunc(s, func(r rune) bool </span><span class="cov8" title="27988">{ return !(unicode.IsSpace(r)) }</span>) &lt; 0
}

func IsStrPtrBlank(s *string) bool <span class="cov0" title="0">{
        return s == nil || IsStrBlank(*s)
}</span>

func IsStrNotBlank(s string) bool <span class="cov9" title="102322">{
        return !IsStrBlank(s)
}</span>

func IsStrPtrNotBlank(s *string) bool <span class="cov4" title="70">{
        return s != nil &amp;&amp; IsStrNotBlank(*s)
}</span>

var (
        keywordFuzzyDelimited = []string{
                constant.Space,
                constant.Colon,
                constant.Hyphen,
                constant.Underline,
        }
)

func FuzzyKeyword(keyword string) []string <span class="cov6" title="845">{
        words := strings.Fields(constant.NonNumberLetterReg.ReplaceAllString(keyword, " "))
        compact := strings.Join(words, "")
        lowerWords := SliceMapping(words, func(s string) string </span><span class="cov6" title="1690">{ return strings.ToLower(s) }</span>)
        <span class="cov6" title="845">upperWords := SliceMapping(words, func(s string) string </span><span class="cov6" title="1690">{ return strings.ToUpper(s) }</span>)
        <span class="cov6" title="845">titleWords := SliceMapping(words, func(s string) string </span><span class="cov6" title="1690">{ return strings.Title(s) }</span>)

        <span class="cov6" title="845">s := NewSet(keyword)
        s.Insert(
                compact,
                strings.ToUpper(compact),
                strings.ToLower(compact),
                strcase.ToCamel(keyword),
                strcase.ToLowerCamel(keyword),
                strcase.ToKebab(keyword),
                strcase.ToSnake(keyword),
                strcase.ToScreamingSnake(keyword),
                strcase.ToScreamingKebab(keyword),
        )
        for _, delimited := range keywordFuzzyDelimited </span><span class="cov7" title="3379">{
                s.Insert(
                        strings.Join(lowerWords, delimited),
                        strings.Join(upperWords, delimited),
                        strings.Join(titleWords, delimited),
                )
        }</span>

        <span class="cov6" title="845">return s.Items()</span>
}

func init() <span class="cov3" title="14">{
        strcase.ConfigureAcronym("I18n", "i18n")
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package utils

import (
        "reflect"
)

type parseTagOption struct {
        tag           string
        overwrite     bool
        unmarshalType unmarshalType
}

func ParseTagName(tag string) OptionFunc[parseTagOption] <span class="cov5" title="209">{
        return func(o *parseTagOption) </span><span class="cov5" title="209">{
                o.tag = tag
        }</span>
}

func ParseTagOverwrite(overwrite bool) OptionFunc[parseTagOption] <span class="cov0" title="0">{
        return func(o *parseTagOption) </span><span class="cov0" title="0">{
                o.overwrite = overwrite
        }</span>
}

func ParseTagUnmarshalType(unmarshalTag unmarshalType) OptionFunc[parseTagOption] <span class="cov5" title="209">{
        return func(o *parseTagOption) </span><span class="cov5" title="209">{
                o.unmarshalType = unmarshalTag
        }</span>
}

func ParseTag(data any, opts ...OptionExtender) (err error) <span class="cov5" title="209">{
        opt := ApplyOptions[parseTagOption](opts...)
        stepInKinds := NewSet(reflect.Struct, reflect.Array, reflect.Slice, reflect.Map)
        TraverseValue(data, false, func(field reflect.StructField, value reflect.Value) (end, stepIn bool) </span><span class="cov10" title="25631">{
                if !value.IsValid() || !value.CanSet() || !value.CanAddr() || !value.CanInterface() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov10" title="25631">vk := value.Kind()
                stepIn = stepInKinds.Contains(vk) ||
                        (vk == reflect.Ptr &amp;&amp; value.Elem().IsValid() &amp;&amp; value.Elem().Kind() == reflect.Struct)

                defaultString := field.Tag.Get(opt.tag)
                if IsStrBlank(defaultString) || (!opt.overwrite &amp;&amp; !IsBlank(value)) </span><span class="cov9" title="23121">{
                        return
                }</span>

                <span class="cov7" title="2510">defaultValue := reflect.New(value.Type()).Interface()
                if err = Unmarshal(defaultString, defaultValue, opt.unmarshalType); err != nil </span><span class="cov0" title="0">{
                        end = true
                        return
                }</span>
                <span class="cov7" title="2510">value.Set(reflect.ValueOf(defaultValue).Elem())
                return</span>
        })

        <span class="cov5" title="209">return</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package utils

import (
        "context"
        "errors"
        "math/rand"
        "sync"
        "time"

        "go.uber.org/multierr"
)

// UnixNano returns t as a Unix time, the number of nanoseconds elapsed
// since January 1, 1970 UTC. The result is undefined if the Unix time
// in nanoseconds cannot be represented by an int64 (a date before the year
// 1678 or after 2262). Note that this means the result of calling UnixNano
// on the zero Time is undefined. The result does not depend on the
// location associated with t.
const (
        minYear = 1678
        maxYear = 2262
)

// GetTime 
func GetTime(timestampMs int64) time.Time <span class="cov0" title="0">{
        return time.UnixMilli(timestampMs)
}</span>

// GetTimeStamp 
func GetTimeStamp(t time.Time) int64 <span class="cov10" title="343">{
        if year := t.Year(); year &gt;= maxYear || year &lt; minYear </span><span class="cov0" title="0">{
                return t.Unix() * 1e3
        }</span>
        <span class="cov10" title="343">return t.UnixNano() / 1e6</span>
}

// IsValidTimestamp  false  time.Time 
func IsValidTimestamp(timeMS int64) bool <span class="cov0" title="0">{
        year := GetTime(timeMS).Year()
        return year &gt;= minYear &amp;&amp; year &lt; maxYear
}</span>

type loopWithIntervalOption struct {
        maxTimes uint
        // jitter time
        base, max  time.Duration
        ratio, exp float64
        symmetric  bool
}

// LoopJitterInterval Deprecated, try github.com/rican7/retry.Retry instead
func LoopJitterInterval(base, max time.Duration, ratio, exp float64,
        symmetric bool) OptionFunc[loopWithIntervalOption] <span class="cov0" title="0">{
        return func(o *loopWithIntervalOption) </span><span class="cov0" title="0">{
                o.base = base
                o.max = max
                o.ratio = ratio
                o.exp = exp
                o.symmetric = symmetric
        }</span>
}

// LoopMaxTimes Deprecated, try github.com/rican7/retry.Retry instead
func LoopMaxTimes(maxTimes uint) OptionFunc[loopWithIntervalOption] <span class="cov0" title="0">{
        return func(o *loopWithIntervalOption) </span><span class="cov0" title="0">{
                o.maxTimes = maxTimes
        }</span>
}

// LoopWithInterval Deprecated, try github.com/rican7/retry.Retry instead
func LoopWithInterval(ctx context.Context, interval time.Duration,
        fn func() bool, opts ...OptionExtender) (err error) <span class="cov0" title="0">{
        var (
                maxTimes     uint
                nextInterval func() time.Duration
        )

        opt := ApplyOptions[loopWithIntervalOption](opts...)
        enableJitter := opt.base &gt; 0
        enableMaxTimes := opt.maxTimes &gt; 0
        if enableJitter </span><span class="cov0" title="0">{
                nextInterval = NextJitterIntervalFunc(opt.base, opt.max, opt.ratio, opt.exp, opt.symmetric)
                interval = nextInterval()
        }</span>
        <span class="cov0" title="0">if enableMaxTimes </span><span class="cov0" title="0">{
                maxTimes = opt.maxTimes
        }</span>

        <span class="cov0" title="0">timer := time.NewTimer(interval)
        defer timer.Stop()
        for </span><span class="cov0" title="0">{
                if fn() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if enableMaxTimes </span><span class="cov0" title="0">{
                        if maxTimes--; maxTimes == 0 </span><span class="cov0" title="0">{
                                return multierr.Append(err, errors.New("exceed the maximum times"))
                        }</span>
                }

                // time.Sleep
                <span class="cov0" title="0">timer.Reset(interval)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-timer.C:<span class="cov0" title="0">
                        if enableJitter </span><span class="cov0" title="0">{
                                interval = nextInterval()
                        }</span>
                }
        }
}

// NextJitterIntervalFunc generate a jitter and exponential power duration, inspired by net/http.(*Server).Shutdown
func NextJitterIntervalFunc(base, max time.Duration, ratio, exp float64, symmetric bool) func() time.Duration <span class="cov2" title="2">{
        return func() (interval time.Duration) </span><span class="cov5" title="20">{
                // add specified ratio jitter
                if !symmetric </span><span class="cov4" title="10">{
                        // if ratio is 0.5
                        // then interval = base + random(0.5*base) &lt;=&gt; [base, 1.5*base)
                        // if ratio is 0.1
                        // then interval = base + random(0.1*base) &lt;=&gt; [base, 1.1*base)
                        _range := float64(base) * ratio * rand.Float64()
                        interval = base + time.Duration(_range)
                }</span> else<span class="cov4" title="10"> {
                        // if ratio is 0.5
                        // then interval = base + random(0.5*base) - 0.25*base &lt;=&gt; [0.75*base, 1.25*base)
                        // if ratio is 0.1
                        // then interval = base + random(0.1*base) - 0.05*base &lt;=&gt; [0.95*base, 1.05*base)
                        _range := float64(base) * ratio * rand.Float64()
                        interval = base + time.Duration(_range) - time.Duration(float64(base)*(ratio/2))
                }</span>

                // double and clamp for next time
                <span class="cov5" title="20">base = time.Duration(float64(base) * exp)
                if base &gt; max </span><span class="cov4" title="12">{
                        base = max
                }</span>
                <span class="cov5" title="20">return interval</span>
        }
}

// WaitGroupTimeout adds timeout feature for sync.WaitGroup.Wait().
// It returns true, when timeout.
type timeoutOption struct {
        wg *sync.WaitGroup
}

func TimeoutWg(wg *sync.WaitGroup) OptionFunc[timeoutOption] <span class="cov7" title="90">{
        return func(o *timeoutOption) </span><span class="cov7" title="90">{
                o.wg = wg
        }</span>
}

func Timeout(timeout time.Duration, opts ...OptionExtender) bool <span class="cov7" title="90">{
        opt := ApplyOptions[timeoutOption](opts...)
        wgClosed := make(chan struct{}, 1)
        go func() </span><span class="cov7" title="90">{
                switch </span>{
                case opt.wg != nil:<span class="cov7" title="90">
                        opt.wg.Wait()</span>
                }
                <span class="cov7" title="90">wgClosed &lt;- struct{}{}</span>
        }()

        <span class="cov7" title="90">timer := time.NewTimer(timeout)
        defer timer.Stop()
        select </span>{
        case &lt;-wgClosed:<span class="cov7" title="90">
                return false</span>
        case &lt;-timer.C:<span class="cov0" title="0">
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package config

import (
        "encoding/base64"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/cipher"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/encode"
)

func (p *registry) Debug() (debug bool) <span class="cov6" title="165">{
        if p.appName != "" </span><span class="cov6" title="143">{
                return p.debug
        }</span>
        <span class="cov4" title="22">_ = p.LoadComponentConfig(ComponentDebug, &amp;debug)
        return</span>
}

func (p *registry) AppName() (name string) <span class="cov10" title="7207">{
        if p.appName != "" </span><span class="cov9" title="7094">{
                return p.appName
        }</span>
        <span class="cov5" title="111">_ = p.LoadComponentConfig(ComponentApp, &amp;name)
        return</span>
}

func (p *registry) DI() di.DI <span class="cov1" title="1">{ return p.di }</span>

func (p *registry) cryptoConfig() (conf *CryptoConf) <span class="cov5" title="68">{
        conf = new(CryptoConf)
        if err := p.LoadComponentConfig(ComponentCrypto, &amp;conf); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="68">parseCfgFunc := func(c *cryptoConf) </span><span class="cov5" title="68">{
                if c == nil </span><span class="cov4" title="50">{
                        return
                }</span>
                <span class="cov3" title="18">c.Algorithm = cipher.ParseAlgorithm(c.AlgorithmString)
                c.Mode = cipher.ParseMode(c.ModeString)
                c.Key = utils.Must(base64.StdEncoding.DecodeString(c.KeyBase64))
                c.IV = utils.Must(base64.StdEncoding.DecodeString(c.IVBase64))

                if utils.IsStrPtrNotBlank(c.CompressAlgorithmString) </span><span class="cov0" title="0">{
                        c.CompressAlgorithm = compress.ParseAlgorithm(*c.CompressAlgorithmString)
                }</span>
                <span class="cov3" title="18">if utils.IsStrPtrNotBlank(c.OutputAlgorithmString) </span><span class="cov3" title="18">{
                        c.OutputAlgorithm = encode.ParseAlgorithm(*c.OutputAlgorithmString)
                }</span>
        }

        <span class="cov5" title="68">if conf != nil </span><span class="cov5" title="68">{
                parseCfgFunc(conf.Config)
                conf.Custom = make(map[string]*cryptoConf)
                for _, c := range conf.Custom </span><span class="cov0" title="0">{
                        parseCfgFunc(c)
                }</span>
        }

        <span class="cov5" title="68">return</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package config

import (
        "context"
        "fmt"
        "reflect"
        "sync"

        "github.com/pkg/errors"
        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
)

// common component names
const (
        ComponentApp           = "App"
        ComponentDebug         = "Debug"
        ComponentCrypto        = "Crypto"
        ComponentMetrics       = "Metrics"
        ComponentLog           = "Log"
        ComponentDB            = "DB"
        ComponentRedis         = "Redis"
        ComponentMongo         = "Mongo"
        ComponentI18n          = "I18n"
        ComponentLock          = "Lock"
        ComponentMessageQueue  = "MQ"
        ComponentHttp          = "Http"
        ComponentCache         = "Cache"
        ComponentCron          = "Cron"
        ComponentAsync         = "Async"
        ComponentGoroutinePool = "GoroutinePool"
)

const (
        DefaultInstanceKey = "default"
)

var (
        // componentOrder common component setup order
        componentOrder = []string{
                ComponentApp,
                ComponentDebug,
                ComponentCrypto,
                ComponentLog,
                ComponentMetrics,
                ComponentRedis,
                ComponentCache,
                ComponentDB,
                ComponentMongo,
                ComponentI18n,
                ComponentLock,
                ComponentMessageQueue,
                ComponentAsync,
                ComponentGoroutinePool,
                ComponentCron,
                ComponentHttp,
        }

        componentLocker sync.RWMutex
        components      []*componentItem
)

func indexComponent(name string) (idx int) <span class="cov8" title="7054">{
        for idx = 0; idx &lt; len(componentOrder); idx++ </span><span class="cov10" title="51770">{
                if componentOrder[idx] == name </span><span class="cov8" title="7054">{
                        return
                }</span>
        }
        <span class="cov0" title="0">idx = -1
        return</span>
}

type Component struct {
        Name                 string
        Tag                  string
        Constructor          reflect.Value
        ConstructorInputType reflect.Type
        isCore               bool
}

func (c *Component) Clone() (r *Component) <span class="cov0" title="0">{
        return &amp;Component{
                Name:                 c.Name,
                Tag:                  c.Tag,
                Constructor:          c.Constructor,
                ConstructorInputType: c.ConstructorInputType,
                isCore:               c.isCore,
        }
}</span>

type options struct {
        TagList         []string
        IsCoreComponent bool
}

type ComponentOption func(*options)

func newOptions() *options <span class="cov5" title="400">{
        return &amp;options{}
}</span>

// WithTag set component struct tags
func WithTag(name, val string) ComponentOption <span class="cov5" title="225">{
        return func(opt *options) </span><span class="cov5" title="225">{
                opt.TagList = append(opt.TagList, fmt.Sprintf(`%s:"%s"`, name, val))
        }</span>
}

// WithCore mark component as core component, they must be init first
func WithCore() ComponentOption <span class="cov0" title="0">{
        return func(opt *options) </span><span class="cov0" title="0">{
                opt.IsCoreComponent = true
        }</span>
}

type componentItem struct {
        name        string
        constructor any
        opt         []ComponentOption
}

func AddComponent(name string, constructor any, opts ...ComponentOption) <span class="cov5" title="182">{
        componentLocker.Lock()
        defer componentLocker.Unlock()
        parseConstructor(constructor)
        components = append(components, &amp;componentItem{name, constructor, opts})
}</span>

func getComponents() []*componentItem <span class="cov3" title="25">{
        componentLocker.RLock()
        defer componentLocker.RUnlock()
        return clone.Clone(components)
}</span>

func parseConstructor(fn any) (fnVal reflect.Value, input reflect.Type) <span class="cov6" title="582">{
        fnVal = reflect.ValueOf(fn)
        typ := reflect.TypeOf(fn)
        if typ.Kind() != reflect.Func </span><span class="cov0" title="0">{
                panic(errors.New("component constructor should be a function"))</span>
        }

        // check output
        <span class="cov6" title="582">if typ.NumOut() != 1 </span><span class="cov0" title="0">{
                panic(errors.New("component constructor should return one finalizer function"))</span>
        }
        <span class="cov6" title="582">retTyp := typ.Out(0)
        if retTyp.Kind() != reflect.Func </span><span class="cov0" title="0">{
                panic(errors.New("component constructor should return one finalizer function"))</span>
        }
        <span class="cov6" title="582">if retTyp.NumIn() != 0 </span><span class="cov0" title="0">{
                panic(errors.New("component constructor should return one finalizer function looks like func()"))</span>
        }

        // check input
        <span class="cov6" title="582">fnType := fnVal.Type()
        if n := fnType.NumIn(); n != 1 &amp;&amp; (!fnType.IsVariadic() &amp;&amp; n != 3) </span><span class="cov0" title="0">{
                panic(errors.New("component constructor should receive input looks like " +
                        "func(context.Context), func(context.Context, *serializableConf, ...utils.OptionExtender)"))</span>
        }
        <span class="cov6" title="582">if fnType.In(0) != constant.ContextType </span><span class="cov0" title="0">{
                panic(errors.New("component constructor should receive context.Context as first input " +
                        "looks like func(context.Context), func(context.Context, *serializableConf, ...utils.OptionExtender)"))</span>
        }

        // wrapper
        <span class="cov6" title="582">switch typ.NumIn() </span>{
        case 1:<span class="cov0" title="0">
                input = reflect.TypeOf(int(0))
                fnVal = reflect.ValueOf(func(ctx context.Context, mock int, _ ...utils.OptionExtender) func() </span><span class="cov0" title="0">{
                        out := reflect.ValueOf(fn).Call([]reflect.Value{reflect.ValueOf(ctx)})
                        if retfn := out[0]; retfn.IsNil() </span><span class="cov0" title="0">{
                                return nil
                        }</span> else<span class="cov0" title="0"> if obj := retfn.Interface(); obj == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span> else<span class="cov0" title="0"> if fn, ok := obj.(func()); !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span> else<span class="cov0" title="0"> {
                                return fn
                        }</span>
                })
        case 3:<span class="cov6" title="582">
                input = typ.In(1)
                argsType := typ.In(2)
                if argsType.Kind() != reflect.Slice ||
                        argsType.Elem() != reflect.TypeOf((*utils.OptionExtender)(nil)).Elem() </span><span class="cov0" title="0">{
                        panic(errors.New("component constructor only receive utils.OptionExtender variadic input"))</span>
                }
        default:<span class="cov0" title="0">
                panic(errors.New("component constructor should receive one or three inputs looks like " +
                        "func(context.Context), func(context.Context, *serializableConf, ...utils.OptionExtender)"))</span>
        }
        <span class="cov6" title="582">return</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package config

import (
        "context"
        "encoding/base64"
        "hash/crc64"
        "math/rand"
        "reflect"

        "github.com/pkg/errors"
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/cipher"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/encode"
)

const (
        cryptoTagKey = "encrypted"
)

type CryptoConf struct {
        Config *cryptoConf            `yaml:"config" json:"config" toml:"config"`
        Custom map[string]*cryptoConf `yaml:"custom" json:"custom" toml:"custom"`
}

func (c *CryptoConf) ToOptionMap() (result map[string][]utils.OptionExtender) <span class="cov5" title="68">{
        result = make(map[string][]utils.OptionExtender)
        if c.Config != nil </span><span class="cov3" title="18">{
                result[""] = c.Config.ToOptions()
        }</span>
        <span class="cov5" title="68">for name, cfg := range c.Custom </span><span class="cov0" title="0">{
                result[name] = cfg.ToOptions()
        }</span>
        <span class="cov5" title="68">return</span>
}

// cryptoConf
//nolint: revive // struct tag too long issue
type cryptoConf struct {
        Key        []byte `yaml:"-" json:"-" toml:"-"`
        KeyBase64  string `yaml:"key_base64" json:"key_base64" toml:"key_base64"`
        ConfuseKey bool   `yaml:"confuse_key" json:"confuse_key" toml:"confuse_key"`

        IV       []byte `yaml:"-" json:"-" toml:"-"`
        IVBase64 string `yaml:"iv_base64" json:"iv_base64" toml:"iv_base64"`

        Algorithm       cipher.Algorithm `yaml:"-" json:"-" toml:"-"`
        AlgorithmString string           `yaml:"algorithm" json:"algorithm" toml:"algorithm"`

        Mode       cipher.Mode `yaml:"-" json:"-" toml:"-"`
        ModeString string      `yaml:"mode" json:"mode" toml:"mode"`

        CompressAlgorithm       compress.Algorithm `yaml:"-" json:"-" toml:"-"`
        CompressAlgorithmString *string            `yaml:"compress_algorithm" json:"compress_algorithm" toml:"compress_algorithm"`

        OutputAlgorithm       encode.Algorithm `yaml:"-" json:"-" toml:"-"`
        OutputAlgorithmString *string          `yaml:"output_algorithm" json:"output_algorithm" toml:"output_algorithm"`
}

func (c *cryptoConf) ToOptions() (opts []utils.OptionExtender) <span class="cov3" title="18">{
        if !c.Algorithm.IsValid() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="18">if c.ConfuseKey </span><span class="cov3" title="18">{
                c.Key = c.cryptoConfuseKey(c.Key)
        }</span>

        <span class="cov3" title="18">opts = make([]utils.OptionExtender, 0, 3)
        opts = append(opts, encode.Cipher(c.Algorithm, c.Mode, c.Key, c.IV))
        if c.CompressAlgorithm.IsValid() </span><span class="cov0" title="0">{
                opts = append(opts, encode.Compress(c.CompressAlgorithm))
        }</span>
        <span class="cov3" title="18">if c.OutputAlgorithm.IsValid() </span><span class="cov3" title="18">{
                opts = append(opts, encode.Encode(c.OutputAlgorithm))
        }</span>
        <span class="cov3" title="18">return</span>
}

func (c *cryptoConf) cryptoConfuseKey(key []byte) (confused []byte) <span class="cov3" title="18">{
        var (
                k1 = make([]byte, len(key))
                k2 = make([]byte, len(key))
                k3 = make([]byte, len(key))
        )
        rndSeed := int64(crc64.Checksum(key, crc64.MakeTable(crc64.ISO)))
        utils.Must(rand.New(rand.NewSource(cipher.RndSeed ^ compress.RndSeed ^ rndSeed)).Read(k1))
        utils.Must(rand.New(rand.NewSource(cipher.RndSeed ^ encode.RndSeed ^ rndSeed)).Read(k2))
        utils.Must(rand.New(rand.NewSource(compress.RndSeed ^ encode.RndSeed ^ rndSeed)).Read(k3))

        confused = make([]byte, len(key))
        utils.Must(rand.New(rand.NewSource(cipher.RndSeed ^ compress.RndSeed ^ encode.RndSeed)).Read(confused))
        for i := 0; i &lt; len(confused); i++ </span><span class="cov6" title="288">{
                confused[i] ^= k1[i] ^ k2[i] ^ k3[i]
        }</span>
        <span class="cov3" title="18">return</span>
}

func CryptoConstruct(ctx context.Context, c CryptoConf, _ ...utils.OptionExtender) func() <span class="cov4" title="34">{
        if c.Config != nil </span><span class="cov3" title="9">{
                checkCryptoConf("", c.Config)
        }</span>
        <span class="cov4" title="34">for name, cfg := range c.Custom </span><span class="cov3" title="8">{
                if cfg != nil </span><span class="cov3" title="8">{
                        checkCryptoConf(name, cfg)
                }</span>
        }

        <span class="cov4" title="34">return func() </span>{<span class="cov4" title="34">

        }</span>
}

func checkCryptoConf(name string, c *cryptoConf) <span class="cov3" title="17">{
        // cipher
        if c.Algorithm = cipher.ParseAlgorithm(c.AlgorithmString); !c.Algorithm.IsValid() </span><span class="cov0" title="0">{
                panic(errors.Errorf("unknown config %s algorithm: %s", name, c.AlgorithmString))</span>
        }
        <span class="cov3" title="17">c.Mode = cipher.ParseMode(c.ModeString)
        if !c.Mode.IsValid() </span><span class="cov0" title="0">{
                panic(errors.Errorf("unknown config %s mode: %s", name, c.ModeString))</span>
        }
        <span class="cov3" title="17">if utils.IsStrBlank(c.KeyBase64) </span><span class="cov0" title="0">{
                panic(errors.Errorf("%s not found crypto key", name))</span>
        }
        <span class="cov3" title="17">c.Key = utils.Must(base64.StdEncoding.DecodeString(c.KeyBase64))
        if c.Mode.NeedIV() &amp;&amp; utils.IsStrBlank(c.IVBase64) </span><span class="cov0" title="0">{
                panic(errors.Errorf("%s not found crypto iv", name))</span>
        }
        <span class="cov3" title="17">c.IV = utils.Must(base64.StdEncoding.DecodeString(c.IVBase64))

        // compress
        if utils.IsStrPtrNotBlank(c.CompressAlgorithmString) </span><span class="cov0" title="0">{
                c.CompressAlgorithm = compress.ParseAlgorithm(*c.CompressAlgorithmString)
                if !c.CompressAlgorithm.IsValid() </span><span class="cov0" title="0">{
                        panic(errors.Errorf("unknown config %s compress algorithm: %s", name, *c.CompressAlgorithmString))</span>
                }
        }

        // output
        <span class="cov3" title="17">if utils.IsStrPtrNotBlank(c.OutputAlgorithmString) </span><span class="cov3" title="17">{
                c.OutputAlgorithm = encode.ParseAlgorithm(*c.OutputAlgorithmString)
                if !c.OutputAlgorithm.IsValid() </span><span class="cov0" title="0">{
                        panic(errors.Errorf("unknown config %s output algorithm: %s", name, *c.OutputAlgorithmString))</span>
                }
        }
}

type cryptoConfigOption struct {
        name string
}

func CryptoConfigName(name string) utils.OptionFunc[cryptoConfigOption] <span class="cov0" title="0">{
        return func(o *cryptoConfigOption) </span><span class="cov0" title="0">{
                o.name = name
        }</span>
}

func CryptoEncryptFunc(opts ...utils.OptionExtender) func(src string) (dst string) <span class="cov0" title="0">{
        o := utils.ApplyOptions[InitOption](opts...)
        opt := utils.ApplyOptions[cryptoConfigOption](opts...)
        optsMap := Use(o.AppName).(*registry).cryptoConfig().ToOptionMap()
        opts = optsMap[opt.name]
        return func(src string) (dst string) </span><span class="cov0" title="0">{
                return utils.Must(encode.From(src).Encode(opts...).ToString())
        }</span>
}

func CryptoDecryptFunc(opts ...utils.OptionExtender) func(src string) (dst string) <span class="cov0" title="0">{
        o := utils.ApplyOptions[InitOption](opts...)
        opt := utils.ApplyOptions[cryptoConfigOption](opts...)
        optsMap := Use(o.AppName).(*registry).cryptoConfig().ToOptionMap()
        for _, opts := range optsMap </span><span class="cov0" title="0">{
                utils.SliceReverse(opts)
        }</span>
        <span class="cov0" title="0">opts = optsMap[opt.name]
        return func(src string) (dst string) </span><span class="cov0" title="0">{
                return utils.Must(encode.From(src).Decode(opts...).ToString())
        }</span>
}

func CryptoDecryptByTag(data any, opts ...utils.OptionExtender) <span class="cov5" title="68">{
        o := utils.ApplyOptions[InitOption](opts...)
        optsMap := Use(o.AppName).(*registry).cryptoConfig().ToOptionMap()
        for _, opts := range optsMap </span><span class="cov3" title="18">{
                utils.SliceReverse(opts)
        }</span>

        <span class="cov5" title="68">supportedFields := utils.NewSet(reflect.Struct, reflect.Array, reflect.Slice, reflect.Map)
        utils.TraverseValue(data, false, func(field reflect.StructField, value reflect.Value) (end, stepIn bool) </span><span class="cov10" title="8707">{
                if !value.IsValid() || !value.CanInterface() || !value.CanSet() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov10" title="8707">vk := value.Kind()
                stepIn = supportedFields.Contains(vk) ||
                        (vk == reflect.Ptr &amp;&amp; value.Elem().IsValid() &amp;&amp; value.Elem().Kind() == reflect.Struct)

                configName, ok := field.Tag.Lookup(cryptoTagKey)
                if !ok </span><span class="cov9" title="8569">{
                        return
                }</span>
                <span class="cov5" title="138">opts, ok := optsMap[configName]
                if !ok </span><span class="cov5" title="94">{
                        return
                }</span>
                <span class="cov4" title="44">src := cast.ToString(value.Interface())
                if utils.IsStrBlank(src) </span><span class="cov1" title="1">{
                        return
                }</span>

                <span class="cov4" title="43">dst := utils.Must(encode.From(src).Decode(opts...).ToString())
                value.SetString(dst)
                return</span>
        })
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package config

import (
        "flag"
        "log"
        "os"
        "path/filepath"
        "syscall"

        "github.com/pkg/errors"
        "gopkg.in/yaml.v3"

        "github.com/wfusion/gofusion/common/env"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/internal/configor"
)

type loader struct {
        files []string
}

// NewDefaultLoader front files overwrite the backs
func NewDefaultLoader(files ...string) *loader <span class="cov8" title="66">{
        return &amp;loader{
                files: files,
        }
}</span>

// Unmarshal support required and default tag setting
// be carefully we can only assign default value when value is a pointer in map or slice
func (l *loader) Unmarshal(out any) (err error) <span class="cov8" title="66">{
        return configor.New(&amp;configor.Config{
                Environment:        env.GetEnv(),
                ENVPrefix:          "",
                Debug:              false,
                Verbose:            false,
                Silent:             true,
                AutoReload:         true,
                AutoReloadInterval: 0,
                AutoReloadCallback: func(config any) </span><span class="cov6" title="20">{
                        log.Printf("%v [Gofusion] Config auto reload config successfully =&gt; \n%s",
                                syscall.Getpid(), utils.Must(yaml.Marshal(config)))
                }</span>,
                ErrorOnUnmatchedKeys: false,
                FS:                   nil,
        }).Load(out, l.files...)
}

var profile string

type loadConfigFunc func(out any, opts ...utils.OptionExtender)

var customConfigPath string

func init() <span class="cov6" title="14">{
        flag.StringVar(&amp;customConfigPath, "configPath", "", "config file path")
}</span>

func loadConfig(out any, opts ...utils.OptionExtender) <span class="cov8" title="66">{
        if !flag.Parsed() </span><span class="cov0" title="0">{
                flag.Parse()
        }</span>

        <span class="cov8" title="66">opt := utils.ApplyOptions[initOption](opts...)

        files := make([]string, 0, 2)
        switch </span>{
        case utils.IsStrNotBlank(customConfigPath):<span class="cov0" title="0">
                files = append(files, filepath.Clean(customConfigPath))</span>
        case len(opt.filenames) &gt; 0:<span class="cov8" title="58">
                files = append(files, opt.filenames...)</span>
        default:<span class="cov4" title="8">
                defaultPathPrefix := filepath.Join(env.WorkDir, "configs", "app.")
                defaultLocal1PathPrefix := filepath.Join(env.WorkDir, "configs", "app.local.")
                defaultLocal2PathPrefix := filepath.Join(env.WorkDir, "configs", "app_local.")
                defaultLocal3PathPrefix := filepath.Join(env.WorkDir, "configs", "app-local.")
                extensions := []string{"yaml", "yml", "json", "toml"}
                for _, ext := range extensions </span><span class="cov7" title="32">{
                        localFilename := defaultLocal1PathPrefix + ext
                        if _, err := os.Stat(localFilename); err == nil </span><span class="cov4" title="6">{
                                files = append(files, localFilename)
                                continue</span>
                        }
                        <span class="cov7" title="26">localFilename = defaultLocal2PathPrefix + ext
                        if _, err := os.Stat(localFilename); err == nil </span><span class="cov0" title="0">{
                                files = append(files, localFilename)
                                continue</span>
                        }
                        <span class="cov7" title="26">localFilename = defaultLocal3PathPrefix + ext
                        if _, err := os.Stat(localFilename); err == nil </span><span class="cov0" title="0">{
                                files = append(files, localFilename)
                                continue</span>
                        }
                }
                <span class="cov4" title="8">for _, ext := range extensions </span><span class="cov7" title="32">{
                        defaultFilename := defaultPathPrefix + ext
                        if _, err := os.Stat(defaultFilename); err == nil </span><span class="cov6" title="18">{
                                files = append(files, defaultFilename)
                        }</span>
                }
        }

        // check if configure file exists first, to avoid auto reload a nonexistent file
        <span class="cov8" title="66">existFiles := make([]string, 0, len(files))
        for _, name := range files </span><span class="cov10" title="114">{
                if _, err := os.Stat(name); err == nil </span><span class="cov10" title="114">{
                        existFiles = append(existFiles, name)
                }</span>
        }

        <span class="cov8" title="66">if profile != "" </span><span class="cov0" title="0">{
                if err := configor.New(&amp;configor.Config{Environment: profile}).Load(out, existFiles...); err != nil </span><span class="cov0" title="0">{
                        panic(errors.Errorf("parse config file of config env %s error: %v", profile, err))</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="66">if err := NewDefaultLoader(files...).Unmarshal(out); err != nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("parse config file error! %s", err))</span>
        }
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package config

import (
        "context"
        "fmt"
        "log"
        "reflect"
        "sort"
        "strings"
        "sync"
        "syscall"

        "github.com/iancoleman/strcase"
        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
)

var (
        Registry = &amp;registry{di: di.Dig, initOnce: new(sync.Once), closeCh: make(chan struct{})}

        initLocker   sync.RWMutex
        registryLock sync.RWMutex
        registryMap  = map[string]Configurable{"": Registry}
)

const (
        componentConfigFieldName = "Base"
)

func Use(appName string, opts ...utils.OptionExtender) Configurable <span class="cov8" title="32630">{
        registryLock.RLock()
        defer registryLock.RUnlock()
        cfg, ok := registryMap[appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("app register config not found: %s", appName))</span>
        }
        <span class="cov8" title="32777">return cfg</span>
}

func New(appName string) Configurable <span class="cov6" title="1129">{
        registryLock.Lock()
        defer registryLock.Unlock()
        if reg, ok := registryMap[appName]; ok </span><span class="cov6" title="1105">{
                return reg
        }</span>

        <span class="cov3" title="24">reg := &amp;registry{
                di:       di.NewDI(),
                appName:  appName,
                initOnce: new(sync.Once),
                closeCh:  make(chan struct{}),
        }
        registryMap[appName] = reg
        return reg</span>
}

type registry struct {
        di                 di.DI
        appName            string
        debug              bool
        loadComponentsOnce sync.Once
        initOnce           *sync.Once
        initWg             sync.WaitGroup
        closeCh            chan struct{}

        componentList      []*Component
        businessConfig     any
        businessConfigType reflect.Type
        componentConfigs   any
}

type initOption struct {
        debug          bool
        bizCtx         context.Context
        customLoadFunc loadConfigFunc
        filenames      []string
}

func Ctx(ctx context.Context) utils.OptionFunc[initOption] <span class="cov1" title="1">{
        return func(o *initOption) </span><span class="cov1" title="3">{
                o.bizCtx = ctx
        }</span>
}

func Loader(fn func(any, ...utils.OptionExtender)) utils.OptionFunc[initOption] <span class="cov1" title="1">{
        return func(o *initOption) </span><span class="cov1" title="1">{
                o.customLoadFunc = fn
        }</span>
}

func Files(filenames []string) utils.OptionFunc[initOption] <span class="cov6" title="1131">{
        return func(o *initOption) </span><span class="cov4" title="91">{
                o.filenames = filenames
        }</span>
}

func Debug() utils.OptionFunc[initOption] <span class="cov0" title="0">{
        return func(o *initOption) </span><span class="cov0" title="0">{
                o.debug = true
        }</span>
}

func (p *registry) Init(businessConfig any, opts ...utils.OptionExtender) (gracefully func()) <span class="cov6" title="2126">{
        initLocker.Lock()
        defer initLocker.Unlock()

        p.initWg.Add(1)
        p.initOnce.Do(func() </span><span class="cov3" title="34">{
                opt := utils.ApplyOptions[initOption](opts...)
                p.debug = opt.debug
                p.closeCh = make(chan struct{})

                // context
                parent := context.Background()
                if opt.bizCtx != nil </span><span class="cov1" title="1">{
                        parent = opt.bizCtx
                }</span>

                // load config function
                <span class="cov3" title="34">loadFn := loadConfig
                if opt.customLoadFunc != nil </span><span class="cov1" title="1">{
                        loadFn = opt.customLoadFunc
                }</span>

                <span class="cov3" title="34">gracefully = p.initByConfigFile(parent, businessConfig, loadFn, opts...)</span>
        })
        <span class="cov6" title="2132">if gracefully == nil </span><span class="cov6" title="2098">{
                // give back
                reflect.Indirect(reflect.ValueOf(businessConfig)).Set(reflect.ValueOf(p.businessConfig))

                once := new(sync.Once)
                gracefully = func() </span><span class="cov6" title="2055">{
                        once.Do(func() </span><span class="cov6" title="2094">{
                                p.initWg.Done()
                        }</span>)
                }
        }
        <span class="cov6" title="2132">return</span>
}

func (p *registry) AddComponent(name string, constructor any, opts ...ComponentOption) <span class="cov5" title="400">{
        if name[0] &lt; 'A' || name[0] &gt; 'Z' </span><span class="cov0" title="0">{
                panic("component name should start with A-Z")</span>
        }
        <span class="cov5" title="400">for idx, com := range p.componentList </span><span class="cov6" title="3000">{
                if com.Name == name </span><span class="cov0" title="0">{
                        p.componentList = append(p.componentList[:idx], p.componentList[idx+1:]...)
                }</span>
        }
        <span class="cov5" title="400">opt := newOptions()
        for _, fn := range opts </span><span class="cov5" title="225">{
                fn(opt)
        }</span>

        <span class="cov5" title="400">com := &amp;Component{
                Name:   name,
                isCore: opt.IsCoreComponent,
        }

        hasYamlTag := false
        hasJsonTag := false
        hasTomlTag := false
        for _, tag := range opt.TagList </span><span class="cov5" title="225">{
                hasYamlTag = strings.HasPrefix(tag, "`yaml:")
                hasJsonTag = strings.HasPrefix(tag, "`json:")
                hasTomlTag = strings.HasPrefix(tag, "`toml:")
        }</span>
        <span class="cov5" title="400">lowerName := strcase.ToSnake(name)
        if name == ComponentI18n </span><span class="cov3" title="25">{
                lowerName = strings.ToLower(name)
        }</span>
        <span class="cov5" title="400">if !hasYamlTag </span><span class="cov5" title="400">{
                opt.TagList = append(opt.TagList, fmt.Sprintf(`yaml:"%s"`, lowerName))
        }</span>
        <span class="cov5" title="400">if !hasJsonTag </span><span class="cov5" title="400">{
                opt.TagList = append(opt.TagList, fmt.Sprintf(`json:"%s"`, lowerName))
        }</span>
        <span class="cov5" title="400">if !hasTomlTag </span><span class="cov5" title="400">{
                opt.TagList = append(opt.TagList, fmt.Sprintf(`toml:"%s"`, lowerName))
        }</span>
        <span class="cov5" title="400">if len(opt.TagList) &gt; 0 </span><span class="cov5" title="400">{
                com.Tag = strings.Join(opt.TagList, " ")
        }</span>

        <span class="cov5" title="400">com.Constructor, com.ConstructorInputType = parseConstructor(constructor)

        p.addComponent(com)</span>
}

func (p *registry) LoadComponentConfig(name string, componentConfig any) (err error) <span class="cov8" title="25653">{
        val := reflect.ValueOf(componentConfig)
        typ := val.Type()
        if typ.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return errors.New("componentConfig should be pointer")
        }</span>

        <span class="cov8" title="25655">var found bool
        for _, com := range p.componentList </span><span class="cov10" title="190369">{
                if com.Name == name </span><span class="cov8" title="24636">{
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="25602">if !found </span><span class="cov6" title="985">{
                return errors.Errorf("no such component [%s]", name)
        }</span>

        // load config
        <span class="cov8" title="24619">if p.componentConfigs == nil </span><span class="cov3" title="31">{
                return
        }</span>
        <span class="cov8" title="24590">componentConfigsValue := utils.IndirectValue(reflect.ValueOf(clone.Clone(p.componentConfigs)))
        if !componentConfigsValue.IsValid() </span><span class="cov0" title="0">{
                return errors.Errorf("component configs not initialize now [%s]", name)
        }</span>
        <span class="cov8" title="24593">componentConfigValue := componentConfigsValue.FieldByName(componentConfigFieldName).FieldByName(name)

        if componentConfigValue.Type().Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if componentConfigValue.IsNil() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">componentConfigValue = componentConfigValue.Elem()</span>
        }
        <span class="cov8" title="24671">if componentConfigValue.Type() == typ.Elem() || componentConfigValue.Type().ConvertibleTo(typ.Elem()) </span><span class="cov7" title="5862">{
                val.Elem().Set(reflect.ValueOf(clone.Clone(componentConfigValue.Convert(typ.Elem()).Interface())))
                return
        }</span>

        <span class="cov8" title="18814">decoder, err := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig{
                Metadata:         nil,
                Result:           componentConfig,
                TagName:          "yaml",
                WeaklyTypedInput: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="18746">return decoder.Decode(componentConfigValue.Interface())</span>
}

func (p *registry) GetAllConfigs() any <span class="cov2" title="7">{
        val := reflect.New(p.makeAllConfigStruct())
        derefVal := reflect.Indirect(val)

        // business configs
        businessConfigsVal := reflect.Indirect(reflect.ValueOf(p.businessConfig))
        numFields := businessConfigsVal.NumField()
        for i := 0; i &lt; numFields; i++ </span><span class="cov3" title="28">{
                derefVal.Field(i + 1).Set(businessConfigsVal.Field(i))
        }</span>

        // component configs
        <span class="cov2" title="7">derefComponentConfigsVal := derefVal.FieldByName(componentConfigFieldName)
        componentConfigsVal := reflect.Indirect(reflect.ValueOf(p.componentConfigs)).FieldByName(componentConfigFieldName)
        numFields = componentConfigsVal.NumField()
        for i := 0; i &lt; numFields; i++ </span><span class="cov4" title="112">{
                derefComponentConfigsVal.Field(i).Set(componentConfigsVal.Field(i))
        }</span>
        <span class="cov2" title="7">return clone.Clone(val.Interface())</span>
}

func (p *registry) initByConfigFile(parent context.Context, businessConfig any,
        loadFn loadConfigFunc, opts ...utils.OptionExtender) func() <span class="cov3" title="34">{
        p.loadComponents()
        p.checkBusinessConfig(businessConfig)
        p.initAllConfigByLoadFunc(businessConfig, loadFn, opts...)

        appName := p.AppName()
        registryLock.Lock()
        if _, ok := registryMap[appName]; !ok </span><span class="cov1" title="1">{
                registryMap[appName] = p
        }</span>
        <span class="cov3" title="34">registryLock.Unlock()

        // decrypt
        CryptoDecryptByTag(p.businessConfig, AppName(p.AppName()))
        CryptoDecryptByTag(p.componentConfigs, AppName(p.AppName()))

        // give back
        reflect.Indirect(reflect.ValueOf(businessConfig)).Set(reflect.ValueOf(p.businessConfig))

        return p.initComponents(parent)</span>
}

func (p *registry) getBaseObject() reflect.Value <span class="cov3" title="34">{
        return reflect.Indirect(reflect.ValueOf(p.componentConfigs)).FieldByName(componentConfigFieldName)
}</span>

func (p *registry) makeComponentsConfigStruct() reflect.Type <span class="cov3" title="34">{
        fieldList := p.makeComponentsConfigFields()
        return reflect.StructOf([]reflect.StructField{
                {
                        Name:      componentConfigFieldName,
                        Type:      reflect.StructOf(fieldList),
                        Tag:       `yaml:"base" json:"base" toml:"base"`,
                        Anonymous: true,
                },
        })
}</span>

func (p *registry) makeComponentsConfigFields() []reflect.StructField <span class="cov3" title="41">{
        fieldList := make([]reflect.StructField, len(p.componentList))
        for i := 0; i &lt; len(p.componentList); i++ </span><span class="cov5" title="656">{
                component := p.componentList[i]
                fieldList[i] = reflect.StructField{
                        Name: component.Name,
                        Type: component.ConstructorInputType,
                        Tag:  reflect.StructTag(component.Tag),
                }
        }</span>

        <span class="cov3" title="41">return fieldList</span>
}

func (p *registry) makeAllConfigStruct() reflect.Type <span class="cov2" title="7">{
        /* AllConfig struct may look like below
        type AllConfig struct {
                XXXBase struct {
                        Debug       bool
                        App         string
                        DB          map[string]*db.Conf
                        Redis       map[string]*redis.Conf
                        Log         *log.Conf
                        ...
                } `yaml:"base" json:"base" toml:"base"`

                BusinessConfigField1
            BusinessConfigField2
                BusinessConfigField3

                ...
        }
        */

        numFields := p.businessConfigType.NumField()
        fieldList := make([]reflect.StructField, 0, numFields+1)
        fieldList = append(fieldList, reflect.StructField{
                Name:      componentConfigFieldName,
                Type:      reflect.StructOf(p.makeComponentsConfigFields()),
                Tag:       `yaml:"base" json:"base" toml:"base"`,
                Anonymous: true,
        })
        for i := 0; i &lt; numFields; i++ </span><span class="cov3" title="28">{
                fieldList = append(fieldList, p.businessConfigType.Field(i))
        }</span>

        <span class="cov2" title="7">return reflect.StructOf(fieldList)</span>
}

func (p *registry) loadComponents() <span class="cov3" title="34">{
        p.loadComponentsOnce.Do(func() </span><span class="cov3" title="25">{
                // app
                p.AddComponent(ComponentApp, func(context.Context, string, ...utils.OptionExtender) func() </span><span class="cov3" title="34">{ return nil }</span>,
                        WithTag("yaml", "app"), WithTag("json", "app"), WithTag("toml", "app"))

                // debug
                <span class="cov3" title="25">p.AddComponent(ComponentDebug, func(context.Context, bool, ...utils.OptionExtender) func() </span><span class="cov3" title="34">{ return nil }</span>,
                        WithTag("yaml", "debug"), WithTag("json", "debug"), WithTag("toml", "debug"))

                // crypto
                <span class="cov3" title="25">p.AddComponent(ComponentCrypto, CryptoConstruct,
                        WithTag("yaml", "crypto"), WithTag("json", "crypto"), WithTag("toml", "crypto"))

                for _, item := range getComponents() </span><span class="cov5" title="325">{
                        p.AddComponent(item.name, item.constructor, item.opt...)
                }</span>

                /* example */
                // registry.AddComponent("ComponentExample", func(context.Context, string) func() { return nil },
                //    WithTag("custom_tag", "val"), WithTag("yaml", "val"))
        })
}

func (p *registry) initAllConfigByLoadFunc(businessConfig any, loadFn loadConfigFunc, opts ...utils.OptionExtender) <span class="cov3" title="34">{
        businessConfigVal := reflect.ValueOf(businessConfig)
        p.businessConfigType = utils.IndirectType(businessConfigVal.Type())

        p.businessConfig = reflect.New(p.businessConfigType).Interface()
        p.componentConfigs = reflect.New(p.makeComponentsConfigStruct()).Interface()
        if loadFn != nil </span><span class="cov3" title="34">{
                loadFn(p.businessConfig, opts...)
                loadFn(p.componentConfigs, opts...)
        }</span>
}

func (p *registry) initComponents(parent context.Context) func() <span class="cov3" title="34">{
        ctx, cancel := context.WithCancel(parent)
        ctxVal := reflect.ValueOf(ctx)
        o1 := reflect.ValueOf(utils.OptionExtender(AppName(p.appName)))
        o2 := reflect.ValueOf(utils.OptionExtender(DI(p.di)))

        baseObject := p.getBaseObject()
        destructors := make([]reflect.Value, 0, len(p.componentList))
        componentNames := make([]string, 0, len(p.componentList))
        hasCallbackComponentNames := make([]string, 0, len(p.componentList))
        for i := 0; i &lt; len(p.componentList); i++ </span><span class="cov5" title="544">{
                com := p.componentList[i]
                comArgs := reflect.ValueOf(clone.Clone(baseObject.FieldByName(com.Name).Interface()))
                componentNames = append(componentNames, com.Name)
                if out := com.Constructor.Call([]reflect.Value{ctxVal, comArgs, o1, o2}); len(out) &gt; 0 &amp;&amp; !out[0].IsNil() </span><span class="cov5" title="476">{
                        destructors = append(destructors, out[0])
                        hasCallbackComponentNames = append(hasCallbackComponentNames, com.Name)
                }</span>
        }

        /* print summary to stdout */
        <span class="cov3" title="34">pid := syscall.Getpid()
        app := p.AppName()
        log.SetFlags(log.Lshortfile | log.Ldate | log.Lmicroseconds)
        log.Printf("%v [Gofusion] %s initialized total %d components below: %s\n",
                pid, app, len(componentNames), strings.Join(componentNames, ", "))

        once := new(sync.Once)
        return func() </span><span class="cov3" title="34">{
                once.Do(func() </span><span class="cov3" title="34">{
                        initLocker.Lock()
                        defer initLocker.Unlock()

                        defer close(p.closeCh)

                        p.initWg.Done()
                        p.initWg.Wait()
                        cancel()
                        for i := len(destructors) - 1; i &gt;= 0; i-- </span><span class="cov5" title="476">{
                                log.Printf("%v [Gofusion] %s %s exiting...", pid, app, hasCallbackComponentNames[i])
                                destructors[i].Call(nil)
                                log.Printf("%v [Gofusion] %s %s exited", pid, app, hasCallbackComponentNames[i])
                        }</span>

                        <span class="cov3" title="34">p.di.Clear()
                        p.businessConfig = nil
                        p.componentConfigs = nil
                        p.initOnce = new(sync.Once)</span>
                })
        }
}

func (p *registry) addComponent(com *Component) <span class="cov5" title="400">{
        firstNonCoreComIndex := -1
        for i, cp := range p.componentList </span><span class="cov5" title="375">{
                if !cp.isCore </span><span class="cov5" title="375">{
                        firstNonCoreComIndex = i
                        break</span>
                }
        }
        <span class="cov5" title="400">if !com.isCore || firstNonCoreComIndex == -1 </span><span class="cov5" title="400">{
                p.componentList = append(p.componentList, com)
                sort.SliceStable(p.componentList, func(i, j int) bool </span><span class="cov7" title="3527">{
                        // core component would not be sorted
                        if p.componentList[i].isCore || p.componentList[j].isCore </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov7" title="3527">orderA := indexComponent(p.componentList[i].Name)
                        if orderA == -1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov7" title="3527">orderB := indexComponent(p.componentList[j].Name)
                        if orderB == -1 </span><span class="cov0" title="0">{
                                return true
                        }</span>

                        <span class="cov7" title="3527">return orderA &lt; orderB</span>
                })

                <span class="cov5" title="400">return</span>
        }
        <span class="cov0" title="0">list := make([]*Component, len(p.componentList)+1)
        for i := range list </span><span class="cov0" title="0">{
                if i &lt; firstNonCoreComIndex </span><span class="cov0" title="0">{
                        list[i] = p.componentList[i]
                }</span> else<span class="cov0" title="0"> if i == firstNonCoreComIndex </span><span class="cov0" title="0">{
                        list[i] = com
                }</span> else<span class="cov0" title="0"> {
                        list[i] = p.componentList[i-1]
                }</span>
        }

        <span class="cov0" title="0">p.componentList = list</span>
}

func (p *registry) checkBusinessConfig(businessConfig any) <span class="cov3" title="34">{
        typ := reflect.TypeOf(businessConfig)
        if typ.Kind() != reflect.Ptr || typ.Elem().Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                panic(errors.New("businessConfig should be a **struct"))</span>
        }
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package config

import (
        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/utils"
)

type Configurable interface {
        Init(businessConfig any, opts ...utils.OptionExtender) (gracefully func())
        LoadComponentConfig(name string, componentConfig any) (err error)
        GetAllConfigs() any
        Debug() (debug bool)
        AppName() (name string)
        DI() di.DI
}

type InitOption struct {
        DI      di.DI
        AppName string
}

func AppName(name string) utils.OptionFunc[InitOption] <span class="cov7" title="104">{
        return func(o *InitOption) </span><span class="cov10" title="478">{
                o.AppName = name
        }</span>
}

func DI(di di.DI) utils.OptionFunc[InitOption] <span class="cov6" title="34">{
        return func(o *InitOption) </span><span class="cov9" title="408">{
                o.DI = di
        }</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package context

import (
        "context"

        "github.com/wfusion/gofusion/common/utils"
)

func GetUserID(ctx context.Context, args ...string) (userID string) <span class="cov9" title="12807">{
        return utils.GetCtxAny(ctx, KeyUserID, args...)
}</span>

func SetUserID(ctx context.Context, val string) context.Context <span class="cov0" title="0">{
        return utils.SetCtxAny(ctx, KeyUserID, val)
}</span>

func GetTraceID(ctx context.Context, args ...string) (traceID string) <span class="cov10" title="12886">{
        return utils.GetCtxAny(ctx, KeyTraceID, args...)
}</span>

func SetTraceID(ctx context.Context, val string) context.Context <span class="cov5" title="192">{
        return utils.SetCtxAny(ctx, KeyTraceID, val)
}</span>

func GetLangs(ctx context.Context, args ...[]string) (langs []string) <span class="cov5" title="162">{
        return utils.GetCtxAny(ctx, KeyLangs, args...)
}</span>

func SetLangs(ctx context.Context, val []string) context.Context <span class="cov0" title="0">{
        return utils.SetCtxAny(ctx, KeyLangs, val)
}</span>

func GetCronTaskID(ctx context.Context, args ...string) (userID string) <span class="cov9" title="12804">{
        return utils.GetCtxAny(ctx, KeyCronTaskID, args...)
}</span>

func SetCronTaskID(ctx context.Context, val string) context.Context <span class="cov0" title="0">{
        return utils.SetCtxAny(ctx, KeyCronTaskID, val)
}</span>

func GetCronTaskName(ctx context.Context, args ...string) (userID string) <span class="cov9" title="12846">{
        return utils.GetCtxAny(ctx, KeyCronTaskName, args...)
}</span>

func SetCronTaskName(ctx context.Context, val string) context.Context <span class="cov4" title="32">{
        return utils.SetCtxAny(ctx, KeyCronTaskName, val)
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package context

import (
        "context"
        "encoding/gob"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/wfusion/gofusion/common/infra/watermill"

        "github.com/wfusion/gofusion/common/infra/watermill/message"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

// _context is a gofusion union context struct
//nolint: revive // struct tag too long issue
type _context struct {
        Langs            []string `json:"langs" yaml:"langs" toml:"langs" mapstructure:"langs"`
        UserID           *string  `json:"user_id" yaml:"user_id" toml:"user_id" mapstructure:"user_id"`
        TraceID          *string  `json:"trace_id" yaml:"trace_id" toml:"trace_id" mapstructure:"trace_id"`
        CronTaskID       *string  `json:"cron_task_id" yaml:"cron_task_id" toml:"cron_task_id" mapstructure:"cron_task_id"`
        CronTaskName     *string  `json:"cron_task_name" yaml:"cron_task_name" toml:"cron_task_name" mapstructure:"cron_task_name"`
        Deadline         *string  `json:"deadline" yaml:"deadline" toml:"deadline" mapstructure:"deadline"`
        DeadlineLocation *string  `json:"deadline_location" yaml:"deadline_location" toml:"deadline_location" mapstructure:"deadline_location"`
}

func (c *_context) unmarshal() (ctx context.Context) <span class="cov2" title="6">{
        ctx = context.Background()
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="6">if c.Langs != nil </span><span class="cov0" title="0">{
                ctx = SetLangs(ctx, c.Langs)
        }</span>
        <span class="cov2" title="6">if c.UserID != nil </span><span class="cov0" title="0">{
                ctx = SetUserID(ctx, *c.UserID)
        }</span>
        <span class="cov2" title="6">if c.TraceID != nil </span><span class="cov2" title="4">{
                ctx = SetTraceID(ctx, *c.TraceID)
        }</span>
        <span class="cov2" title="6">if c.CronTaskID != nil </span><span class="cov0" title="0">{
                ctx = SetCronTaskID(ctx, *c.CronTaskID)
        }</span>
        <span class="cov2" title="6">if c.CronTaskName != nil </span><span class="cov0" title="0">{
                ctx = SetCronTaskName(ctx, *c.CronTaskName)
        }</span>
        <span class="cov2" title="6">if c.Deadline != nil </span><span class="cov2" title="4">{
                location := utils.Must(time.LoadLocation(*c.DeadlineLocation))
                // FIXME: it may result context leak issue
                ctx, _ = context.WithDeadline(ctx, utils.Must(time.ParseInLocation(time.RFC3339Nano, *c.Deadline, location)))
        }</span>

        <span class="cov2" title="6">return</span>
}

func (c *_context) Marshal() (b []byte) <span class="cov2" title="6">{
        bs, cb := utils.BytesBufferPool.Get(nil)
        defer cb()
        utils.MustSuccess(gob.NewEncoder(bs).Encode(c))

        b = make([]byte, bs.Len())
        copy(b, bs.Bytes())
        return
}</span>

func Flatten(ctx context.Context) (c *_context) <span class="cov2" title="6">{
        c = new(_context)
        if langs := GetLangs(ctx); langs != nil </span><span class="cov0" title="0">{
                c.Langs = langs
        }</span>
        <span class="cov2" title="6">if userID := GetUserID(ctx); utils.IsStrNotBlank(userID) </span><span class="cov0" title="0">{
                c.UserID = utils.AnyPtr(userID)
        }</span>
        <span class="cov2" title="6">if traceID := GetTraceID(ctx); utils.IsStrNotBlank(traceID) </span><span class="cov2" title="4">{
                c.TraceID = utils.AnyPtr(traceID)
        }</span>
        <span class="cov2" title="6">if taskID := GetCronTaskID(ctx); utils.IsStrNotBlank(taskID) </span><span class="cov0" title="0">{
                c.CronTaskID = utils.AnyPtr(taskID)
        }</span>
        <span class="cov2" title="6">if taskName := GetCronTaskName(ctx); utils.IsStrNotBlank(taskName) </span><span class="cov0" title="0">{
                c.CronTaskName = utils.AnyPtr(taskName)
        }</span>
        <span class="cov2" title="6">if deadline, ok := ctx.Deadline(); ok </span><span class="cov2" title="4">{
                c.Deadline = utils.AnyPtr(deadline.Format(time.RFC3339Nano))
                c.DeadlineLocation = utils.AnyPtr(deadline.Location().String())
        }</span>
        <span class="cov2" title="6">return</span>
}

func WatermillMetadata(ctx context.Context) (metadata message.Metadata) <span class="cov6" title="159">{
        metadata = make(message.Metadata)
        if langs := GetLangs(ctx); langs != nil </span><span class="cov0" title="0">{
                marshaled, _ := json.Marshal(langs)
                metadata["langs"] = string(marshaled)
        }</span>
        <span class="cov6" title="157">if userID := GetUserID(ctx); utils.IsStrNotBlank(userID) </span><span class="cov0" title="0">{
                metadata["user_id"] = userID
        }</span>
        <span class="cov6" title="160">if traceID := GetTraceID(ctx); utils.IsStrNotBlank(traceID) </span><span class="cov6" title="159">{
                metadata["trace_id"] = traceID
        }</span>
        <span class="cov6" title="155">if taskID := GetCronTaskID(ctx); utils.IsStrNotBlank(taskID) </span><span class="cov0" title="0">{
                metadata["cron_task_id"] = taskID
        }</span>
        <span class="cov6" title="160">if taskName := GetCronTaskName(ctx); utils.IsStrNotBlank(taskName) </span><span class="cov0" title="0">{
                metadata["cron_task_name"] = taskName
        }</span>
        <span class="cov6" title="160">if deadline, ok := ctx.Deadline(); ok </span><span class="cov6" title="160">{
                metadata["deadline"] = deadline.Format(time.RFC3339Nano)
                metadata["deadline_location"] = deadline.Location().String()
        }</span>
        <span class="cov6" title="160">return</span>
}

type newOption struct {
        g *gin.Context
        c *_context
        m message.Metadata
}

func (o *newOption) ginUnmarshal() (ctx context.Context) <span class="cov4" title="34">{
        ctx = context.Background()
        if userID := o.g.GetString(KeyUserID); utils.IsStrNotBlank(userID) </span><span class="cov0" title="0">{
                ctx = SetUserID(ctx, userID)
        }</span>
        <span class="cov4" title="34">if traceID := o.g.GetString(KeyTraceID); utils.IsStrNotBlank(traceID) </span><span class="cov1" title="2">{
                ctx = SetTraceID(ctx, traceID)
        }</span>
        <span class="cov4" title="34">langs := o.g.Request.Header.Values("Accept-Language")
        if lang := o.g.GetString("lang"); utils.IsStrNotBlank(lang) </span><span class="cov0" title="0">{
                langs = append(langs, lang)
        }</span>
        <span class="cov4" title="34">if lang := o.g.GetString(KeyLangs); utils.IsStrNotBlank(lang) </span><span class="cov0" title="0">{
                langs = append(langs, lang)
        }</span>
        <span class="cov4" title="34">if len(langs) &gt; 0 </span><span class="cov0" title="0">{
                ctx = SetLangs(ctx, langs)
        }</span>
        <span class="cov4" title="34">return</span>
}

func (o *newOption) messageUnmarshal() (ctx context.Context) <span class="cov5" title="120">{
        ctx = context.Background()
        mapGetFn := func(k string) string </span><span class="cov10" title="8259">{ return o.m[k] }</span>
        <span class="cov5" title="120">if userID := utils.LookupByFuzzyKeyword[string](mapGetFn, "user_id"); utils.IsStrNotBlank(userID) </span><span class="cov0" title="0">{
                ctx = SetUserID(ctx, userID)
        }</span>
        <span class="cov5" title="120">if traceID := utils.LookupByFuzzyKeyword[string](mapGetFn, "trace_id"); utils.IsStrNotBlank(traceID) </span><span class="cov5" title="120">{
                ctx = SetTraceID(ctx, traceID)
        }</span>
        <span class="cov5" title="120">if langstr := utils.LookupByFuzzyKeyword[string](mapGetFn, "langs"); utils.IsStrNotBlank(langstr) </span><span class="cov0" title="0">{
                var langs []string
                _ = json.Unmarshal([]byte(langstr), &amp;langs)
                ctx = SetLangs(ctx, langs)
        }</span>
        <span class="cov5" title="120">if taskID := utils.LookupByFuzzyKeyword[string](mapGetFn, "cron_task_id"); utils.IsStrNotBlank(taskID) </span><span class="cov0" title="0">{
                ctx = SetCronTaskID(ctx, taskID)
        }</span>
        <span class="cov5" title="120">if name := utils.LookupByFuzzyKeyword[string](mapGetFn, "cron_task_name"); utils.IsStrNotBlank(name) </span><span class="cov0" title="0">{
                ctx = SetCronTaskName(ctx, name)
        }</span>
        <span class="cov5" title="120">if messageUUID := o.m[watermill.ContextKeyMessageUUID]; utils.IsStrNotBlank(messageUUID) </span><span class="cov5" title="105">{
                ctx = utils.SetCtxAny(ctx, watermill.ContextKeyMessageUUID, messageUUID)
        }</span>
        <span class="cov5" title="120">if messageRawID := o.m[watermill.ContextKeyRawMessageID]; utils.IsStrNotBlank(messageRawID) </span><span class="cov5" title="105">{
                ctx = utils.SetCtxAny(ctx, watermill.ContextKeyRawMessageID, messageRawID)
        }</span>

        <span class="cov5" title="120">deadline := utils.LookupByFuzzyKeyword[string](mapGetFn, "deadline")
        deadlineLoc := utils.LookupByFuzzyKeyword[string](mapGetFn, "deadline_location")
        if utils.IsStrNotBlank(deadline) </span><span class="cov5" title="120">{
                location := utils.Must(time.LoadLocation(deadlineLoc))
                // FIXME: it may result context leak issue
                ctx, _ = context.WithDeadline(ctx, utils.Must(time.ParseInLocation(time.RFC3339Nano, deadline, location)))
        }</span>
        <span class="cov5" title="120">return</span>
}

func Context(c []byte) utils.OptionFunc[newOption] <span class="cov2" title="6">{
        return func(o *newOption) </span><span class="cov2" title="6">{
                o.c = new(_context)
                utils.MustSuccess(utils.Unmarshal(c, o.c, ""))
        }</span>
}

func Gin(c *gin.Context) utils.OptionFunc[newOption] <span class="cov4" title="34">{
        return func(o *newOption) </span><span class="cov4" title="34">{
                o.g = c
        }</span>
}

func Watermill(m message.Metadata) utils.OptionFunc[newOption] <span class="cov5" title="120">{
        return func(o *newOption) </span><span class="cov5" title="120">{
                o.m = m
        }</span>
}

func New(opts ...utils.OptionExtender) (ctx context.Context) <span class="cov6" title="160">{
        o := utils.ApplyOptions[newOption](opts...)

        // alternative
        switch </span>{
        case o.g != nil:<span class="cov4" title="34">
                return o.ginUnmarshal()</span>
        case o.c != nil:<span class="cov2" title="6">
                return o.c.unmarshal()</span>
        case o.m != nil:<span class="cov5" title="120">
                return o.messageUnmarshal()</span>
        default:<span class="cov0" title="0">
                panic(ErrUnknownInstantiationMethod)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package cron

import (
        "context"
        "fmt"
        "math/rand"
        "reflect"
        "strings"
        "sync"
        "time"

        "github.com/pkg/errors"
        "github.com/robfig/cron/v3"
        "go.uber.org/multierr"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/infra/asynq"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/lock"
        "github.com/wfusion/gofusion/log"
        "github.com/wfusion/gofusion/redis"
        "github.com/wfusion/gofusion/routine"

        rdsDrv "github.com/redis/go-redis/v9"

        fmkCtx "github.com/wfusion/gofusion/context"
)

const (
        asyncqTaskPayloadField  = "payload"
        asyncqTaskTypenameField = "typename"
)

var (
        asynqLoggerType                     = reflect.TypeOf((*asynq.Logger)(nil)).Elem()
        asynqPeriodicTaskConfigProviderType = reflect.TypeOf((*asynq.PeriodicTaskConfigProvider)(nil)).Elem()
)

type asynqRouter struct {
        *asynq.ServeMux

        appName string

        l sync.RWMutex
        n string
        c *Conf

        mws     []asynq.MiddlewareFunc
        logger  asynq.Logger
        locker  lock.Lockable
        server  *asynq.Server
        trigger *asynq.PeriodicTaskManager

        id                    string
        lockDurations         map[string]time.Duration
        shouldShutdownServer  bool
        shouldShutdownTrigger bool
}

func newAsynq(ctx context.Context, appName, name string, conf *Conf) IRouter <span class="cov2" title="13">{
        r := &amp;asynqRouter{
                appName:               appName,
                n:                     name,
                c:                     conf,
                lockDurations:         make(map[string]time.Duration, len(conf.Tasks)),
                shouldShutdownServer:  true,
                shouldShutdownTrigger: true,
        }
        if utils.IsStrBlank(r.c.Queue) </span><span class="cov2" title="9">{
                r.c.Queue = r.defaultQueue()
        }</span>

        <span class="cov2" title="13">var rdsCli rdsDrv.UniversalClient
        switch conf.InstanceType </span>{
        case instanceTypeRedis:<span class="cov2" title="13">
                rdsCli = redis.Use(ctx, conf.Instance, redis.AppName(appName))</span>
        case instanceTypeMysql:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unknown instance type: %s", conf.InstanceType))</span>
        }

        <span class="cov2" title="13">if r.logger == nil &amp;&amp; utils.IsStrNotBlank(conf.Logger) </span><span class="cov2" title="13">{
                loggerType := inspect.TypeOf(conf.Logger)
                loggerValue := reflect.New(loggerType)
                if loggerValue.Type().Implements(customLoggerType) </span><span class="cov2" title="13">{
                        logger := log.Use(conf.LogInstance, log.AppName(appName))
                        loggerValue.Interface().(customLogger).Init(logger, appName, name)
                }</span>
                <span class="cov2" title="13">r.logger = loggerValue.Convert(asynqLoggerType).Interface().(asynq.Logger)</span>
        }
        <span class="cov2" title="13">if r.locker == nil &amp;&amp; utils.IsStrNotBlank(conf.LockInstance) </span><span class="cov2" title="11">{
                r.locker = lock.Use(conf.LockInstance, lock.AppName(appName))
                if r.locker == nil </span><span class="cov0" title="0">{
                        panic(errors.Errorf("locker instance not found: %s", conf.LockInstance))</span>
                }
        }

        <span class="cov2" title="13">var provider asynq.PeriodicTaskConfigProvider
        if utils.IsStrNotBlank(conf.TaskLoader) </span><span class="cov0" title="0">{
                loaderType := inspect.TypeOf(conf.TaskLoader)
                if loaderType == nil </span><span class="cov0" title="0">{
                        panic(errors.Errorf("%s not found", conf.TaskLoader))</span>
                }
                <span class="cov0" title="0">provider = reflect.New(loaderType).
                        Convert(asynqPeriodicTaskConfigProviderType).Interface().(asynq.PeriodicTaskConfigProvider)</span>
        }

        <span class="cov2" title="13">logLevel := asynq.LogLevel(0)
        utils.MustSuccess(logLevel.Set(conf.LogLevel))

        wrapper := &amp;asynqWrapper{r: r, n: r.n, appName: appName, cli: rdsCli, provider: provider}
        if conf.Trigger </span><span class="cov2" title="13">{
                r.initTrigger(ctx, wrapper, logLevel)
        }</span>
        <span class="cov2" title="13">if conf.Server </span><span class="cov2" title="13">{
                r.initServer(ctx, wrapper, logLevel)
        }</span>

        <span class="cov2" title="13">return r</span>
}

func (a *asynqRouter) Use(mws ...routerMiddleware) <span class="cov0" title="0">{
        for _, mw := range mws </span><span class="cov0" title="0">{
                a.mws = append(a.mws, a.adaptMiddleware(mw))
        }</span>
}

func (a *asynqRouter) Handle(pattern string, fn any, _ ...utils.OptionExtender) <span class="cov1" title="6">{
        if !a.c.Server </span><span class="cov0" title="0">{
                a.debug(context.Background(), "cannot handle task %s: client is not enabled", a.n)
                return
        }</span>

        <span class="cov1" title="6">a.ServeMux.Handle(a.formatTaskName(pattern), a.adaptAsynqHandlerFunc(fn))</span>
}

func (a *asynqRouter) Serve() (err error) <span class="cov0" title="0">{
        defer a.info(context.Background(), "scheduler is running")

        if a.c.Server </span><span class="cov0" title="0">{
                a.ServeMux.Use(a.gatewayMiddleware)
                a.ServeMux.Use(a.mws...)
        }</span>

        <span class="cov0" title="0">if a.c.Trigger &amp;&amp; !a.c.Server </span><span class="cov0" title="0">{
                return a.trigger.Run()
        }</span>
        <span class="cov0" title="0">if !a.c.Trigger &amp;&amp; a.c.Server </span><span class="cov0" title="0">{
                return a.server.Run(a.ServeMux)
        }</span>

        <span class="cov0" title="0">a.shouldShutdownServer = false
        if err = a.trigger.Start(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return a.server.Run(a.ServeMux)</span>
}

func (a *asynqRouter) Start() (err error) <span class="cov1" title="4">{
        defer a.info(context.Background(), "scheduler started")

        if a.c.Trigger </span><span class="cov1" title="4">{
                if err = a.trigger.Start(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov1" title="4">if a.c.Server </span><span class="cov1" title="4">{
                a.ServeMux.Use(a.gatewayMiddleware)
                a.ServeMux.Use(a.mws...)
                if err = a.server.Start(a.ServeMux); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov1" title="4">return</span>
}

func (a *asynqRouter) shutdown() (err error) <span class="cov2" title="13">{
        if a.c.Trigger </span><span class="cov2" title="13">{
                _, catchErr := utils.Catch(a.trigger.Shutdown)
                err = multierr.Append(err, errors.Cause(catchErr))
        }</span>
        <span class="cov2" title="13">if a.c.Server </span><span class="cov2" title="13">{
                _, catchErr := utils.Catch(a.server.Shutdown)
                err = multierr.Append(err, errors.Cause(catchErr))
        }</span>
        <span class="cov2" title="13">return</span>
}

func (a *asynqRouter) initTrigger(ctx context.Context, wrapper *asynqWrapper, logLevel asynq.LogLevel) <span class="cov2" title="13">{
        a.trigger = utils.Must(
                asynq.NewPeriodicTaskManager(asynq.PeriodicTaskManagerOpts{
                        PeriodicTaskConfigProvider: wrapper,
                        RedisConnOpt:               wrapper,
                        SchedulerOpts: &amp;asynq.SchedulerOpts{
                                Logger:                a.logger,
                                LogLevel:              logLevel,
                                Location:              utils.Must(time.LoadLocation(a.c.Timezone)),
                                DisableRedisConnClose: true,
                                PreEnqueueFunc:        a.preEnqueueFunc(ctx),
                                PostEnqueueFunc:       a.postEnqueueFunc(ctx),
                                EnqueueErrorHandler: func(task *asynq.Task, opts []asynq.Option, err error) </span><span class="cov2" title="44">{
                                        ignored := []error{errDiscardMessage}
                                        if a.locker == nil </span><span class="cov1" title="5">{
                                                ignored = append(ignored, asynq.ErrDuplicateTask, asynq.ErrTaskIDConflict)
                                        }</span>
                                        <span class="cov2" title="44">if err = utils.ErrIgnore(err, ignored...); err == nil </span><span class="cov2" title="35">{
                                                return
                                        }</span>
                                        <span class="cov2" title="9">taskName := "unknown"
                                        if task != nil </span><span class="cov2" title="9">{
                                                taskName = a.unformatTaskName(task.Type())
                                        }</span>
                                        <span class="cov2" title="9">a.warn(ctx, "enqueue task %s failed: %s", taskName, err)</span>
                                },
                        },
                        SyncInterval: utils.Must(time.ParseDuration(a.c.RefreshTasksInterval)),
                }),
        )
        <span class="cov2" title="13">a.id = a.trigger.ID()</span>
}

func (a *asynqRouter) initServer(ctx context.Context, wrapper *asynqWrapper, logLevel asynq.LogLevel) <span class="cov2" title="13">{
        a.ServeMux = asynq.NewServeMux()
        for pattern, taskCfg := range a.c.Tasks </span><span class="cov2" title="16">{
                if utils.IsStrBlank(taskCfg.Callback) </span><span class="cov2" title="14">{
                        continue</span>
                }
                <span class="cov1" title="2">handler := *(*routerHandleFunc)(inspect.FuncOf(taskCfg.Callback))
                a.ServeMux.Handle(a.formatTaskName(pattern), a.adaptAsynqHandlerFunc(handler))</span>
        }

        <span class="cov2" title="13">asynqCfg := asynq.Config{
                Concurrency:    a.c.ServerConcurrency,
                BaseContext:    context.Background,
                RetryDelayFunc: asynq.DefaultRetryDelayFunc,
                IsFailure:      func(err error) bool </span><span class="cov0" title="0">{ return !errors.Is(err, errDiscardMessage) }</span>,
                Queues:         nil,
                StrictPriority: false,
                ErrorHandler: asynq.ErrorHandlerFunc(func(ctx context.Context, task *asynq.Task, err error) <span class="cov0" title="0">{
                        taskName := "unknown"
                        if task != nil </span><span class="cov0" title="0">{
                                taskName = a.unformatTaskName(task.Type())
                        }</span>
                        <span class="cov0" title="0">a.info(ctx, "handle task %s message error %s", taskName, err)</span>
                }),
                Logger:          a.logger,
                LogLevel:        logLevel,
                ShutdownTimeout: 8 * time.Second,
                HealthCheckFunc: func(err error) <span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                a.warn(ctx, "health check check failed: %s", err)
                        }</span>
                },
                HealthCheckInterval:      15 * time.Second,
                DelayedTaskCheckInterval: 5 * time.Second,
                GroupGracePeriod:         1 * time.Minute,
                GroupMaxDelay:            0,
                GroupMaxSize:             0,
                GroupAggregator:          nil,
                DisableRedisConnClose:    true,
        }
        <span class="cov2" title="13">if utils.IsStrNotBlank(a.c.Queue) </span><span class="cov2" title="13">{
                asynqCfg.Queues = map[string]int{a.c.Queue: 3}
        }</span>

        <span class="cov2" title="13">a.server = asynq.NewServer(wrapper, asynqCfg)</span>
}

func (a *asynqRouter) preEnqueueFunc(ctx context.Context) func(*asynq.Task, []asynq.Option) error <span class="cov2" title="13">{
        return func(task *asynq.Task, opts []asynq.Option) (err error) </span><span class="cov3" title="79">{
                // when locker is disabled, we cannot determine which message should be discarded
                if a.locker == nil </span><span class="cov2" title="10">{
                        return
                }</span>

                <span class="cov3" title="69">taskName := a.unformatTaskName(task.Type())
                lockKey := a.formatLockKey(taskName)
                if err = a.locker.Lock(ctx, lockKey, lock.Expire(tolerantOfTimeNotSync), lock.ReentrantKey(a.id)); err == nil </span><span class="cov2" title="30">{
                        a.info(ctx, "pre enqueue task %s success", taskName)
                        return
                }</span>

                <span class="cov2" title="37">err = utils.ErrIgnore(err, lock.ErrTimeout, lock.ErrContextDone)
                if err == nil </span><span class="cov2" title="29">{
                        a.debug(ctx, "pre enqueue discard task %s", taskName)
                        return errDiscardMessage
                }</span>

                <span class="cov2" title="9">a.warn(ctx, "pre enqueue task %s failed: %s", taskName, err)
                return</span>
        }
}

func (a *asynqRouter) postEnqueueFunc(ctx context.Context) func(info *asynq.TaskInfo, err error) <span class="cov2" title="13">{
        return func(info *asynq.TaskInfo, err error) </span><span class="cov3" title="78">{
                // release lock
                if a.locker != nil </span><span class="cov3" title="68">{
                        defer routine.Go(a.releaseCronTaskLock, routine.Args(ctx, info), routine.AppName(a.appName))
                }</span>

                <span class="cov3" title="78">ignored := []error{errDiscardMessage}
                if a.locker == nil </span><span class="cov2" title="10">{
                        ignored = append(ignored, asynq.ErrDuplicateTask, asynq.ErrTaskIDConflict)
                }</span>

                <span class="cov3" title="78">if err = utils.ErrIgnore(err, ignored...); err == nil </span><span class="cov3" title="69">{
                        return
                }</span>
                <span class="cov2" title="9">taskName := "unknown"
                if info != nil </span><span class="cov0" title="0">{
                        taskName = a.unformatTaskName(info.Type)
                }</span>
                <span class="cov2" title="9">a.debug(ctx, "post enqueue task %s failed: %s", taskName, err)</span>
        }
}

func (a *asynqRouter) releaseCronTaskLock(ctx context.Context, info *asynq.TaskInfo) <span class="cov3" title="65">{
        if info == nil </span><span class="cov2" title="36">{
                return
        }</span>
        <span class="cov2" title="29">taskName := a.unformatTaskName(info.Type)

        // 90 ~ 100ms jitter
        jitter := 90*time.Millisecond + time.Duration(float64(10*time.Millisecond)*rand.Float64())

        a.l.RLock()
        lockTime := a.lockDurations[info.Type]
        a.l.RUnlock()

        // prevent a negative tolerant
        tolerant := utils.Min(tolerantOfTimeNotSync, lockTime) - jitter
        tolerant = utils.Max(tolerant, 500*time.Millisecond)
        timer := time.NewTimer(tolerant)
        defer timer.Stop()

        var e error
        defer func() </span><span class="cov2" title="30">{
                if e != nil </span><span class="cov1" title="3">{
                        a.warn(ctx, "post enqueue task %s release lock failed: %s", taskName, e)
                }</span>
        }()

        <span class="cov2" title="30">now := time.Now()
        unlockKey := a.formatLockKey(taskName)
        for </span><span class="cov9" title="105261566">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="3">
                        a.debug(ctx, "post enqueue task %s release lock: context done", taskName)
                        e = a.locker.Unlock(ctx, unlockKey, lock.ReentrantKey(a.id))
                        return</span>
                case &lt;-timer.C:<span class="cov2" title="27">
                        e = a.locker.Unlock(ctx, unlockKey, lock.ReentrantKey(a.id))
                        return</span>
                default:<span class="cov10" title="105404745">
                        a.l.RLock()
                        newLockTime := a.lockDurations[info.Type]
                        a.l.RUnlock()
                        if newLockTime != lockTime </span><span class="cov0" title="0">{
                                lockTime = newLockTime
                                tolerant = utils.Min(tolerantOfTimeNotSync, lockTime) - jitter
                                tolerant = utils.Max(tolerant, 500*time.Millisecond)
                                tolerant = utils.Max(0, tolerant-time.Since(now))
                                timer.Reset(tolerant)
                        }</span>
                }
        }
}

func (a *asynqRouter) gatewayMiddleware(next asynq.Handler) asynq.Handler <span class="cov2" title="32">{
        return asynq.HandlerFunc(func(ctx context.Context, raw *asynq.Task) (err error) </span><span class="cov2" title="32">{
                taskName := a.unformatTaskName(raw.Type())
                inspect.SetField(raw, asyncqTaskTypenameField, taskName)
                if utils.IsStrBlank(fmkCtx.GetTraceID(ctx)) </span><span class="cov2" title="32">{
                        ctx = fmkCtx.SetTraceID(ctx, utils.NginxID())
                }</span>
                <span class="cov2" title="32">if utils.IsStrBlank(fmkCtx.GetCronTaskName(ctx)) </span><span class="cov2" title="32">{
                        ctx = fmkCtx.SetCronTaskName(ctx, taskName)
                }</span>
                <span class="cov2" title="32">return next.ProcessTask(ctx, raw)</span>
        })
}

func (a *asynqRouter) adaptMiddleware(mw routerMiddleware) asynq.MiddlewareFunc <span class="cov0" title="0">{
        return func(asynqNext asynq.Handler) asynq.Handler </span><span class="cov0" title="0">{
                next := mw(a.adaptRouterHandlerFunc(asynqNext))
                return a.adaptAsynqHandlerFunc(next)
        }</span>
}

// adaptAsynqHandlerFunc support function signature
// - func(ctx context.Context)
// - func(ctx context.Context) error
// - func(ctx context.Context, args json.Serializable)
// - func(ctx context.Context, args *json.Serializable) error
func (a *asynqRouter) adaptAsynqHandlerFunc(h any) asynq.HandlerFunc <span class="cov2" title="8">{
        if fn, ok := h.(routerHandleFunc); ok </span><span class="cov1" title="2">{
                return func(ctx context.Context, raw *asynq.Task) (err error) </span><span class="cov2" title="10">{
                        return fn(ctx, a.newTask(raw))
                }</span>
        }
        <span class="cov1" title="6">if fn, ok := h.(func(ctx context.Context, task Task) (err error)); ok </span><span class="cov1" title="4">{
                return func(ctx context.Context, raw *asynq.Task) (err error) </span><span class="cov2" title="13">{
                        return fn(ctx, a.newTask(raw))
                }</span>
        }

        <span class="cov1" title="2">var (
                hasArg          bool
                argType         reflect.Type
                argTypePtrDepth int
        )
        if reflect.TypeOf(h).NumIn() &gt; 1 </span><span class="cov1" title="2">{
                argType = reflect.TypeOf(h).In(1)
                for argType.Kind() == reflect.Ptr </span><span class="cov1" title="2">{
                        argType = argType.Elem()
                        argTypePtrDepth++
                }</span>
                <span class="cov1" title="2">hasArg = true</span>
        }

        <span class="cov1" title="2">fn := utils.WrapFunc1[error](h)
        return func(ctx context.Context, raw *asynq.Task) (err error) </span><span class="cov2" title="9">{
                if !hasArg </span><span class="cov0" title="0">{
                        return fn(ctx)
                }</span>
                <span class="cov2" title="9">arg := reflect.New(argType)
                payload := raw.Payload()
                if len(payload) == 0 </span><span class="cov0" title="0">{
                        payload = []byte("null")
                }</span>
                <span class="cov2" title="9">if err = json.Unmarshal(payload, arg.Interface()); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov2" title="9">arg = arg.Elem()
                for i := 0; i &lt; argTypePtrDepth; i++ </span><span class="cov2" title="9">{
                        arg = arg.Addr()
                }</span>

                <span class="cov2" title="9">return fn(ctx, arg.Interface())</span>
        }
}

func (a *asynqRouter) adaptRouterHandlerFunc(h asynq.Handler) routerHandleFunc <span class="cov0" title="0">{
        return func(ctx context.Context, raw Task) (err error) </span><span class="cov0" title="0">{
                return h.ProcessTask(ctx, a.newAsynqTask(raw))
        }</span>
}

func (a *asynqRouter) defaultQueue() (result string) <span class="cov2" title="9">{
        return fmt.Sprintf("%s:cron", config.Use(a.appName).AppName())
}</span>
func (a *asynqRouter) formatLockKey(taskName string) string <span class="cov3" title="98">{
        return fmt.Sprintf("cron_%s", taskName)
}</span>
func (a *asynqRouter) formatTaskName(taskName string) (result string) <span class="cov2" title="16">{
        return fmt.Sprintf("%s:cron:%s", config.Use(a.appName).AppName(), taskName)
}</span>
func (a *asynqRouter) unformatTaskName(taskName string) (result string) <span class="cov3" title="140">{
        return strings.TrimPrefix(taskName, fmt.Sprintf("%s:cron:", config.Use(a.appName).AppName()))
}</span>

func (a *asynqRouter) newTask(raw *asynq.Task) (t Task) <span class="cov2" title="23">{
        return &amp;task{
                id:         raw.Type(),
                name:       raw.Type(),
                payload:    raw.Payload(),
                rawMessage: raw,
        }
}</span>

func (a *asynqRouter) newAsynqTask(raw Task) (t *asynq.Task) <span class="cov0" title="0">{
        return raw.RawMessage().(*asynq.Task)
}</span>

type asynqWrapper struct {
        appName string

        r        *asynqRouter
        n        string
        cli      rdsDrv.UniversalClient
        provider asynq.PeriodicTaskConfigProvider
}

func (a *asynqWrapper) MakeRedisClient() any <span class="cov2" title="39">{
        return a.cli
}</span>

func (a *asynqWrapper) GetConfigs() (result []*asynq.PeriodicTaskConfig, err error) <span class="cov1" title="4">{
        result, err = a.getConfigs()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="4">a.r.l.Lock()
        defer a.r.l.Unlock()
        for _, cfg := range result </span><span class="cov2" title="8">{
                // renaming
                taskName := inspect.GetField[string](cfg.Task, asyncqTaskTypenameField)
                inspect.SetField(cfg.Task, asyncqTaskTypenameField, a.r.formatTaskName(taskName))

                name := cfg.Task.Type()
                a.r.lockDurations[name], err = a.getTaskExecuteInterval(cfg.Cronspec)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov1" title="4">return</span>
}

func (a *asynqWrapper) getConfigs() (result []*asynq.PeriodicTaskConfig, err error) <span class="cov1" title="4">{
        if a.provider != nil </span><span class="cov0" title="0">{
                result, err = a.provider.GetConfigs()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov1" title="4">var confs map[string]*Conf
        if err = config.Use(a.appName).LoadComponentConfig(config.ComponentCron, &amp;confs); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="4">conf, ok := confs[a.n]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.Errorf("%s cron config not found", a.n)
        }</span>

        <span class="cov1" title="4">loc, _ := time.LoadLocation(a.r.c.Timezone)
        if loc == nil </span><span class="cov0" title="0">{
                loc = constant.DefaultLocation()
        }</span>

        <span class="cov1" title="4">queue := conf.Queue
        if utils.IsStrBlank(queue) </span><span class="cov0" title="0">{
                queue = a.r.c.Queue
        }</span>
        <span class="cov1" title="4">for name, cfg := range conf.Tasks </span><span class="cov2" title="8">{
                var (
                        deadline          time.Time
                        interval, timeout time.Duration
                        opts              []asynq.Option
                )
                if interval, err = a.getTaskExecuteInterval(cfg.Crontab); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov2" title="8">if utils.IsStrNotBlank(cfg.Timeout) </span><span class="cov0" title="0">{
                        if timeout, err = time.ParseDuration(cfg.Timeout); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">opts = append(opts, asynq.Timeout(timeout))</span>
                } else<span class="cov2" title="8"> {
                        opts = append(opts, asynq.Timeout(interval))
                }</span>
                <span class="cov2" title="8">if utils.IsStrNotBlank(cfg.Deadline) </span><span class="cov0" title="0">{
                        if deadline, err = time.ParseInLocation(constant.StdTimeLayout, cfg.Deadline, loc); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">opts = append(opts, asynq.Deadline(deadline))</span>
                }

                <span class="cov2" title="8">result = append(result, &amp;asynq.PeriodicTaskConfig{
                        Cronspec: cfg.Crontab,
                        Task:     asynq.NewTask(name, []byte(cfg.Payload)),
                        Opts: append(opts, []asynq.Option{
                                asynq.TaskID(name),
                                asynq.Unique(utils.Min(interval, tolerantOfTimeNotSync)),
                                asynq.Queue(queue),
                                asynq.MaxRetry(utils.Max(0, cfg.Retry)),
                        }...),
                })</span>
        }
        <span class="cov1" title="4">return</span>
}

func (a *asynqWrapper) getTaskExecuteInterval(spec string) (interval time.Duration, err error) <span class="cov2" title="16">{
        now := time.Now()
        scheduler, err := cron.ParseStandard(spec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov2" title="16">next := scheduler.Next(now)
        interval = scheduler.Next(next).Sub(next)
        return</span>
}

func init() <span class="cov2" title="14">{
        rand.Seed(time.Now().UnixMicro())
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package cron

import (
        "context"
        "log"
        "sync"
        "syscall"

        "github.com/pkg/errors"
        "github.com/wfusion/gofusion/common/utils"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/config"
)

var (
        locker  sync.RWMutex
        routers map[string]map[string]IRouter
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov5" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov2" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov5" title="34">for name, conf := range confs </span><span class="cov4" title="13">{
                addInstance(ctx, name, conf, opt)
        }</span>
        <span class="cov5" title="34">return func() </span><span class="cov5" title="34">{
                locker.Lock()
                defer locker.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                if routers != nil </span><span class="cov3" title="12">{
                        for name, router := range routers[opt.AppName] </span><span class="cov4" title="13">{
                                log.Printf("%v [Gofusion] %s %s %s exiting...", pid, app, config.ComponentCron, name)
                                if err := router.shutdown(); err == nil </span><span class="cov4" title="13">{
                                        log.Printf("%v [Gofusion] %s %s %s exited", pid, app, config.ComponentCron, name)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("%v [Gofusion] %s %s %s exit failed: %s", pid, app, config.ComponentCron, name, err)
                                }</span>
                        }
                        <span class="cov3" title="12">delete(routers, opt.AppName)</span>
                }
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov4" title="13">{
        var r IRouter
        switch conf.Type </span>{
        case schedulerTypeAsynq:<span class="cov4" title="13">
                r = newAsynq(ctx, opt.AppName, name, conf)</span>
        default:<span class="cov0" title="0">
                panic(ErrUnsupportedSchedulerType)</span>
        }

        <span class="cov4" title="13">locker.Lock()
        defer locker.Unlock()
        if routers == nil </span><span class="cov1" title="2">{
                routers = make(map[string]map[string]IRouter)
        }</span>
        <span class="cov4" title="13">if routers[opt.AppName] == nil </span><span class="cov3" title="10">{
                routers[opt.AppName] = make(map[string]IRouter)
        }</span>
        <span class="cov4" title="13">if _, ok := routers[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("duplicated cron name: %s", name))</span>
        }
        <span class="cov4" title="13">routers[opt.AppName][name] = r

        // ioc
        if opt.DI != nil </span><span class="cov4" title="13">{
                opt.DI.MustProvide(
                        func() IRouter </span><span class="cov0" title="0">{ return Use(name, AppName(opt.AppName)) }</span>,
                        di.Name(name),
                )
        }
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov9" title="1890">{
        return func(o *useOption) </span><span class="cov9" title="1822">{
                o.appName = name
        }</span>
}

func Use(name string, opts ...utils.OptionExtender) IRouter <span class="cov9" title="1889">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        routers, ok := routers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("cron router instance not found for app: %s", opt.appName))</span>
        }

        <span class="cov10" title="2003">router, ok := routers[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("cron router instance not found for name: %s", name))</span>
        }
        <span class="cov10" title="2003">return router</span>
}

func init() <span class="cov4" title="14">{
        config.AddComponent(config.ComponentCron, Construct)
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package cron

import (
        "context"
        "fmt"
        "log"
        "syscall"

        "github.com/wfusion/gofusion/config"
)

func (a *asynqRouter) debug(ctx context.Context, msg string, args ...any) <span class="cov8" title="42">{
        msg = a.format(msg)
        if a.logger == nil </span><span class="cov0" title="0">{
                log.Printf(msg, args...)
        }</span> else<span class="cov8" title="41"> {
                logArgs := make([]any, 0, len(args)+2)
                logArgs = append(logArgs, ctx, msg)
                logArgs = append(logArgs, args...)
                a.logger.Debug(logArgs...)
        }</span>
}

func (a *asynqRouter) info(ctx context.Context, msg string, args ...any) <span class="cov7" title="34">{
        msg = a.format(msg)
        if a.logger == nil </span><span class="cov0" title="0">{
                log.Printf(msg, args...)
        }</span> else<span class="cov7" title="34"> {
                logArgs := make([]any, 0, len(args)+2)
                logArgs = append(logArgs, ctx, msg)
                logArgs = append(logArgs, args...)
                a.logger.Info(logArgs...)
        }</span>
}

func (a *asynqRouter) warn(ctx context.Context, msg string, args ...any) <span class="cov6" title="20">{
        msg = a.format(msg)
        if a.logger == nil </span><span class="cov0" title="0">{
                log.Printf(msg, args...)
        }</span> else<span class="cov6" title="20"> {
                logArgs := make([]any, 0, len(args)+2)
                logArgs = append(logArgs, ctx, msg)
                logArgs = append(logArgs, args...)
                a.logger.Warn(logArgs...)
        }</span>
}

func (a *asynqRouter) format(src string) (dst string) <span class="cov10" title="96">{
        return fmt.Sprintf("%v [Gofusion] %s %s asynq(%s) %s",
                syscall.Getpid(), config.ComponentCron, a.n, a.id, src)
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package cron

import (
        "context"
        "reflect"
        "time"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/log"
)

const (
        ErrLockInstanceNotFound     utils.Error = "cron lock instance not found"
        ErrUnsupportedSchedulerType utils.Error = "unsupported cron scheduler type"

        errDiscardMessage     utils.Error = "discard message"
        tolerantOfTimeNotSync             = 5 * time.Second
)

var (
        customLoggerType = reflect.TypeOf((*customLogger)(nil)).Elem()
)

type IRouter interface {
        Use(mws ...routerMiddleware)
        Handle(pattern string, fn any, opts ...utils.OptionExtender)
        Serve() error
        Start() error
        shutdown() error
}

type Task interface {
        ID() string
        Name() string
        Payload() []byte
        RawMessage() any
}

// Conf conf
//nolint: revive // struct tag too long issue
type Conf struct {
        Type                 schedulerType        `yaml:"type" json:"type" toml:"type" default:"asynq"`
        Instance             string               `yaml:"instance" json:"instance" toml:"instance"`
        InstanceType         instanceType         `yaml:"instance_type" json:"instance_type" toml:"instance_type"`
        LockInstance         string               `yaml:"lock_instance" json:"lock_instance" toml:"lock_instance"`
        Queue                string               `yaml:"queue" json:"queue" toml:"queue"`
        Server               bool                 `yaml:"server" json:"server" toml:"server" default:"true"`
        Trigger              bool                 `yaml:"trigger" json:"trigger" toml:"trigger" default:"false"`
        ServerConcurrency    int                  `yaml:"server_concurrency" json:"server_concurrency" toml:"server_concurrency"`
        Timezone             string               `yaml:"timezone" json:"timezone" toml:"timezone" default:"Asia/Shanghai"`
        Tasks                map[string]*taskConf `yaml:"tasks" json:"tasks" toml:"tasks"`
        TaskLoader           string               `yaml:"task_loader" json:"task_loader" toml:"task_loader"`
        RefreshTasksInterval string               `yaml:"refresh_tasks_interval" json:"refresh_tasks_interval" toml:"refresh_tasks_interval" default:"3m"`

        EnableLogger bool   `yaml:"enable_logger" json:"enable_logger" toml:"enable_logger" default:"false"`
        LogLevel     string `yaml:"log_level" json:"log_level" toml:"log_level" default:"info"`
        Logger       string `yaml:"logger" json:"logger" toml:"logger" default:"github.com/wfusion/gofusion/log/customlogger.cronLogger"`
        LogInstance  string `yaml:"log_instance" json:"log_instance" toml:"log_instance" default:"default"`
}

type schedulerType string

const (
        schedulerTypeAsynq schedulerType = "asynq"
)

type instanceType string

const (
        instanceTypeRedis instanceType = "redis"
        instanceTypeMysql instanceType = "mysql"
)

type routerHandleFunc func(ctx context.Context, task Task) (err error)

type routerMiddleware func(next routerHandleFunc) routerHandleFunc

type taskConf struct {
        Crontab  string `yaml:"crontab" json:"crontab" toml:"crontab"`
        Callback string `yaml:"callback" json:"callback" toml:"callback"`
        Payload  string `yaml:"payload" json:"payload" toml:"payload"`
        Retry    int    `yaml:"retry" json:"retry" toml:"retry"`
        Timeout  string `yaml:"timeout" json:"timeout" toml:"timeout"`
        Deadline string `yaml:"deadline" json:"deadline" toml:"deadline"`
}

type task struct {
        id, name   string
        payload    []byte
        rawMessage any
}

func (t *task) ID() string <span class="cov0" title="0">{
        return t.id
}</span>

func (t *task) Name() string <span class="cov10" title="23">{
        return t.name
}</span>

func (t *task) Payload() []byte <span class="cov0" title="0">{
        return t.payload
}</span>

func (t *task) RawMessage() any <span class="cov0" title="0">{
        return t.rawMessage
}</span>

type customLogger interface {
        Init(log log.Logable, appName, name string)
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package callbacks

import (
        "reflect"
        "strings"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/utils"

        comUtl "github.com/wfusion/gofusion/common/utils"

        . "gorm.io/driver/mysql"
)

func CreateAutoIncr(db *gorm.DB, gormDialector gorm.Dialector, autoIncrIncr int64) <span class="cov0" title="0">{
        withReturning := false
        dialector := gormDialector.(*Dialector)
        if !dialector.Config.SkipInitializeWithVersion &amp;&amp; strings.Contains(dialector.ServerVersion, "MariaDB") </span><span class="cov0" title="0">{
                withReturning = checkVersion(dialector.ServerVersion, "10.5")
        }</span>

        <span class="cov0" title="0">lastInsertIDReversed := false
        if !dialector.Config.DisableWithReturning &amp;&amp; withReturning </span><span class="cov0" title="0">{
                lastInsertIDReversed = true
        }</span>

        <span class="cov0" title="0">comUtl.MustSuccess(
                db.Callback().Create().Replace("gorm:create", func(db *gorm.DB) </span><span class="cov0" title="0">{
                        if db.Error != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">BuildCreateSQL(db)

                        isDryRun := !db.DryRun &amp;&amp; db.Error == nil
                        if !isDryRun </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">ok, mode := hasReturning(db, utils.Contains(db.Callback().Create().Clauses, "RETURNING"))
                        if ok </span><span class="cov0" title="0">{
                                if c, ok := db.Statement.Clauses["ON CONFLICT"]; ok </span><span class="cov0" title="0">{
                                        if onConflict, _ := c.Expression.(clause.OnConflict); onConflict.DoNothing </span><span class="cov0" title="0">{
                                                mode |= gorm.ScanOnConflictDoNothing
                                        }</span>
                                }

                                <span class="cov0" title="0">rows, err := db.Statement.ConnPool.QueryContext(
                                        db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...,
                                )
                                if db.AddError(err) == nil </span><span class="cov0" title="0">{
                                        defer func() </span><span class="cov0" title="0">{ _ = db.AddError(rows.Close()) }</span>()
                                        <span class="cov0" title="0">gorm.Scan(rows, db, mode)</span>
                                }

                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">result, err := db.Statement.ConnPool.ExecContext(
                                db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                _ = db.AddError(err)
                                return
                        }</span>

                        <span class="cov0" title="0">db.RowsAffected, _ = result.RowsAffected()
                        if db.RowsAffected != 0 &amp;&amp; db.Statement.Schema != nil &amp;&amp;
                                db.Statement.Schema.PrioritizedPrimaryField != nil &amp;&amp;
                                db.Statement.Schema.PrioritizedPrimaryField.HasDefaultValue </span><span class="cov0" title="0">{
                                insertID, err := result.LastInsertId()
                                insertOk := err == nil &amp;&amp; insertID &gt; 0
                                if !insertOk </span><span class="cov0" title="0">{
                                        _ = db.AddError(err)
                                        return
                                }</span>

                                <span class="cov0" title="0">switch db.Statement.ReflectValue.Kind() </span>{
                                case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                                        if lastInsertIDReversed </span><span class="cov0" title="0">{
                                                for i := db.Statement.ReflectValue.Len() - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                                        rv := db.Statement.ReflectValue.Index(i)
                                                        if reflect.Indirect(rv).Kind() != reflect.Struct </span><span class="cov0" title="0">{
                                                                break</span>
                                                        }

                                                        <span class="cov0" title="0">_, isZero := db.Statement.Schema.PrioritizedPrimaryField.ValueOf(db.Statement.Context, rv)
                                                        if isZero </span><span class="cov0" title="0">{
                                                                _ = db.AddError(db.Statement.Schema.PrioritizedPrimaryField.Set(db.Statement.Context, rv, insertID))
                                                                //insertID -= db.Statement.Schema.PrioritizedPrimaryField.AutoIncrementIncrement
                                                                insertID -= autoIncrIncr
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                for i := 0; i &lt; db.Statement.ReflectValue.Len(); i++ </span><span class="cov0" title="0">{
                                                        rv := db.Statement.ReflectValue.Index(i)
                                                        if reflect.Indirect(rv).Kind() != reflect.Struct </span><span class="cov0" title="0">{
                                                                break</span>
                                                        }

                                                        <span class="cov0" title="0">if _, isZero := db.Statement.Schema.PrioritizedPrimaryField.ValueOf(db.Statement.Context, rv); isZero </span><span class="cov0" title="0">{
                                                                _ = db.AddError(db.Statement.Schema.PrioritizedPrimaryField.Set(db.Statement.Context, rv, insertID))
                                                                //insertID += db.Statement.Schema.PrioritizedPrimaryField.AutoIncrementIncrement
                                                                insertID += autoIncrIncr
                                                        }</span>
                                                }
                                        }
                                case reflect.Struct:<span class="cov0" title="0">
                                        _, isZero := db.Statement.Schema.PrioritizedPrimaryField.ValueOf(db.Statement.Context, db.Statement.ReflectValue)
                                        if isZero </span><span class="cov0" title="0">{
                                                _ = db.AddError(db.Statement.Schema.PrioritizedPrimaryField.Set(db.Statement.Context, db.Statement.ReflectValue, insertID))
                                        }</span>
                                }
                        }
                }),
        )
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package callbacks

import (
        "reflect"

        "gorm.io/gorm"
        "gorm.io/gorm/callbacks"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"
        "gorm.io/gorm/utils"

        "github.com/wfusion/gofusion/db/softdelete"
)

func BuildQuerySQL(db *gorm.DB) <span class="cov9" title="625">{
        callbacks.BuildQuerySQL(db)
}</span>

func BuildCreateSQL(db *gorm.DB) <span class="cov0" title="0">{
        supportReturning := utils.Contains(db.Callback().Create().Clauses, "RETURNING")
        if db.Statement.Schema != nil </span><span class="cov0" title="0">{
                if !db.Statement.Unscoped </span><span class="cov0" title="0">{
                        for _, c := range db.Statement.Schema.CreateClauses </span><span class="cov0" title="0">{
                                db.Statement.AddClause(c)
                        }</span>
                }

                <span class="cov0" title="0">if supportReturning &amp;&amp; len(db.Statement.Schema.FieldsWithDefaultDBValue) &gt; 0 </span><span class="cov0" title="0">{
                        if _, ok := db.Statement.Clauses["RETURNING"]; !ok </span><span class="cov0" title="0">{
                                fromColumns := make([]clause.Column, 0, len(db.Statement.Schema.FieldsWithDefaultDBValue))
                                for _, field := range db.Statement.Schema.FieldsWithDefaultDBValue </span><span class="cov0" title="0">{
                                        fromColumns = append(fromColumns, clause.Column{Name: field.DBName})
                                }</span>
                                <span class="cov0" title="0">db.Statement.AddClause(clause.Returning{Columns: fromColumns})</span>
                        }
                }
        }

        <span class="cov0" title="0">if db.Statement.SQL.Len() == 0 </span><span class="cov0" title="0">{
                db.Statement.SQL.Grow(180)
                db.Statement.AddClauseIfNotExists(clause.Insert{})
                db.Statement.AddClause(callbacks.ConvertToCreateValues(db.Statement))

                db.Statement.Build(db.Statement.BuildClauses...)
        }</span>
}

func BuildUpdateSQL(db *gorm.DB) <span class="cov4" title="10">{
        if db.Statement.Schema != nil </span><span class="cov4" title="10">{
                for _, c := range db.Statement.Schema.UpdateClauses </span><span class="cov5" title="25">{
                        db.Statement.AddClause(c)
                }</span>
        }

        <span class="cov4" title="10">if db.Statement.SQL.Len() == 0 </span><span class="cov4" title="10">{
                db.Statement.SQL.Grow(180)
                db.Statement.AddClauseIfNotExists(clause.Update{})
                if _, ok := db.Statement.Clauses["SET"]; !ok </span><span class="cov4" title="10">{
                        if set := callbacks.ConvertToAssignments(db.Statement); len(set) != 0 </span><span class="cov4" title="10">{
                                db.Statement.AddClause(set)
                        }</span> else<span class="cov0" title="0"> {
                                return
                        }</span>
                }

                <span class="cov4" title="10">db.Statement.Build(db.Statement.BuildClauses...)</span>
        }
}

func BuildDeleteSQL(db *gorm.DB) <span class="cov10" title="760">{
        if db.Statement.Schema != nil </span><span class="cov10" title="760">{
                for _, c := range db.Statement.Schema.DeleteClauses </span><span class="cov8" title="195">{
                        db.Statement.AddClause(c)
                }</span>
        }

        <span class="cov9" title="757">if db.Statement.SQL.Len() &gt; 0 </span><span class="cov7" title="95">{
                return
        }</span>

        <span class="cov9" title="662">stmt := db.Statement
        stmt.SQL.Grow(180)
        if softdelete.IsClausesWithSoftDelete(db.Statement.Clauses) </span><span class="cov3" title="5">{
                stmt.AddClauseIfNotExists(clause.Update{})

                if stmt.Schema != nil </span><span class="cov3" title="5">{
                        _, queryValues := schema.GetIdentityFieldValuesMap(stmt.Context, stmt.ReflectValue, stmt.Schema.PrimaryFields)
                        column, values := schema.ToQueryValues(stmt.Table, stmt.Schema.PrimaryFieldDBNames, queryValues)

                        if len(values) &gt; 0 </span><span class="cov3" title="5">{
                                stmt.AddClause(clause.Where{Exprs: []clause.Expression{clause.IN{Column: column, Values: values}}})
                        }</span>

                        <span class="cov3" title="5">if stmt.ReflectValue.CanAddr() &amp;&amp; stmt.Dest != stmt.Model &amp;&amp; stmt.Model != nil </span><span class="cov0" title="0">{
                                _, queryValues = schema.GetIdentityFieldValuesMap(stmt.Context, reflect.ValueOf(stmt.Model), stmt.Schema.PrimaryFields)
                                column, values = schema.ToQueryValues(stmt.Table, stmt.Schema.PrimaryFieldDBNames, queryValues)

                                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                        stmt.AddClause(clause.Where{Exprs: []clause.Expression{clause.IN{Column: column, Values: values}}})
                                }</span>
                        }
                }

                <span class="cov3" title="5">stmt.AddClauseIfNotExists(clause.From{})
                stmt.Build(stmt.DB.Callback().Update().Clauses...)</span>
        } else<span class="cov9" title="660"> {
                stmt.AddClauseIfNotExists(clause.Delete{})

                if stmt.Schema != nil </span><span class="cov9" title="660">{
                        _, queryValues := schema.GetIdentityFieldValuesMap(stmt.Context, stmt.ReflectValue, stmt.Schema.PrimaryFields)
                        column, values := schema.ToQueryValues(stmt.Table, stmt.Schema.PrimaryFieldDBNames, queryValues)

                        if len(values) &gt; 0 </span><span class="cov9" title="644">{
                                stmt.AddClause(clause.Where{Exprs: []clause.Expression{clause.IN{Column: column, Values: values}}})
                        }</span>

                        <span class="cov9" title="660">if stmt.ReflectValue.CanAddr() &amp;&amp; stmt.Dest != stmt.Model &amp;&amp; stmt.Model != nil </span><span class="cov3" title="5">{
                                _, queryValues = schema.GetIdentityFieldValuesMap(stmt.Context, reflect.ValueOf(stmt.Model), stmt.Schema.PrimaryFields)
                                column, values = schema.ToQueryValues(stmt.Table, stmt.Schema.PrimaryFieldDBNames, queryValues)

                                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                        stmt.AddClause(clause.Where{Exprs: []clause.Expression{clause.IN{Column: column, Values: values}}})
                                }</span>
                        }
                }

                <span class="cov9" title="659">stmt.AddClauseIfNotExists(clause.From{})
                stmt.Build(stmt.BuildClauses...)</span>
        }
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package callbacks

import (
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/utils"

        "github.com/wfusion/gofusion/db/softdelete"

        comUtl "github.com/wfusion/gofusion/common/utils"
)

func SoftDelete(db *gorm.DB) <span class="cov6" title="62">{
        // update callback
        comUtl.MustSuccess(db.Callback().Update().Replace("gorm:update", func(db *gorm.DB) </span><span class="cov4" title="10">{
                if db.Error != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov4" title="10">BuildUpdateSQL(db)
                checkMissingWhereConditions(db)

                if !db.DryRun &amp;&amp; db.Error == nil </span><span class="cov4" title="10">{
                        if ok, mode := hasReturning(db, utils.Contains(db.Callback().Update().Clauses, "RETURNING")); ok </span><span class="cov0" title="0">{
                                if rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...); db.AddError(err) == nil </span><span class="cov0" title="0">{
                                        dest := db.Statement.Dest
                                        db.Statement.Dest = db.Statement.ReflectValue.Addr().Interface()
                                        gorm.Scan(rows, db, mode)
                                        db.Statement.Dest = dest
                                        _ = db.AddError(rows.Close())
                                }</span>
                        } else<span class="cov4" title="10"> {
                                result, err := db.Statement.ConnPool.ExecContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)

                                if db.AddError(err) == nil </span><span class="cov4" title="10">{
                                        db.RowsAffected, _ = result.RowsAffected()
                                }</span>
                        }
                }
        }))

        // delete callback
        <span class="cov6" title="62">comUtl.MustSuccess(db.Callback().Delete().Replace("gorm:delete", func(db *gorm.DB) </span><span class="cov9" title="705">{
                if db.Error != nil </span><span class="cov3" title="5">{
                        return
                }</span>

                <span class="cov9" title="700">BuildDeleteSQL(db)
                checkMissingWhereConditions(db)

                if !db.DryRun &amp;&amp; db.Error == nil </span><span class="cov9" title="700">{
                        ok, mode := hasReturning(db, utils.Contains(db.Callback().Delete().Clauses, "RETURNING"))
                        if !ok </span><span class="cov9" title="700">{
                                result, err := db.Statement.ConnPool.ExecContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...)
                                if db.AddError(err) == nil </span><span class="cov9" title="700">{
                                        db.RowsAffected, _ = result.RowsAffected()
                                }</span>

                                <span class="cov9" title="700">return</span>
                        }

                        <span class="cov0" title="0">if rows, err := db.Statement.ConnPool.QueryContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...); db.AddError(err) == nil </span><span class="cov0" title="0">{
                                gorm.Scan(rows, db, mode)
                                _ = db.AddError(rows.Close())
                        }</span>
                }
        }))

        <span class="cov6" title="62">return</span>
}

func checkMissingWhereConditions(db *gorm.DB) <span class="cov9" title="709">{
        if !db.AllowGlobalUpdate &amp;&amp; db.Error == nil </span><span class="cov9" title="709">{
                where, withCondition := db.Statement.Clauses["WHERE"]
                if withCondition </span><span class="cov9" title="709">{
                        if softdelete.IsClausesWithSoftDelete(db.Statement.Clauses) </span><span class="cov6" title="50">{
                                whereClause, _ := where.Expression.(clause.Where)
                                withCondition = len(whereClause.Exprs) &gt; 1
                        }</span>
                }
                <span class="cov10" title="710">if !withCondition </span><span class="cov0" title="0">{
                        _ = db.AddError(gorm.ErrMissingWhereClause)
                }</span>
                <span class="cov10" title="710">return</span>
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package db

import (
        "context"
        "fmt"
        "math"
        "reflect"
        "strings"

        "github.com/pkg/errors"
        "gorm.io/gorm"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/log"
)

type scanOption struct {
        dbName string

        cursors       []any
        cursorWhere   any
        cursorColumns []string

        where           any
        sqlAndArguments []any

        order any

        batch int
        limit int

        log log.Logable
}

type scanOptionGeneric[T any, TS ~[]*T] struct {
        dal DalInterface[T, TS]
}

func ScanDAL[T any, TS ~[]*T](dal DalInterface[T, TS]) utils.OptionFunc[scanOptionGeneric[T, TS]] <span class="cov4" title="5">{
        return func(o *scanOptionGeneric[T, TS]) </span><span class="cov4" title="5">{
                o.dal = dal
        }</span>
}

func ScanUse(dbName string) utils.OptionFunc[scanOption] <span class="cov0" title="0">{
        return func(o *scanOption) </span><span class="cov0" title="0">{
                o.dbName = dbName
        }</span>
}

func ScanWhere(where any, sqlAndArguments ...any) utils.OptionFunc[scanOption] <span class="cov0" title="0">{
        return func(o *scanOption) </span><span class="cov0" title="0">{
                o.where = where
                o.sqlAndArguments = sqlAndArguments
        }</span>
}

func ScanCursor(cursorWhere any, cursorColumns []string, cursors ...any) utils.OptionFunc[scanOption] <span class="cov4" title="5">{
        return func(o *scanOption) </span><span class="cov4" title="5">{
                o.cursors = cursors
                o.cursorWhere = cursorWhere
                o.cursorColumns = cursorColumns
        }</span>
}

func ScanOrder(order any) utils.OptionFunc[scanOption] <span class="cov4" title="5">{
        return func(o *scanOption) </span><span class="cov4" title="5">{
                o.order = order
        }</span>
}

func ScanBatch(batch int) utils.OptionFunc[scanOption] <span class="cov4" title="5">{
        return func(o *scanOption) </span><span class="cov4" title="5">{
                o.batch = batch
        }</span>
}

func ScanLimit(limit int) utils.OptionFunc[scanOption] <span class="cov0" title="0">{
        return func(o *scanOption) </span><span class="cov0" title="0">{
                o.limit = limit
        }</span>
}

func ScanLog(log log.Logable) utils.OptionFunc[scanOption] <span class="cov0" title="0">{
        return func(o *scanOption) </span><span class="cov0" title="0">{
                o.log = log
        }</span>
}

func Scan[T any, TS ~[]*T](ctx context.Context, cb func(TS) bool, opts ...utils.OptionExtender) (err error) <span class="cov4" title="5">{
        var (
                tx    *gorm.DB
                mList TS
        )

        o := utils.ApplyOptions[useOption](opts...)
        opt := utils.ApplyOptions[scanOption](opts...)
        optG := utils.ApplyOptions[scanOptionGeneric[T, TS]](opts...)

        // get db instance
        switch </span>{
        case optG.dal != nil:<span class="cov4" title="5">
                tx = optG.dal.ReadDB(ctx)</span>
        case opt.dbName != "":<span class="cov0" title="0">
                tx = Use(ctx, opt.dbName, AppName(o.appName)).GetProxy()</span>
        default:<span class="cov0" title="0">
                panic(errors.New("unknown which table to scan"))</span>
        }

        // default values
        <span class="cov4" title="5">if opt.cursors == nil </span><span class="cov0" title="0">{
                opt.cursors = []any{0}
        }</span>
        <span class="cov4" title="5">if opt.cursorWhere == nil </span><span class="cov0" title="0">{
                opt.cursorWhere = "id &gt; ?"
        }</span>
        <span class="cov4" title="5">if len(opt.cursorColumns) == 0 </span><span class="cov0" title="0">{
                opt.cursorColumns = []string{"id"}
        }</span>
        <span class="cov4" title="5">if opt.order == nil </span><span class="cov0" title="0">{
                opt.order = fmt.Sprintf("%s ASC", strings.Join(opt.cursorColumns, constant.Comma))
        }</span>
        <span class="cov4" title="5">if opt.batch == 0 </span><span class="cov0" title="0">{
                opt.batch = 100
        }</span>
        <span class="cov4" title="5">if opt.limit == 0 </span><span class="cov4" title="5">{
                opt.limit = math.MaxInt
        }</span>

        <span class="cov4" title="5">count := 0
        tx = tx.WithContext(ctx)
        if opt.log != nil </span><span class="cov0" title="0">{
                opt.log.Info(ctx, "scan begin [where[%s][%+v] cursor[%s][%+v] order[%s] limit[%v] batch[%v]]",
                        opt.where, opt.sqlAndArguments, opt.cursorWhere, opt.cursors, opt.order, opt.limit, opt.batch)

                defer func() </span><span class="cov0" title="0">{ opt.log.Info(ctx, "scan end [count[%v]]", count) }</span>()
        }

        // scan
        <span class="cov4" title="5">for hasMore := true; hasMore; hasMore = len(mList) &gt;= opt.batch </span><span class="cov6" title="15">{
                // init model slice
                mList = make(TS, 0, opt.batch)

                // db query
                q := tx.Where(opt.cursorWhere, opt.cursors...)
                if opt.where != nil </span><span class="cov0" title="0">{
                        q = q.Where(opt.where, opt.sqlAndArguments...)
                }</span>
                <span class="cov6" title="15">if opt.order != nil </span><span class="cov6" title="15">{
                        q = q.Order(opt.order)
                }</span>
                <span class="cov6" title="15">if err = q.Limit(opt.batch).Find(&amp;mList).Error; err != nil </span><span class="cov0" title="0">{
                        if opt.log != nil </span><span class="cov0" title="0">{
                                opt.log.Warn(ctx, "scan quit because meet with error [err[%s]]", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov6" title="15">if len(mList) &gt; 0 </span><span class="cov6" title="15">{
                        // callback
                        if !cb(mList) </span><span class="cov0" title="0">{
                                if opt.log != nil </span><span class="cov0" title="0">{
                                        opt.log.Info(ctx, "scan quit because callback return false")
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }

                        // get next cursor
                        <span class="cov6" title="15">next := mList[len(mList)-1]
                        nextVal := reflect.Indirect(reflect.ValueOf(next))
                        for idx, col := range opt.cursorColumns </span><span class="cov6" title="15">{
                                fieldVal := nextVal.FieldByNameFunc(func(s string) bool </span><span class="cov10" title="75">{ return strings.EqualFold(s, col) }</span>)
                                <span class="cov6" title="15">if !fieldVal.IsValid() </span><span class="cov0" title="0">{
                                        fieldVal, _ = utils.GetGormColumnValue(next, col)
                                }</span>
                                <span class="cov6" title="15">if !fieldVal.IsValid() </span><span class="cov0" title="0">{
                                        err = errors.Errorf("scan cursor column value is not found [col[%s]]", col)
                                        if opt.log != nil </span><span class="cov0" title="0">{
                                                opt.log.Error(ctx, "%s", err)
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }
                                <span class="cov6" title="15">opt.cursors[idx] = fieldVal.Interface()</span>
                        }
                }

                // check if exceed max
                <span class="cov6" title="15">if count += len(mList); count &gt;= opt.limit </span><span class="cov0" title="0">{
                        if opt.log != nil </span><span class="cov0" title="0">{
                                opt.log.Info(ctx, "scan quit because reach max [count[%v] max[%v]]", count, opt.limit)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov4" title="5">return</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package db

import (
        "context"
        "log"
        "reflect"
        "sync"
        "syscall"

        "github.com/PaesslerAG/gval"
        "github.com/pkg/errors"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/infra/drivers/orm"
        "github.com/wfusion/gofusion/common/infra/drivers/orm/idgen"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/gomonkey"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/db/callbacks"
        "github.com/wfusion/gofusion/db/plugins"
        "github.com/wfusion/gofusion/db/softdelete"
        fmkLog "github.com/wfusion/gofusion/log"

        _ "github.com/wfusion/gofusion/log/customlogger"
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov7" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov3" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov7" title="34">for name, conf := range confs </span><span class="cov8" title="62">{
                addInstance(ctx, name, conf, opt)
        }</span>
        // patch delete at
        <span class="cov7" title="34">patches := make([]*gomonkey.Patches, 0, len(confs))
        patches = append(patches, softdelete.PatchGormDeleteAt())

        return func() </span><span class="cov7" title="34">{
                rwlock.Lock()
                defer rwlock.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                if appInstances != nil </span><span class="cov6" title="23">{
                        for _, instance := range appInstances[opt.AppName] </span><span class="cov8" title="62">{
                                if sqlDB, err := instance.GetProxy().DB(); err == nil </span><span class="cov8" title="62">{
                                        if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("%v [Gofusion] %s %s close error: %s", pid, app, config.ComponentDB, err)
                                        }</span>
                                }
                        }
                        <span class="cov6" title="23">delete(appInstances, opt.AppName)</span>
                }
                <span class="cov7" title="34">if len(appInstances) == 0 </span><span class="cov6" title="32">{
                        for _, patch := range patches </span><span class="cov6" title="32">{
                                if patch != nil </span><span class="cov0" title="0">{
                                        patch.Reset()
                                }</span>
                        }
                        <span class="cov6" title="32">softdelete.PatchGormDeleteAtOnce = new(sync.Once)</span>
                }
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov8" title="62">{
        var logObj logger.Interface
        if !config.Use(opt.AppName).Debug() &amp;&amp; utils.IsStrNotBlank(conf.LoggerConfig.Logger) </span><span class="cov7" title="55">{
                loggerType := inspect.TypeOf(conf.LoggerConfig.Logger)
                loggerValue := reflect.New(loggerType)
                if loggerValue.Type().Implements(customLoggerType) </span><span class="cov7" title="55">{
                        l := fmkLog.Use(conf.LoggerConfig.LogInstance, fmkLog.AppName(opt.AppName))
                        loggerValue.Interface().(customLogger).Init(l, opt.AppName, name)
                }</span>
                <span class="cov7" title="55">logObj = loggerValue.Interface().(logger.Interface)</span>
        }

        // conf.Option.Password = config.CryptoDecryptFunc()(conf.Option.Password)
        <span class="cov8" title="62">db, err := orm.Gorm.New(ctx, conf.Option, orm.WithLogger(logObj))
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("initialize gorm db instance error: %+v", err))</span>
        }

        <span class="cov8" title="62">adaptMysqlAutoIncrementIncrement(db, conf)
        mysqlSoftDelete(db, conf)
        if config.Use(opt.AppName).Debug() </span><span class="cov4" title="7">{
                db.DB = db.Debug()
        }</span>

        // sharding
        <span class="cov8" title="62">tablePluginMap := make(map[string]plugins.TableSharding, len(conf.Sharding))
        for _, shardConf := range conf.Sharding </span><span class="cov10" title="188">{
                var generator idgen.Generator
                if utils.IsStrNotBlank(shardConf.IDGen) </span><span class="cov10" title="188">{
                        generator = (*(*func() idgen.Generator)(inspect.FuncOf(shardConf.IDGen)))()
                }</span>

                <span class="cov10" title="188">var expression gval.Evaluable
                if utils.IsStrNotBlank(shardConf.ShardingKeyExpr) </span><span class="cov7" title="36">{
                        expression = utils.Must(gval.Full().NewEvaluable(shardConf.ShardingKeyExpr))
                }</span>

                <span class="cov10" title="188">tableShardingPlugin := plugins.DefaultTableSharding(plugins.TableShardingConfig{
                        Database:                 name,
                        Table:                    shardConf.Table,
                        ShardingKeys:             shardConf.Columns,
                        ShardingKeyExpr:          expression,
                        ShardingKeyByRawValue:    shardConf.ShardingKeyByRawValue,
                        ShardingKeysForMigrating: shardConf.ShardingKeysForMigrating,
                        NumberOfShards:           shardConf.NumberOfShards,
                        CustomSuffix:             shardConf.Suffix,
                        PrimaryKeyGenerator:      generator,
                })

                utils.MustSuccess(db.Use(tableShardingPlugin))
                tablePluginMap[shardConf.Table] = tableShardingPlugin</span>
        }

        <span class="cov8" title="62">rwlock.Lock()
        defer rwlock.Unlock()
        if appInstances == nil </span><span class="cov4" title="6">{
                appInstances = make(map[string]map[string]*Instance)
        }</span>
        <span class="cov8" title="62">if appInstances[opt.AppName] == nil </span><span class="cov6" title="21">{
                appInstances[opt.AppName] = make(map[string]*Instance)
        }</span>
        <span class="cov8" title="62">if _, ok := appInstances[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedName)</span>
        }
        <span class="cov8" title="62">appInstances[opt.AppName][name] = &amp;Instance{db: db, name: name, tableShardingPlugins: tablePluginMap}

        // ioc
        if opt.DI != nil </span><span class="cov8" title="62">{
                opt.DI.MustProvide(
                        func() *gorm.DB </span><span class="cov0" title="0">{
                                rwlock.RLock()
                                defer rwlock.RUnlock()
                                return appInstances[opt.AppName][name].GetProxy()
                        }</span>,
                        di.Name(name),
                )
        }

        <span class="cov8" title="62">go startDaemonRoutines(ctx, opt.AppName, name, conf)</span>
}

// adaptAutoIncrementIncrement patch gorm schema parse method to enable changing autoIncrementIncrement in runtime
// see also: https://github.com/go-gorm/gorm/issues/5814
func adaptMysqlAutoIncrementIncrement(db *orm.DB, conf *Conf) <span class="cov8" title="62">{
        autoIncrIncr := conf.AutoIncrementIncrement
        // unset, query auto increment increment
        if autoIncrIncr == 0 &amp;&amp; conf.Driver == orm.DriverMysql </span><span class="cov7" title="35">{
                type autoConfig struct {
                        VariableName string `gorm:"column:Variable_name"`
                        Value        int64  `gorm:"column:Value"`
                }

                var cfg *autoConfig
                db.WithContext(context.Background()).
                        Raw("show variables like 'auto_increment_increment'").
                        Scan(&amp;cfg)
                autoIncrIncr = cfg.Value
        }</span>
        // no need to replace callbacks
        <span class="cov8" title="62">if autoIncrIncr &lt;= 1 </span><span class="cov8" title="62">{
                return
        }</span>

        <span class="cov0" title="0">callbacks.CreateAutoIncr(db.GetProxy(), db.GetDialector(), autoIncrIncr)</span>
}

func mysqlSoftDelete(db *orm.DB, conf *Conf) <span class="cov8" title="62">{
        callbacks.SoftDelete(db.GetProxy())
}</span>

func init() <span class="cov5" title="14">{
        config.AddComponent(config.ComponentDB, Construct)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package db

import (
        "context"

        "github.com/wfusion/gofusion/common/utils"

        fmkCtx "github.com/wfusion/gofusion/context"
)

func GetCtxGormDB(ctx context.Context) *DB <span class="cov10" title="353">{
        return utils.GetCtxAny(ctx, fmkCtx.KeyGormDB, (*DB)(nil))
}</span>

func GetCtxGormDBByName(ctx context.Context, name string) (db *DB) <span class="cov3" title="5">{
        utils.TravelCtx(ctx, func(ctx context.Context) bool </span><span class="cov3" title="5">{
                db = utils.GetCtxAny(ctx, fmkCtx.KeyGormDB, (*DB)(nil))
                return db != nil &amp;&amp; db.Name == name
        }</span>)
        <span class="cov3" title="5">return</span>
}

func SetCtxGormDB(ctx context.Context, db *DB) context.Context <span class="cov5" title="15">{
        return utils.SetCtxAny(ctx, fmkCtx.KeyGormDB, db)
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package db

import (
        "context"
        "reflect"

        "github.com/pkg/errors"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/db/plugins"

        ormDrv "github.com/wfusion/gofusion/common/infra/drivers/orm"
        fmkCtx "github.com/wfusion/gofusion/context"
)

// DalInterface
//nolint: revive // interface issue
type DalInterface[T any, TS ~[]*T] interface {
        Query(ctx context.Context, query any, args ...any) (TS, error)
        QueryFirst(ctx context.Context, query any, args ...any) (*T, error)
        QueryLast(ctx context.Context, query any, args ...any) (*T, error)
        QueryInBatches(ctx context.Context, batchSize int, fc func(tx *DB, batch int, found TS) error, query any, args ...any) error
        Count(ctx context.Context, query any, args ...any) (int64, error)
        Pluck(ctx context.Context, column string, dest any, query any, args ...any) error
        Take(ctx context.Context, dest any, conds ...any) error
        InsertOne(ctx context.Context, mod *T, opts ...utils.OptionExtender) error
        InsertInBatches(ctx context.Context, modList TS, batchSize int, opts ...utils.OptionExtender) error
        Save(ctx context.Context, mod any, opts ...utils.OptionExtender) error
        Update(ctx context.Context, column string, value any, query any, args ...any) (int64, error)
        Updates(ctx context.Context, columns map[string]any, query any, args ...any) (int64, error)
        Delete(ctx context.Context, query any, args ...any) (int64, error)
        FirstOrCreate(ctx context.Context, mod *T, conds ...any) (int64, error)
        Transaction(ctx context.Context, fc func(tx context.Context) error, opts ...utils.OptionExtender) error
        ReadDB(ctx context.Context) *gorm.DB
        WriteDB(ctx context.Context) *gorm.DB
        SetCtxReadDB(src context.Context) (dst context.Context)
        SetCtxWriteDB(src context.Context) (dst context.Context)
        Model() *T
        ModelSlice() TS
        IgnoreErr(err error) error
        CanIgnore(err error) bool
        ShardingByValues(ctx context.Context, src []map[string]any) (dst map[string][]map[string]any, err error)
        ShardingIDGen(ctx context.Context) (id uint64, err error)
        ShardingIDListGen(ctx context.Context, amount int) (idList []uint64, err error)
        ShardingByModelList(ctx context.Context, src TS) (dst map[string]TS, err error)
}

type dal[T any, TS ~[]*T] struct {
        appName     string
        readDBName  string
        writeDBName string
}

func NewDAL[T any, TS ~[]*T](readDBName, writeDBName string, opts ...utils.OptionExtender) DalInterface[T, TS] <span class="cov6" title="45">{
        instance := new(T)
        if _, ok := any(instance).(schema.Tabler); !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("model unimplement schema.Tabler [model[%T] read_db[%s] write_db[%s]]",
                        instance, readDBName, writeDBName))</span>
        }
        <span class="cov6" title="45">opt := utils.ApplyOptions[useOption](opts...)
        return &amp;dal[T, TS]{
                appName:     opt.appName,
                readDBName:  readDBName,
                writeDBName: writeDBName,
        }</span>
}

func (d *dal[T, TS]) Query(ctx context.Context, query any, args ...any) (TS, error) <span class="cov0" title="0">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)

        found := d.ModelSlice()
        result := d.ReadDB(ctx).Clauses(o.clauses...).Where(query, args...).Find(&amp;found)
        if d.CanIgnore(result.Error) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return found, d.IgnoreErr(result.Error)</span>
}

func (d *dal[T, TS]) QueryLast(ctx context.Context, query any, args ...any) (*T, error) <span class="cov0" title="0">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)

        found := d.Model()
        result := d.ReadDB(ctx).Clauses(o.clauses...).Where(query, args...).Last(found)
        if d.CanIgnore(result.Error) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return found, d.IgnoreErr(result.Error)</span>
}

func (d *dal[T, TS]) QueryFirst(ctx context.Context, query any, args ...any) (*T, error) <span class="cov5" title="15">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)

        found := d.Model()
        result := d.ReadDB(ctx).Clauses(o.clauses...).Where(query, args...).First(found)
        if d.CanIgnore(result.Error) </span><span class="cov3" title="5">{
                return nil, nil
        }</span>
        <span class="cov4" title="10">return found, d.IgnoreErr(result.Error)</span>
}

func (d *dal[T, TS]) QueryInBatches(ctx context.Context, batchSize int,
        fc func(tx *DB, batch int, found TS) error, query any, args ...any) (err error) <span class="cov0" title="0">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)

        orm := Use(ctx, d.readDBName, AppName(d.appName))
        found := make(TS, 0, batchSize)
        result := d.ReadDB(ctx).Clauses(o.clauses...).Where(query, args...).FindInBatches(&amp;found, batchSize,
                func(tx *gorm.DB, batch int) error </span><span class="cov0" title="0">{
                        wrapper := &amp;DB{
                                DB:                   &amp;ormDrv.DB{DB: tx},
                                Name:                 orm.Name,
                                tableShardingPlugins: orm.tableShardingPlugins,
                        }
                        return fc(wrapper, batch, found)
                }</span>,
        )
        <span class="cov0" title="0">if d.CanIgnore(result.Error) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return d.IgnoreErr(result.Error)</span>
}

func (d *dal[T, TS]) Count(ctx context.Context, query any, args ...any) (int64, error) <span class="cov0" title="0">{
        var count int64

        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)

        result := d.ReadDB(ctx).Clauses(o.clauses...).Where(query, args...).Count(&amp;count)
        if d.CanIgnore(result.Error) </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">return count, d.IgnoreErr(result.Error)</span>
}

func (d *dal[T, TS]) Pluck(ctx context.Context, column string, dest any,
        query any, args ...any) error <span class="cov0" title="0">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)

        result := d.ReadDB(ctx).Clauses(o.clauses...).Where(query, args...).Pluck(column, dest)
        return d.IgnoreErr(result.Error)
}</span>

func (d *dal[T, TS]) Take(ctx context.Context, dest any, conds ...any) error <span class="cov0" title="0">{
        o, args := d.parseOptionFromArgs(conds...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)

        result := d.ReadDB(ctx).Clauses(o.clauses...).Take(dest, args...)
        return d.IgnoreErr(result.Error)
}</span>

func (d *dal[T, TS]) InsertOne(ctx context.Context, mod *T, opts ...utils.OptionExtender) error <span class="cov5" title="15">{
        o := utils.ApplyOptions[mysqlDALOption](opts...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)
        return d.WriteDB(ctx).Clauses(o.clauses...).Create(mod).Error
}</span>

func (d *dal[T, TS]) InsertInBatches(ctx context.Context,
        modList TS, batchSize int, opts ...utils.OptionExtender) error <span class="cov5" title="20">{
        o := utils.ApplyOptions[mysqlDALOption](opts...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)
        sharded, err := d.writeWithTableSharding(ctx, modList)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="20">for _, mList := range sharded </span><span class="cov6" title="45">{
                if err = d.WriteDB(ctx).Clauses(o.clauses...).CreateInBatches(mList, batchSize).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="20">return nil</span>
}

func (d *dal[T, TS]) FirstOrCreate(ctx context.Context, mod *T, conds ...any) (int64, error) <span class="cov0" title="0">{
        o, conds := d.parseOptionFromArgs(conds...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)
        result := d.WriteDB(ctx).Clauses(o.clauses...).FirstOrCreate(mod, conds...)
        return result.RowsAffected, result.Error
}</span>

// Save create or update model
// Only support for passing in *mod, []*mod, [...]*mod, it's recommended to only use *mod to call this method.
// If using mod, []mod, since it's value passing, the upper layer will not be able to
// obtain the auto-incremented id from create or other fields filled in by the lower layer.
// If using [...]mod, it will trigger panic: using unaddressable error.
// In official usage, both mod and [...]mod will trigger panic: using unaddressable error.
func (d *dal[T, TS]) Save(ctx context.Context, mod any, opts ...utils.OptionExtender) error <span class="cov4" title="8">{
        // Translate the struct to slice to follow the insert into with ON DUPLICATE KEY UPDATE
        mList, ok := d.convertAnyToTS(mod)
        if !ok </span><span class="cov0" title="0">{
                mList = utils.SliceConvert(mod, reflect.TypeOf(TS{})).(TS)
        }</span>
        <span class="cov4" title="8">if len(mList) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="8">o := utils.ApplyOptions[mysqlDALOption](opts...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)
        sharded, err := d.writeWithTableSharding(ctx, mList)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="8">for _, mList := range sharded </span><span class="cov5" title="20">{
                if err = d.WriteDB(ctx).Clauses(o.clauses...).Save(mList).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="8">return nil</span>
}

func (d *dal[T, TS]) Update(ctx context.Context, column string, value any,
        query any, args ...any) (int64, error) <span class="cov0" title="0">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)
        u := d.WriteDB(ctx).Clauses(o.clauses...).Where(query, args...).Update(column, value)
        return u.RowsAffected, u.Error
}</span>

func (d *dal[T, TS]) Updates(ctx context.Context, columns map[string]any,
        query any, args ...any) (int64, error) <span class="cov0" title="0">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)
        u := d.WriteDB(ctx).Clauses(o.clauses...).Where(query, args...).Updates(columns)
        return u.RowsAffected, u.Error
}</span>

func (d *dal[T, TS]) Delete(ctx context.Context, query any, args ...any) (int64, error) <span class="cov6" title="35">{
        o, args := d.parseOptionFromArgs(args...)
        ctx = context.WithValue(ctx, fmkCtx.KeyDALOption, o)
        mList, ok := d.convertAnyToTS(query)
        if !ok || len(mList) == 0 </span><span class="cov4" title="10">{
                deleted := d.WriteDB(ctx).Clauses(o.clauses...).Where(query, args...).Delete(d.Model())
                return deleted.RowsAffected, deleted.Error
        }</span> else<span class="cov6" title="25"> {
                sharded, err := d.writeWithTableSharding(ctx, mList)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov6" title="25">var rowAffected int64
                for _, mList := range sharded </span><span class="cov6" title="45">{
                        deleted := d.WriteDB(ctx).Clauses(o.clauses...).Delete(mList, args...)
                        if deleted.Error != nil </span><span class="cov0" title="0">{
                                return rowAffected, deleted.Error
                        }</span>
                        <span class="cov6" title="45">rowAffected += deleted.RowsAffected</span>
                }
                <span class="cov6" title="25">return rowAffected, nil</span>
        }
}

func (d *dal[T, TS]) Transaction(ctx context.Context, fc func(context.Context) error,
        opts ...utils.OptionExtender) error <span class="cov0" title="0">{
        orm := GetCtxGormDB(ctx)
        o := utils.ApplyOptions[mysqlDALOption](opts...)
        if orm == nil || (orm.Name != d.writeDBName &amp;&amp; orm.Name != d.readDBName) </span><span class="cov0" title="0">{
                if o.useWriteDB </span><span class="cov0" title="0">{
                        orm = Use(ctx, d.writeDBName, AppName(d.appName))
                }</span> else<span class="cov0" title="0"> {
                        orm = Use(ctx, d.readDBName, AppName(d.appName))
                }</span>
        }

        <span class="cov0" title="0">return d.unscopedGormDB(orm.GetProxy().WithContext(ctx), o).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                return fc(SetCtxGormDB(ctx, &amp;DB{
                        DB:                   &amp;ormDrv.DB{DB: tx},
                        Name:                 orm.Name,
                        tableShardingPlugins: orm.tableShardingPlugins,
                }))
        }</span>)
}

func (d *dal[T, TS]) ReadDB(ctx context.Context) *gorm.DB <span class="cov7" title="65">{
        o, _ := ctx.Value(fmkCtx.KeyDALOption).(*mysqlDALOption)
        if orm := GetCtxGormDB(ctx); orm != nil &amp;&amp; orm.Name == d.readDBName </span><span class="cov0" title="0">{
                return d.unscopedGormDB(orm.Model(d.Model()), o)
        }</span>

        <span class="cov7" title="65">dbName := d.readDBName
        if o != nil &amp;&amp; o.useWriteDB </span><span class="cov0" title="0">{
                dbName = d.writeDBName
        }</span>
        <span class="cov7" title="65">return d.unscopedGormDB(Use(ctx, dbName, AppName(d.appName)).WithContext(ctx).Model(d.Model()), o)</span>
}
func (d *dal[T, TS]) WriteDB(ctx context.Context) *gorm.DB <span class="cov9" title="230">{
        o, _ := ctx.Value(fmkCtx.KeyDALOption).(*mysqlDALOption)
        if orm := GetCtxGormDB(ctx); orm != nil &amp;&amp; orm.Name == d.writeDBName </span><span class="cov0" title="0">{
                return d.unscopedGormDB(orm.Model(d.Model()), o)
        }</span>

        <span class="cov9" title="230">return d.unscopedGormDB(Use(ctx, d.writeDBName, AppName(d.appName)).WithContext(ctx).Model(d.Model()), o)</span>
}
func (d *dal[T, TS]) SetCtxReadDB(src context.Context) (dst context.Context) <span class="cov0" title="0">{
        if orm := GetCtxGormDB(src); orm != nil &amp;&amp; orm.Name == d.readDBName </span><span class="cov0" title="0">{
                return src
        }</span>

        <span class="cov0" title="0">return SetCtxGormDB(src, Use(src, d.readDBName, AppName(d.appName)))</span>
}
func (d *dal[T, TS]) SetCtxWriteDB(src context.Context) (dst context.Context) <span class="cov0" title="0">{
        if orm := GetCtxGormDB(src); orm != nil &amp;&amp; orm.Name == d.writeDBName </span><span class="cov0" title="0">{
                return src
        }</span>
        <span class="cov0" title="0">return SetCtxGormDB(src, Use(src, d.writeDBName, AppName(d.appName)))</span>
}

func (d *dal[T, TS]) Model() *T      <span class="cov10" title="320">{ return new(T) }</span>
func (d *dal[T, TS]) ModelSlice() TS <span class="cov0" title="0">{ return make(TS, 0) }</span>
func (d *dal[T, TS]) IgnoreErr(err error) error <span class="cov4" title="10">{
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="10">return err</span>
}
func (d *dal[T, TS]) CanIgnore(err error) bool <span class="cov5" title="15">{ return errors.Is(err, gorm.ErrRecordNotFound) }</span>

func (d *dal[T, TS]) ShardingByValues(ctx context.Context, src []map[string]any) (
        dst map[string][]map[string]any, err error) <span class="cov0" title="0">{
        writeDB := d.writeDB(ctx)
        tableName := d.tableName(writeDB, new(T))
        tableShardingPlugin, ok := writeDB.tableShardingPlugins[tableName]
        if !ok </span><span class="cov0" title="0">{
                return map[string][]map[string]any{tableName: src}, nil
        }</span>
        <span class="cov0" title="0">return tableShardingPlugin.ShardingByValues(ctx, src)</span>
}
func (d *dal[T, TS]) ShardingIDGen(ctx context.Context) (id uint64, err error) <span class="cov3" title="5">{
        writeDB := d.writeDB(ctx)
        tableName := d.tableName(writeDB, new(T))
        tableShardingPlugin, ok := writeDB.tableShardingPlugins[tableName]
        if !ok </span><span class="cov0" title="0">{
                return 0, plugins.ErrIDGeneratorNotFound
        }</span>
        <span class="cov3" title="5">return tableShardingPlugin.ShardingIDGen(ctx)</span>
}
func (d *dal[T, TS]) ShardingIDListGen(ctx context.Context, amount int) (idList []uint64, err error) <span class="cov0" title="0">{
        writeDB := d.writeDB(ctx)
        tableName := d.tableName(writeDB, new(T))
        tableShardingPlugin, ok := writeDB.tableShardingPlugins[tableName]
        if !ok </span><span class="cov0" title="0">{
                return nil, plugins.ErrIDGeneratorNotFound
        }</span>
        <span class="cov0" title="0">idList = make([]uint64, 0, amount)
        for i := 0; i &lt; amount; i++ </span><span class="cov0" title="0">{
                id, err := tableShardingPlugin.ShardingIDGen(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">idList = append(idList, id)</span>
        }
        <span class="cov0" title="0">return</span>
}
func (d *dal[T, TS]) ShardingByModelList(ctx context.Context, src TS) (dst map[string]TS, err error) <span class="cov0" title="0">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return make(map[string]TS), nil
        }</span>
        <span class="cov0" title="0">writeDB := d.writeDB(ctx)
        tableName := d.tableName(writeDB, src[0])
        shardingPlugin, ok := writeDB.tableShardingPlugins[tableName]
        if !ok </span><span class="cov0" title="0">{
                return map[string]TS{tableName: src}, nil
        }</span>
        <span class="cov0" title="0">sharded, err := shardingPlugin.ShardingByModelList(ctx, utils.SliceMapping(src, func(t *T) any </span><span class="cov0" title="0">{ return t }</span>)...)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">dst = make(map[string]TS, len(sharded))
        for suffix, item := range sharded </span><span class="cov0" title="0">{
                shardingTableName := tableName + suffix
                dst[shardingTableName] = TS(utils.SliceMapping(item, func(t any) *T </span><span class="cov0" title="0">{ return t.(*T) }</span>))
        }
        <span class="cov0" title="0">return</span>
}

func (d *dal[T, TS]) writeDB(ctx context.Context) *DB <span class="cov7" title="58">{
        if orm := GetCtxGormDB(ctx); orm != nil &amp;&amp; orm.Name == d.writeDBName </span><span class="cov0" title="0">{
                return orm
        }</span>

        <span class="cov7" title="58">return Use(ctx, d.writeDBName, AppName(d.appName))</span>
}
func (d *dal[T, TS]) writeWithTableSharding(ctx context.Context, src TS) (dst []TS, err error) <span class="cov7" title="53">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov7" title="53">writeDB := d.writeDB(ctx)
        shardingPlugin, ok := writeDB.tableShardingPlugins[d.tableName(writeDB, src[0])]
        if !ok </span><span class="cov0" title="0">{
                return []TS{src}, nil
        }</span>

        <span class="cov7" title="53">sharded, err := shardingPlugin.ShardingByModelList(ctx, utils.SliceMapping(src, func(t *T) any </span><span class="cov8" title="149">{ return t }</span>)...)
        <span class="cov7" title="53">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov7" title="53">for _, item := range sharded </span><span class="cov8" title="110">{
                dst = append(dst, utils.SliceMapping(item, func(t any) *T </span><span class="cov8" title="149">{ return t.(*T) }</span>))
        }
        <span class="cov7" title="53">return</span>
}
func (d *dal[T, TS]) tableName(db *DB, mod *T) (name string) <span class="cov7" title="58">{
        if tabler, ok := any(mod).(schema.Tabler); ok </span><span class="cov7" title="58">{
                name = tabler.TableName()
        }</span>
        <span class="cov7" title="58">if tabler, ok := any(mod).(schema.TablerWithNamer); ok </span><span class="cov0" title="0">{
                name = tabler.TableName(db.NamingStrategy)
        }</span>
        // TODO: check if embeddedNamer valid
        <span class="cov7" title="58">embeddedNamer := inspect.TypeOf("gorm.io/gorm/schema.embeddedNamer")
        namingStrategy := reflect.ValueOf(db.NamingStrategy)
        if namingStrategy.CanConvert(embeddedNamer) </span><span class="cov0" title="0">{
                name = namingStrategy.Convert(embeddedNamer).FieldByName("Table").String()
        }</span>
        <span class="cov7" title="58">return</span>
}
func (d *dal[T, TS]) convertAnyToTS(query any) (mList TS, ok bool) <span class="cov6" title="43">{
        switch q := query.(type) </span>{
        case TS:<span class="cov5" title="23">
                ok = true
                mList = q</span>
        case []*T:<span class="cov0" title="0">
                ok = true
                mList = TS(q)</span>
        case []T:<span class="cov0" title="0">
                ok = true
                mList = TS(utils.SliceMapping(q, func(t T) *T </span><span class="cov0" title="0">{ return &amp;t }</span>))
        case T:<span class="cov0" title="0">
                ok = true
                mList = TS{&amp;q}</span>
        case *T:<span class="cov4" title="10">
                ok = true
                mList = TS{q}</span>
        }
        <span class="cov6" title="43">return</span>
}
func (d *dal[T, TS]) unscopedGormDB(src *gorm.DB, o *mysqlDALOption) (dst *gorm.DB) <span class="cov9" title="295">{
        if o != nil &amp;&amp; o.unscoped </span><span class="cov6" title="35">{
                return src.Unscoped()
        }</span>
        <span class="cov9" title="260">return src</span>
}

type mysqlDALOption struct {
        unscoped   bool
        useWriteDB bool
        clauses    []clause.Expression
}

func Unscoped() utils.OptionFunc[mysqlDALOption] <span class="cov5" title="20">{
        return func(m *mysqlDALOption) </span><span class="cov5" title="20">{
                m.unscoped = true
        }</span>
}

func Clauses(clauses ...clause.Expression) utils.OptionFunc[mysqlDALOption] <span class="cov0" title="0">{
        return func(m *mysqlDALOption) </span><span class="cov0" title="0">{
                m.clauses = append(m.clauses, clauses...)
        }</span>
}

func WriteDB() utils.OptionFunc[mysqlDALOption] <span class="cov0" title="0">{
        return func(m *mysqlDALOption) </span><span class="cov0" title="0">{
                m.useWriteDB = true
        }</span>
}

func (d *dal[T, TS]) parseOptionFromArgs(args ...any) (o *mysqlDALOption, r []any) <span class="cov7" title="50">{
        o = new(mysqlDALOption)
        r = make([]any, 0, len(args))
        for _, arg := range args </span><span class="cov6" title="45">{
                if reflect.TypeOf(arg).Implements(gormClauseExpressionType) </span><span class="cov0" title="0">{
                        o.clauses = append(o.clauses, arg.(clause.Expression))
                        continue</span>
                }

                <span class="cov6" title="45">switch v := arg.(type) </span>{
                case utils.OptionFunc[mysqlDALOption]:<span class="cov5" title="20">
                        v(o)</span>
                default:<span class="cov6" title="25">
                        r = append(r, arg)</span>
                }
        }
        <span class="cov7" title="50">return</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package db

import (
        "context"
        "sync"
        "time"

        "github.com/pkg/errors"
        "gorm.io/gorm"

        "github.com/wfusion/gofusion/common/infra/drivers/orm"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/db/plugins"
)

const (
        defaultSlowThreshold = 200 * time.Millisecond
)

var (
        rwlock       = new(sync.RWMutex)
        appInstances map[string]map[string]*Instance
)

type Instance struct {
        name                 string
        db                   *orm.DB
        tableShardingPlugins map[string]plugins.TableSharding
}

func (d *Instance) GetProxy() *gorm.DB <span class="cov7" title="280">{
        return d.db.GetProxy()
}</span>

type DB struct {
        *orm.DB
        Name                 string
        tableShardingPlugins map[string]plugins.TableSharding
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov9" title="4593">{
        return func(o *useOption) </span><span class="cov9" title="4350">{
                o.appName = name
        }</span>
}

func Use(ctx context.Context, name string, opts ...utils.OptionExtender) *DB <span class="cov9" title="4528">{
        opt := utils.ApplyOptions[useOption](opts...)

        rwlock.RLock()
        defer rwlock.RUnlock()
        instances, ok := appInstances[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("db instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov9" title="4651">instance, ok := instances[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("db instance not found for name: %s", name))</span>
        }

        <span class="cov10" title="4652">return &amp;DB{DB: instance.db.WithContext(ctx), Name: name, tableShardingPlugins: instance.tableShardingPlugins}</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package db

import (
        "context"
        "log"
        "syscall"
        "time"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/metrics"
)

var (
        metricsPoolIdleKey         = []string{"db", "idle"}
        metricsPoolTotalKey        = []string{"db", "total"}
        metricsPoolInUseKey        = []string{"db", "inuse"}
        metricsPoolWaitCountKey    = []string{"db", "wait", "count"}
        metricsPoolWaitDurationKey = []string{"db", "wait", "duration"}
        metricsLatencyKey          = []string{"db", "latency"}
        metricsLatencyBuckets      = []float64{
                .1, .25, .5, .75, .90, .95, .99,
                1, 2.5, 5, 7.5, 9, 9.5, 9.9,
                10, 25, 50, 75, 90, 95, 99,
        }
)

func startDaemonRoutines(ctx context.Context, appName, name string, conf *Conf) <span class="cov8" title="62">{
        ticker := time.Tick(time.Second * 5)
        app := config.Use(appName).AppName()
        labels := []metrics.Label{
                {Key: "config", Value: name},
                {Key: "database", Value: conf.DB},
        }
        for </span><span class="cov10" title="171">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="62">
                        log.Printf("%v [Gofusion] %s %s %s metrics exited",
                                syscall.Getpid(), app, config.ComponentDB, name)
                        return</span>
                case &lt;-ticker:<span class="cov9" title="109">
                        go metricDBStats(ctx, appName, name, labels)
                        go metricDBLatency(ctx, appName, name, labels)</span>
                }
        }
}

func metricDBStats(ctx context.Context, appName, name string, labels []metrics.Label) <span class="cov9" title="109">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov9" title="109"></span>

        }

        <span class="cov9" title="109">_, _ = utils.Catch(func() </span><span class="cov9" title="109">{
                rwlock.RLock()
                defer rwlock.RUnlock()

                instances, ok := appInstances[appName]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="109">instance, ok := instances[name]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="109">db := instance.GetProxy()
                sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov9" title="109">app := config.Use(appName).AppName()
                idleKey := append([]string{app}, metricsPoolIdleKey...)
                inuseKey := append([]string{app}, metricsPoolInUseKey...)
                totalKey := append([]string{app}, metricsPoolTotalKey...)
                waitCountKey := append([]string{app}, metricsPoolWaitCountKey...)
                waitDurationKey := append([]string{app}, metricsPoolWaitDurationKey...)

                stats := sqlDB.Stats()
                waitDuration := float64(stats.WaitDuration) / float64(time.Millisecond)
                for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov7" title="42">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov7" title="42">
                                if m.IsEnableServiceLabel() </span><span class="cov7" title="42">{
                                        m.SetGauge(ctx, idleKey, float64(stats.Idle), metrics.Labels(labels))
                                        m.SetGauge(ctx, inuseKey, float64(stats.InUse), metrics.Labels(labels))
                                        m.SetGauge(ctx, totalKey, float64(stats.OpenConnections), metrics.Labels(labels))
                                        m.SetGauge(ctx, waitCountKey, float64(stats.WaitCount), metrics.Labels(labels))
                                        m.SetGauge(ctx, waitDurationKey, waitDuration, metrics.Labels(labels))
                                }</span> else<span class="cov0" title="0"> {
                                        m.SetGauge(ctx, metricsPoolIdleKey, float64(stats.Idle), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolInUseKey, float64(stats.InUse), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolTotalKey, float64(stats.OpenConnections), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolWaitCountKey, float64(stats.WaitCount), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolWaitDurationKey, waitDuration, metrics.Labels(labels))
                                }</span>
                        }
                }
        })
}

func metricDBLatency(ctx context.Context, appName, name string, labels []metrics.Label) <span class="cov9" title="109">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov9" title="109"></span>

        }

        <span class="cov9" title="109">_, _ = utils.Catch(func() </span><span class="cov9" title="109">{
                rwlock.RLock()
                defer rwlock.RUnlock()
                instances, ok := appInstances[appName]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="109">instance, ok := instances[name]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="109">db := instance.GetProxy()
                sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov9" title="109">begin := time.Now()
                if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="109">latency := float64(time.Since(begin)) / float64(time.Millisecond)
                latencyKey := append([]string{config.Use(appName).AppName()}, metricsLatencyKey...)
                for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov7" title="42">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov7" title="42">
                                if m.IsEnableServiceLabel() </span><span class="cov7" title="42">{
                                        m.AddSample(ctx, latencyKey, latency,
                                                metrics.Labels(labels),
                                                metrics.PrometheusBuckets(metricsLatencyBuckets),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        m.AddSample(ctx, metricsLatencyKey, latency,
                                                metrics.Labels(labels),
                                                metrics.PrometheusBuckets(metricsLatencyBuckets),
                                        )
                                }</span>
                        }
                }
        })
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package db

import (
        "time"

        "github.com/google/uuid"
        "github.com/pkg/errors"
        "gorm.io/gorm"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
        "github.com/wfusion/gofusion/db/softdelete"
)

type Data struct {
        ID           uint64 `gorm:"column:id;primary_key;autoIncrement" json:"id"`
        CreateTimeMs int64  `gorm:"column:create_time;type:bigint;autoCreateTime:milli" json:"createTime"`
        ModifyTimeMs int64  `gorm:"column:modify_time;type:bigint;autoUpdateTime:milli" json:"modifyTime"`
}

func (d *Data) CreateTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(d.CreateTimeMs)
}</span>
func (d *Data) ModifyTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(d.ModifyTimeMs)
}</span>
func (d *Data) Clone() *Data <span class="cov0" title="0">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Data{
                ID:           d.ID,
                CreateTimeMs: d.CreateTimeMs,
                ModifyTimeMs: d.ModifyTimeMs,
        }</span>
}
func (d *Data) Equals(o *Data) bool <span class="cov0" title="0">{
        if d == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if d == nil || o == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return d.ID == o.ID &amp;&amp;
                d.CreateTimeMs == o.CreateTimeMs &amp;&amp;
                d.ModifyTimeMs == o.ModifyTimeMs</span>
}

// DataSoftDeleted
//nolint: revive // struct tag too long issue
type DataSoftDeleted struct {
        ID           uint64               `gorm:"column:id;primary_key;autoIncrement" json:"id"`
        CreateTimeMs int64                `gorm:"column:create_time;type:bigint;autoCreateTime:milli" json:"createTime"`
        ModifyTimeMs int64                `gorm:"column:modify_time;type:bigint;autoUpdateTime:milli" json:"modifyTime"`
        DeleteTimeMs softdelete.Timestamp `gorm:"column:delete_time;type:bigint;index:,composite:soft_delete" json:"deleteTime"`
        Deleted      softdelete.Deleted   `gorm:"column:deleted;index:,composite:soft_delete;default:false" json:"deleted"`
}

func (d *DataSoftDeleted) CreateTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(d.CreateTimeMs)
}</span>
func (d *DataSoftDeleted) ModifyTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(d.ModifyTimeMs)
}</span>
func (d *DataSoftDeleted) DeleteTime() *time.Time <span class="cov0" title="0">{
        if !d.DeleteTimeMs.Valid </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return utils.AnyPtr(utils.GetTime(d.DeleteTimeMs.Int64))</span>
}
func (d *DataSoftDeleted) Clone() *DataSoftDeleted <span class="cov0" title="0">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;DataSoftDeleted{
                ID:           d.ID,
                Deleted:      d.Deleted,
                CreateTimeMs: d.CreateTimeMs,
                ModifyTimeMs: d.ModifyTimeMs,
                DeleteTimeMs: d.DeleteTimeMs,
        }</span>
}
func (d *DataSoftDeleted) Equals(o *DataSoftDeleted) bool <span class="cov0" title="0">{
        if d == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if d == nil || o == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return d.ID == o.ID &amp;&amp;
                d.CreateTimeMs == o.CreateTimeMs &amp;&amp;
                d.ModifyTimeMs == o.ModifyTimeMs &amp;&amp;
                d.DeleteTimeMs == o.DeleteTimeMs &amp;&amp;
                d.Deleted == o.Deleted</span>
}

type Business struct {
        Data

        UUID            uuid.UUID `gorm:"column:uuid;type:varchar(36);uniqueIndex" json:"uuid"`
        BizCreateTimeMs int64     `gorm:"column:biz_create_time;type:bigint" json:"bizCreateTime"`
        BizModifyTimeMs int64     `gorm:"column:biz_modify_time;type:bigint" json:"bizModifyTime"`
}

func (b *Business) BeforeCreate(tx *gorm.DB) (err error) <span class="cov10" title="249">{
        if b == nil </span><span class="cov0" title="0">{
                tx.Statement.SetColumn("uuid", utils.UUID())
                return
        }</span>
        <span class="cov10" title="249">if b.UUID == [16]byte{0} </span><span class="cov9" title="225">{
                b.UUID = uuid.New()
        }</span>
        <span class="cov10" title="249">return</span>
}
func (b *Business) BeforeCreateFn(tx *gorm.DB) func() error <span class="cov0" title="0">{
        return func() (err error) </span><span class="cov0" title="0">{
                return b.BeforeCreate(tx)
        }</span>
}
func (b *Business) BizCreateTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(b.BizCreateTimeMs)
}</span>
func (b *Business) BizModifyTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(b.BizModifyTimeMs)
}</span>
func (b *Business) Clone() *Business <span class="cov0" title="0">{
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Business{
                Data:            *b.Data.Clone(),
                UUID:            b.UUID,
                BizCreateTimeMs: b.BizCreateTimeMs,
                BizModifyTimeMs: b.BizModifyTimeMs,
        }</span>
}
func (b *Business) Equals(o *Business) bool <span class="cov0" title="0">{
        if b == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if b == nil || o == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return b.Data.Equals(&amp;o.Data) &amp;&amp;
                b.UUID == o.UUID &amp;&amp;
                b.BizCreateTimeMs == o.BizCreateTimeMs &amp;&amp;
                b.BizModifyTimeMs == o.BizModifyTimeMs</span>
}

type BusinessSoftDeleted struct {
        DataSoftDeleted

        UUID            uuid.UUID `gorm:"column:uuid;type:varchar(36);uniqueIndex:uniq_uuid" json:"uuid"`
        BizCreateTimeMs int64     `gorm:"column:biz_create_time;type:bigint" json:"bizCreateTime"`
        BizModifyTimeMs int64     `gorm:"column:biz_modify_time;type:bigint" json:"bizModifyTime"`
}

func (b *BusinessSoftDeleted) BeforeCreate(tx *gorm.DB) (err error) <span class="cov3" title="5">{
        if b == nil </span><span class="cov0" title="0">{
                tx.Statement.SetColumn("uuid", utils.UUID())
                tx.Statement.SetColumn("delete_time", nil)
                return
        }</span>
        <span class="cov3" title="5">if b.UUID == [16]byte{0} </span><span class="cov3" title="5">{
                b.UUID = uuid.New()
        }</span>
        <span class="cov3" title="5">return</span>
}
func (b *BusinessSoftDeleted) BeforeCreateFn(tx *gorm.DB) func() error <span class="cov0" title="0">{
        return func() (err error) </span><span class="cov0" title="0">{
                return b.BeforeCreate(tx)
        }</span>
}
func (b *BusinessSoftDeleted) BizCreateTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(b.BizCreateTimeMs)
}</span>
func (b *BusinessSoftDeleted) BizModifyTime() time.Time <span class="cov0" title="0">{
        return utils.GetTime(b.BizModifyTimeMs)
}</span>
func (b *BusinessSoftDeleted) Clone() *BusinessSoftDeleted <span class="cov0" title="0">{
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;BusinessSoftDeleted{
                DataSoftDeleted: *b.DataSoftDeleted.Clone(),
                UUID:            b.UUID,
                BizCreateTimeMs: b.BizCreateTimeMs,
                BizModifyTimeMs: b.BizModifyTimeMs,
        }</span>
}
func (b *BusinessSoftDeleted) Equals(o *BusinessSoftDeleted) bool <span class="cov0" title="0">{
        if b == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if b == nil || o == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return b.DataSoftDeleted.Equals(&amp;o.DataSoftDeleted) &amp;&amp;
                b.UUID == o.UUID &amp;&amp;
                b.BizCreateTimeMs == o.BizCreateTimeMs &amp;&amp;
                b.BizModifyTimeMs == o.BizModifyTimeMs</span>
}

type RegionBase struct {
        RegionID string `gorm:"column:region_id;type:varchar(64);index:,composite:base" json:"regionID"`
}

func (r *RegionBase) Clone() *RegionBase <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;RegionBase{
                RegionID: r.RegionID,
        }</span>
}
func (r *RegionBase) Equals(o *RegionBase) bool <span class="cov0" title="0">{
        if r == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if r == nil || o == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return r.RegionID == o.RegionID</span>
}

type AZBase struct {
        RegionBase
        AZName string `gorm:"column:az_name;type:varchar(64);index:,composite:base" json:"azName"`
}

func (a *AZBase) Clone() *AZBase <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;AZBase{
                RegionBase: *a.RegionBase.Clone(),
                AZName:     a.AZName,
        }</span>
}
func (a *AZBase) Equals(o *AZBase) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || o == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return a.RegionBase.Equals(&amp;o.RegionBase) &amp;&amp;
                a.AZName == o.AZName</span>
}

type UserBase struct {
        AZBase
        UserID string `gorm:"column:user_id;type:varchar(64);index:,composite:base" json:"userID"`
}

func (u *UserBase) Clone() *UserBase <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;UserBase{
                AZBase: *u.AZBase.Clone(),
                UserID: u.UserID,
        }</span>
}
func (u *UserBase) Equals(o *UserBase) bool <span class="cov0" title="0">{
        if u == nil &amp;&amp; o == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if u == nil || o == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return u.AZBase.Equals(&amp;o.AZBase) &amp;&amp;
                u.UserID == o.UserID</span>
}

func CheckGormErrorFn(tx *gorm.DB) func() error <span class="cov0" title="0">{ return func() error </span><span class="cov0" title="0">{ return tx.Error }</span> }
func JsonUnmarshalFn(tx *gorm.DB, obj, field any) func() error <span class="cov0" title="0">{
        return func() (err error) </span><span class="cov0" title="0">{
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">var bs []byte
                switch v := field.(type) </span>{
                case string:<span class="cov0" title="0">
                        bs = []byte(v)</span>
                case *string:<span class="cov0" title="0">
                        if v == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">bs = []byte(*v)</span>
                case []byte:<span class="cov0" title="0">
                        bs = v</span>
                case *[]byte:<span class="cov0" title="0">
                        if v == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">bs = *v</span>
                default:<span class="cov0" title="0">
                        return tx.AddError(errors.New("unsupported unmarshal field type"))</span>
                }
                // be compatible with empty value
                <span class="cov0" title="0">if len(bs) == 0 </span><span class="cov0" title="0">{
                        bs = []byte("null")
                }</span>

                <span class="cov0" title="0">return tx.AddError(json.Unmarshal(bs, &amp;obj))</span>
        }
}
func JsonMarshalFn(tx *gorm.DB, obj, field any) func() error <span class="cov0" title="0">{
        return func() (err error) </span><span class="cov0" title="0">{
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">switch v := field.(type) </span>{
                case **string, **[]byte, *string, *[]byte:<span class="cov0" title="0">
                        if v == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">bs, err := json.Marshal(obj)
                        if err != nil </span><span class="cov0" title="0">{
                                return tx.AddError(errors.Wrap(err, "gorm json marshal error"))
                        }</span>
                        <span class="cov0" title="0">switch f := field.(type) </span>{
                        case *string:<span class="cov0" title="0">
                                *f = string(bs)</span>
                        case **string:<span class="cov0" title="0">
                                *f = utils.AnyPtr(string(bs))</span>
                        case *[]byte:<span class="cov0" title="0">
                                *f = bs</span>
                        case **[]byte:<span class="cov0" title="0">
                                *f = utils.AnyPtr(bs)</span>
                        }
                default:<span class="cov0" title="0">
                        return tx.AddError(errors.New("unsupported marshal field type"))</span>
                }
                <span class="cov0" title="0">return</span>
        }

}
</pre>
		
		<pre class="file" id="file109" style="display: none">package plugins

import (
        "bytes"
        "context"
        "encoding/binary"
        "fmt"
        "hash/crc32"
        "math"
        "math/big"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "unsafe"

        "github.com/PaesslerAG/gval"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/spf13/cast"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/infra/drivers/orm/idgen"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/common/utils/sqlparser"
        "github.com/wfusion/gofusion/db/callbacks"
)

const (
        shardingIgnoreStoreKey = "sharding_ignore"
)

var (
        ErrInvalidID             = errors.New("invalid id format")
        ErrIDGeneratorNotFound   = errors.New("id generator not found")
        ErrShardingModelNotFound = errors.New("sharding table model not found when migrating")
        ErrDiffSuffixDML         = errors.New("can not query different suffix table in one sql")
        ErrMissingShardingKey    = errors.New("sharding key required and use operator =")
        ErrColumnAndExprMisMatch = errors.New("column names and expressions mismatch")

        gormSchemaEmbeddedNamer = inspect.TypeOf("gorm.io/gorm/schema.embeddedNamer")
)

type TableShardingConfig struct {
        // Database name
        Database string

        // Table name
        Table string

        // ShardingKeys required, specifies the table columns you want to use for sharding the table rows.
        // For example, for a product order table, you may want to split the rows by `user_id`.
        ShardingKeys []string

        // ShardingKeyExpr optional, specifies how to calculate sharding key by columns, e.g. tenant_id &lt;&lt; 16 | user_id
        ShardingKeyExpr gval.Evaluable

        // ShardingKeyByRawValue optional, specifies sharding key with snake values, e.g. xxx_region1_az1, xxx_region1_az2
        ShardingKeyByRawValue bool

        // ShardingKeysForMigrating optional, specifies all sharding keys
        ShardingKeysForMigrating []string

        // NumberOfShards required, specifies how many tables you want to sharding.
        NumberOfShards uint

        // CustomSuffix optional, specifies shard table a custom suffix, e.g. user_%02d means &lt;main_table_name&gt;_user_01
        CustomSuffix string

        // PrimaryKeyGenerator optional, generates id if id is a sharding key and is zero
        PrimaryKeyGenerator idgen.Generator
}

// sharding plugin inspired by gorm.io/sharding@v0.5.3
type tableSharding struct {
        *gorm.DB

        config TableShardingConfig

        shardingFunc              func(ctx context.Context, values ...any) (suffix string, err error)
        isShardingPrimaryKey      bool
        shardingPrimaryKey        string
        shardingTableModel        any
        shardingTableCreatedMutex sync.RWMutex
        shardingTableCreated      map[string]struct{}

        suffixFormat string
}

func DefaultTableSharding(config TableShardingConfig) TableSharding <span class="cov5" title="188">{
        if utils.IsStrBlank(config.Table) </span><span class="cov0" title="0">{
                panic(errors.New("missing sharding table name"))</span>
        }
        <span class="cov5" title="188">if len(config.ShardingKeys) == 0 </span><span class="cov0" title="0">{
                panic(errors.New("missing sharding keys"))</span>
        }
        <span class="cov5" title="188">if !config.ShardingKeyByRawValue &amp;&amp; (config.NumberOfShards &lt;= 0 || config.NumberOfShards &gt;= 100000) </span><span class="cov0" title="0">{
                panic(errors.New("invalid number of shards"))</span>
        }

        <span class="cov5" title="188">shardingKeySet := utils.NewSet(config.ShardingKeys...)
        shardingPrimaryKey := ""
        isShardingPrimaryKey := false
        if shardingKeySet.Contains("id") || shardingKeySet.Contains("ID") ||
                shardingKeySet.Contains("iD") || shardingKeySet.Contains("Id") </span><span class="cov3" title="36">{
                if config.PrimaryKeyGenerator == nil </span><span class="cov0" title="0">{
                        panic(errors.New("sharding by primary key but primary key generator not found"))</span>
                }

                <span class="cov3" title="36">isShardingPrimaryKey = true
                for _, key := range config.ShardingKeys </span><span class="cov3" title="36">{
                        if key == "id" || key == "ID" || key == "Id" || key == "iD" </span><span class="cov3" title="36">{
                                shardingPrimaryKey = key
                                break</span>
                        }
                }
        }

        <span class="cov5" title="188">return &amp;tableSharding{
                config:               config,
                isShardingPrimaryKey: isShardingPrimaryKey,
                shardingPrimaryKey:   shardingPrimaryKey,
                shardingTableCreated: make(map[string]struct{}, config.NumberOfShards),
        }</span>
}

func (t *tableSharding) Name() string <span class="cov6" title="1316">{
        return fmt.Sprintf("gorm:sharding:%s:%s", t.config.Database, t.config.Table)
}</span>

func (t *tableSharding) Initialize(db *gorm.DB) (err error) <span class="cov5" title="188">{
        db.Dialector = newShardingDialector(db.Dialector, t)

        t.DB = db
        t.shardingFunc = t.defaultShardingFunc()
        t.registerCallbacks(db)
        return
}</span>

func (t *tableSharding) ShardingByModelList(ctx context.Context, src ...any) (dst map[string][]any, err error) <span class="cov4" title="53">{
        dst = make(map[string][]any, len(t.config.ShardingKeys))
        for _, m := range src </span><span class="cov5" title="149">{
                val := reflect.Indirect(reflect.ValueOf(m))
                shardingValues := make([]any, 0, len(t.config.ShardingKeys))
                for _, key := range t.config.ShardingKeys </span><span class="cov5" title="191">{
                        field := val.FieldByNameFunc(func(v string) bool </span><span class="cov7" title="2540">{ return strings.EqualFold(v, key) }</span>)
                        <span class="cov5" title="191">if !field.IsValid() </span><span class="cov4" title="107">{
                                field, _ = utils.GetGormColumnValue(val, key)
                        }</span>
                        <span class="cov5" title="191">if !field.IsValid() </span><span class="cov0" title="0">{
                                return dst, ErrMissingShardingKey
                        }</span>
                        <span class="cov5" title="191">if key == t.shardingPrimaryKey &amp;&amp; field.IsZero() </span><span class="cov0" title="0">{
                                return dst, ErrInvalidID
                        }</span>
                        <span class="cov5" title="191">shardingValues = append(shardingValues, field.Interface())</span>
                }
                <span class="cov5" title="149">suffix, err := t.shardingFunc(ctx, shardingValues...)
                if err != nil </span><span class="cov0" title="0">{
                        return dst, err
                }</span>
                <span class="cov5" title="149">dst[suffix] = append(dst[suffix], m)</span>
        }
        <span class="cov4" title="53">return</span>
}

func (t *tableSharding) ShardingByValues(ctx context.Context, src []map[string]any) (
        dst map[string][]map[string]any, err error) <span class="cov0" title="0">{
        dst = make(map[string][]map[string]any, len(t.config.ShardingKeys))
        for _, col := range src </span><span class="cov0" title="0">{
                values := make([]any, 0, len(col))
                for _, k := range t.config.ShardingKeys </span><span class="cov0" title="0">{
                        value, ok := col[k]
                        if !ok </span><span class="cov0" title="0">{
                                return dst, errors.Errorf("sharding key not found [column[%s]]", k)
                        }</span>
                        <span class="cov0" title="0">if k == t.shardingPrimaryKey &amp;&amp; utils.IsBlank(value) </span><span class="cov0" title="0">{
                                return dst, ErrInvalidID
                        }</span>
                        <span class="cov0" title="0">values = append(values, value)</span>
                }
                <span class="cov0" title="0">suffix, err := t.shardingFunc(ctx, values...)
                if err != nil </span><span class="cov0" title="0">{
                        return dst, err
                }</span>
                <span class="cov0" title="0">dst[suffix] = append(dst[suffix], col)</span>
        }
        <span class="cov0" title="0">return</span>
}

func (t *tableSharding) ShardingIDGen(ctx context.Context) (id uint64, err error) <span class="cov2" title="5">{
        if t.config.PrimaryKeyGenerator == nil </span><span class="cov0" title="0">{
                return 0, ErrIDGeneratorNotFound
        }</span>
        <span class="cov2" title="5">return t.config.PrimaryKeyGenerator.Next()</span>
}

func (t *tableSharding) registerCallbacks(db *gorm.DB) <span class="cov5" title="188">{
        utils.MustSuccess(db.Callback().
                Create().
                After("gorm:before_create").
                Before("gorm:save_before_associations").
                Register(t.Name(), t.createCallback))

        utils.MustSuccess(db.Callback().
                Query().
                Before("gorm:query").
                Register(t.Name(), t.queryCallback))

        utils.MustSuccess(db.Callback().
                Update().
                After("gorm:before_update").
                Before("gorm:save_before_associations").
                Register(t.Name(), t.updateCallback))

        utils.MustSuccess(db.Callback().
                Delete().
                After("gorm:before_delete").
                Before("gorm:delete_before_associations").
                Register(t.Name(), t.deleteCallback))

        utils.MustSuccess(db.Callback().
                Row().
                Before("gorm:row").
                Register(t.Name(), t.queryCallback))

        utils.MustSuccess(db.Callback().
                Raw().
                Before("gorm:raw").
                Register(t.Name(), t.rawCallback))
}</span>
func (t *tableSharding) createCallback(db *gorm.DB) <span class="cov7" title="3675">{
        utils.IfAny(
                t.isIgnored(db),
                func() bool </span><span class="cov7" title="3675">{ ok1, ok2 := t.dispatchTableByModel(db, tableShardingIsInsert()); return ok1 || ok2 }</span>,
                func() bool <span class="cov0" title="0">{
                        callbacks.BuildCreateSQL(db)
                        t.wrapDispatchTableBySQL(db, tableShardingIsInsert())
                        return true
                }</span>,
        )
}
func (t *tableSharding) queryCallback(db *gorm.DB) <span class="cov8" title="12785">{
        utils.IfAny(
                t.isIgnored(db),
                func() bool </span><span class="cov6" title="635">{ ok1, ok2 := t.dispatchTableByModel(db); return ok1 || ok2 }</span>,
                func() bool <span class="cov6" title="625">{
                        callbacks.BuildQuerySQL(db)
                        t.wrapDispatchTableBySQL(db)
                        return true
                }</span>,
        )
}
func (t *tableSharding) updateCallback(db *gorm.DB) <span class="cov4" title="50">{
        utils.IfAny(
                t.isIgnored(db),
                func() bool </span><span class="cov4" title="50">{ ok1, ok2 := t.dispatchTableByModel(db); return ok1 || ok2 }</span>,
                func() bool <span class="cov0" title="0">{
                        callbacks.BuildUpdateSQL(db)
                        t.wrapDispatchTableBySQL(db)
                        return true
                }</span>,
        )
}
func (t *tableSharding) deleteCallback(db *gorm.DB) <span class="cov7" title="3521">{
        utils.IfAny(
                t.isIgnored(db),
                func() bool </span><span class="cov7" title="3523">{ ok1, ok2 := t.dispatchTableByModel(db); return ok1 || ok2 }</span>,
                func() bool <span class="cov4" title="60">{
                        callbacks.BuildDeleteSQL(db)
                        t.wrapDispatchTableBySQL(db)
                        return true
                }</span>,
        )
}
func (t *tableSharding) rawCallback(db *gorm.DB) <span class="cov9" title="17220">{
        utils.IfAny(
                t.isIgnored(db),
                func() bool </span><span class="cov0" title="0">{ ok1, ok2 := t.dispatchTableByModel(db); return ok1 || ok2 }</span>,
                func() bool <span class="cov0" title="0">{ t.wrapDispatchTableBySQL(db); return true }</span>,
        )
}

type tableShardingDispatchOption struct {
        isInsert bool
}

func tableShardingIsInsert() utils.OptionFunc[tableShardingDispatchOption] <span class="cov7" title="3675">{
        return func(t *tableShardingDispatchOption) </span><span class="cov5" title="185">{
                t.isInsert = true
        }</span>
}

func (t *tableSharding) dispatchTableByModel(db *gorm.DB, opts ...utils.OptionExtender) (otherTable, ok bool) <span class="cov8" title="7884">{
        if db.Statement.Model == nil || utils.IsBlank(db.Statement.ReflectValue.Interface()) </span><span class="cov6" title="685">{
                return
        }</span>
        <span class="cov8" title="7200">if db.Statement.Table != t.config.Table </span><span class="cov8" title="6881">{
                otherTable = true
                return
        }</span>
        <span class="cov5" title="317">if t.shardingTableModel == nil </span><span class="cov4" title="42">{
                if _, ok := db.Statement.Model.(schema.Tabler); ok </span><span class="cov3" title="20">{
                        cloneModel := clone.Clone(db.Statement.Model)
                        t.shardingTableModel = cloneModel
                }</span>
        }

        <span class="cov5" title="317">opt := utils.ApplyOptions[tableShardingDispatchOption](opts...)
        if t.isShardingPrimaryKey </span><span class="cov4" title="92">{
                if err := t.setPrimaryKeyByModel(db, opt); err != nil </span><span class="cov0" title="0">{
                        _ = db.AddError(err)
                        return
                }</span>
        }

        <span class="cov5" title="317">reflectVal, ok := t.getModelReflectValue(db)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="317">if err := t.checkDiffSuffixesByModel(db); err != nil </span><span class="cov2" title="5">{
                return
        }</span>

        <span class="cov5" title="312">values := make([]any, 0, len(t.config.ShardingKeys))
        for _, key := range t.config.ShardingKeys </span><span class="cov5" title="404">{
                val := reflectVal.FieldByNameFunc(func(v string) bool </span><span class="cov8" title="5052">{ return strings.EqualFold(v, key) }</span>)
                <span class="cov5" title="404">if !val.IsValid() </span><span class="cov5" title="220">{
                        val, _ = utils.GetGormColumnValue(reflectVal, key)
                }</span>
                <span class="cov5" title="404">if !val.IsValid() </span><span class="cov0" title="0">{
                        _ = db.AddError(ErrMissingShardingKey)
                        return
                }</span>
                <span class="cov5" title="404">values = append(values, val.Interface())</span>
        }

        <span class="cov5" title="312">suffix, err := t.shardingFunc(db.Statement.Context, values...)
        if err != nil </span><span class="cov0" title="0">{
                _ = db.AddError(err)
                return
        }</span>
        // cannot parse suffix from model
        <span class="cov5" title="312">if utils.IsStrBlank(suffix) || suffix == constant.Underline </span><span class="cov0" title="0">{
                return false, false
        }</span>
        <span class="cov5" title="312">if err = t.createTableIfNotExists(db, db.Statement.Table, suffix); err != nil </span><span class="cov0" title="0">{
                _ = db.AddError(err)
                return
        }</span>

        <span class="cov5" title="312">db.Statement.Table = db.Statement.Table + suffix
        t.replaceStatementClauseAndSchema(db, opt)
        ok = true
        return</span>
}

//nolint: revive // sql parser issue
func (t *tableSharding) dispatchTableBySQL(db *gorm.DB, opts ...utils.OptionExtender) (ok bool, err error) <span class="cov6" title="685">{
        expr, err := sqlparser.NewParser(strings.NewReader(db.Statement.SQL.String())).ParseStatement()
        if err != nil </span><span class="cov0" title="0">{
                // maybe not a dml, so we ignore this error
                return
        }</span>

        <span class="cov6" title="685">getSuffix := func(condition sqlparser.Node, tableName string, vars ...any) (suffix string, err error) </span><span class="cov4" title="75">{
                values := make([]any, 0, len(t.config.ShardingKeys))
                for _, key := range t.config.ShardingKeys </span><span class="cov4" title="85">{
                        val, err := t.nonInsertValue(condition, key, tableName, vars...)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", db.AddError(err)
                        }</span>
                        <span class="cov4" title="85">values = append(values, val)</span>
                }

                <span class="cov4" title="75">suffix, err = t.shardingFunc(db.Statement.Context, values...)
                if err != nil </span><span class="cov0" title="0">{
                        return "", db.AddError(err)
                }</span>
                <span class="cov4" title="75">return</span>
        }

        <span class="cov6" title="685">newSQL := ""
        switch stmt := expr.(type) </span>{
        case *sqlparser.InsertStatement:<span class="cov0" title="0">
                if stmt.TableName.TableName() != t.config.Table </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">suffix := ""
                for _, insertExpression := range stmt.Expressions </span><span class="cov0" title="0">{
                        values, id, e := t.insertValue(t.config.ShardingKeys, stmt.ColumnNames,
                                insertExpression.Exprs, db.Statement.Vars...)
                        if e != nil </span><span class="cov0" title="0">{
                                _ = db.AddError(e)
                                return
                        }</span>
                        <span class="cov0" title="0">if t.isShardingPrimaryKey &amp;&amp; id == 0 </span><span class="cov0" title="0">{
                                if t.config.PrimaryKeyGenerator == nil </span><span class="cov0" title="0">{
                                        _ = db.AddError(ErrIDGeneratorNotFound)
                                        return
                                }</span>
                                <span class="cov0" title="0">if id, e = t.config.PrimaryKeyGenerator.Next(idgen.GormTx(db)); e != nil </span><span class="cov0" title="0">{
                                        _ = db.AddError(e)
                                        return
                                }</span>
                                <span class="cov0" title="0">stmt.ColumnNames = append(stmt.ColumnNames, &amp;sqlparser.Ident{Name: "id"})
                                insertExpression.Exprs = append(insertExpression.Exprs, &amp;sqlparser.NumberLit{Value: cast.ToString(id)})
                                values, _, _ = t.insertValue(t.config.ShardingKeys, stmt.ColumnNames,
                                        insertExpression.Exprs, db.Statement.Vars...)</span>
                        }

                        <span class="cov0" title="0">subSuffix, e := t.shardingFunc(db.Statement.Context, values...)
                        if e != nil </span><span class="cov0" title="0">{
                                _ = db.AddError(e)
                                return
                        }</span>

                        <span class="cov0" title="0">if suffix != "" &amp;&amp; suffix != subSuffix </span><span class="cov0" title="0">{
                                _ = db.AddError(ErrDiffSuffixDML)
                                return
                        }</span>
                        <span class="cov0" title="0">suffix = subSuffix</span>
                }
                // FIXME: could not find the table schema to migrate
                <span class="cov0" title="0">if e := t.createTableIfNotExists(db, db.Statement.Table, suffix); e != nil </span><span class="cov0" title="0">{
                        _ = db.AddError(e)
                        return
                }</span>
                <span class="cov0" title="0">stmt.TableName = &amp;sqlparser.TableName{Name: &amp;sqlparser.Ident{Name: stmt.TableName.TableName() + suffix}}
                newSQL = stmt.String()</span>
        case *sqlparser.SelectStatement:<span class="cov6" title="625">
                parseSelectStatementFunc := func(stmt *sqlparser.SelectStatement) (ok bool, err error) </span><span class="cov6" title="625">{
                        if stmt.Hint != nil &amp;&amp; stmt.Hint.Value == "nosharding" </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>

                        <span class="cov6" title="625">switch tbl := stmt.FromItems.(type) </span>{
                        case *sqlparser.TableName:<span class="cov6" title="575">
                                if tbl.TableName() != t.config.Table </span><span class="cov6" title="520">{
                                        return false, nil
                                }</span>
                                <span class="cov4" title="55">suffix, e := getSuffix(stmt.Condition, t.config.Table, db.Statement.Vars...)
                                if e != nil </span><span class="cov0" title="0">{
                                        _ = db.AddError(e)
                                        return false, nil
                                }</span>
                                <span class="cov4" title="55">oldTableName := tbl.TableName()
                                newTableName := oldTableName + suffix
                                stmt.FromItems = &amp;sqlparser.TableName{Name: &amp;sqlparser.Ident{Name: newTableName}}
                                stmt.OrderBy = t.replaceOrderByTableName(stmt.OrderBy, oldTableName, newTableName)
                                if e := t.replaceCondition(stmt.Condition, oldTableName, newTableName); err != nil </span><span class="cov0" title="0">{
                                        _ = db.AddError(e)
                                        return false, nil
                                }</span>
                        case *sqlparser.JoinClause:<span class="cov4" title="50">
                                tblx, _ := tbl.X.(*sqlparser.TableName)
                                tbly, _ := tbl.Y.(*sqlparser.TableName)
                                isXSharding := tblx != nil &amp;&amp; tblx.TableName() == t.config.Table
                                isYSharding := tbly != nil &amp;&amp; tbly.TableName() == t.config.Table
                                oldTableName := ""
                                switch </span>{
                                case isXSharding:<span class="cov2" title="5">
                                        oldTableName = tblx.TableName()</span>
                                case isYSharding:<span class="cov2" title="5">
                                        oldTableName = tbly.TableName()</span>
                                default:<span class="cov4" title="40">
                                        return false, nil</span>
                                }
                                <span class="cov2" title="10">suffix, e := getSuffix(stmt.Condition, oldTableName, db.Statement.Vars...)
                                if e != nil </span><span class="cov0" title="0">{
                                        _ = db.AddError(e)
                                        return false, nil
                                }</span>
                                <span class="cov2" title="10">newTableName := oldTableName + suffix
                                stmt.OrderBy = t.replaceOrderByTableName(stmt.OrderBy, oldTableName, newTableName)
                                if e := t.replaceCondition(stmt.Condition, oldTableName, newTableName); err != nil </span><span class="cov0" title="0">{
                                        _ = db.AddError(e)
                                        return false, nil
                                }</span>
                                <span class="cov2" title="10">if e := t.replaceConstraint(tbl.Constraint, oldTableName, newTableName); err != nil </span><span class="cov0" title="0">{
                                        _ = db.AddError(e)
                                        return false, nil
                                }</span>
                                <span class="cov2" title="10">if isXSharding </span><span class="cov2" title="5">{
                                        tblx.Name.Name = newTableName
                                }</span> else<span class="cov2" title="5"> {
                                        tbly.Name.Name = newTableName
                                }</span>
                                <span class="cov2" title="10">if stmt.Columns != nil </span><span class="cov2" title="10">{
                                        for _, column := range *stmt.Columns </span><span class="cov4" title="100">{
                                                columnTbl, ok := column.Expr.(*sqlparser.QualifiedRef)
                                                if !ok || columnTbl.Table.Name != oldTableName </span><span class="cov4" title="50">{
                                                        continue</span>
                                                }
                                                <span class="cov4" title="50">columnTbl.Table.Name = newTableName</span>
                                        }
                                }
                        }
                        <span class="cov4" title="65">return true, nil</span>
                }
                <span class="cov6" title="625">for compound := stmt; compound != nil; compound = compound.Compound </span><span class="cov6" title="625">{
                        if ok, err = parseSelectStatementFunc(compound); !ok || err != nil </span><span class="cov6" title="560">{
                                return
                        }</span>
                }

                <span class="cov4" title="65">newSQL = stmt.String()</span>

        case *sqlparser.UpdateStatement:<span class="cov2" title="5">
                if stmt.TableName.TableName() != t.config.Table </span><span class="cov2" title="5">{
                        return
                }</span>

                <span class="cov0" title="0">suffix, e := getSuffix(stmt.Condition, t.config.Table, db.Statement.Vars...)
                if e != nil </span><span class="cov0" title="0">{
                        _ = db.AddError(e)
                        return
                }</span>

                <span class="cov0" title="0">oldTableName := stmt.TableName.TableName()
                newTableName := oldTableName + suffix
                stmt.TableName = &amp;sqlparser.TableName{Name: &amp;sqlparser.Ident{Name: newTableName}}
                if e := t.replaceCondition(stmt.Condition, oldTableName, newTableName); err != nil </span><span class="cov0" title="0">{
                        _ = db.AddError(e)
                        return false, nil
                }</span>
                <span class="cov0" title="0">newSQL = stmt.String()</span>
        case *sqlparser.DeleteStatement:<span class="cov4" title="55">
                if stmt.TableName.TableName() != t.config.Table </span><span class="cov4" title="45">{
                        return
                }</span>

                <span class="cov2" title="10">suffix, e := getSuffix(stmt.Condition, t.config.Table, db.Statement.Vars...)
                if e != nil </span><span class="cov0" title="0">{
                        _ = db.AddError(e)
                        return
                }</span>

                <span class="cov2" title="10">oldTableName := stmt.TableName.TableName()
                newTableName := oldTableName + suffix
                stmt.TableName = &amp;sqlparser.TableName{Name: &amp;sqlparser.Ident{Name: newTableName}}
                if e := t.replaceCondition(stmt.Condition, oldTableName, newTableName); err != nil </span><span class="cov0" title="0">{
                        _ = db.AddError(e)
                        return false, nil
                }</span>
                <span class="cov2" title="10">newSQL = stmt.String()</span>
        default:<span class="cov0" title="0">
                _ = db.AddError(sqlparser.ErrNotImplemented)
                return</span>
        }

        <span class="cov4" title="75">sb := strings.Builder{}
        sb.Grow(len(newSQL))
        sb.WriteString(newSQL)
        db.Statement.SQL = sb

        return true, nil</span>
}
func (t *tableSharding) wrapDispatchTableBySQL(db *gorm.DB, opts ...utils.OptionExtender) <span class="cov6" title="685">{
        if ok, err := t.dispatchTableBySQL(db, opts...); err != nil || !ok </span><span class="cov6" title="610">{
                // not a dml
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                // not a sharding table
                <span class="cov6" title="610">if !ok </span>{<span class="cov6" title="610">
                        // FIXME: reset sql parse result will get duplicated sql statement
                        // db.Statement.SQL = strings.Builder{}
                        // db.Statement.Vars = nil
                }</span>
        }
}
func (t *tableSharding) replaceStatementClauseAndSchema(db *gorm.DB, opt *tableShardingDispatchOption) <span class="cov5" title="312">{
        changeExprFunc := func(src []clause.Expression) (dst []clause.Expression) </span><span class="cov1" title="2">{
                changeTableFunc := func(src any) (dst any, ok bool) </span><span class="cov0" title="0">{
                        switch col := src.(type) </span>{
                        case clause.Column:<span class="cov0" title="0">
                                if col.Table == t.config.Table </span><span class="cov0" title="0">{
                                        col.Table = db.Statement.Table
                                        return col, true
                                }</span>
                        case clause.Table:<span class="cov0" title="0">
                                if col.Name == t.config.Table </span><span class="cov0" title="0">{
                                        col.Name = db.Statement.Table
                                        return col, true
                                }</span>
                        }
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov1" title="2">dst = make([]clause.Expression, 0, len(src))
                for _, srcExpr := range src </span><span class="cov1" title="2">{
                        switch expr := srcExpr.(type) </span>{
                        case clause.IN:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        case clause.Eq:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        case clause.Neq:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        case clause.Gt:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        case clause.Gte:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        case clause.Lt:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        case clause.Lte:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        case clause.Like:<span class="cov0" title="0">
                                if col, ok := changeTableFunc(expr.Column); ok </span><span class="cov0" title="0">{
                                        expr.Column = col
                                }</span>
                                <span class="cov0" title="0">dst = append(dst, expr)</span>
                        default:<span class="cov1" title="2">
                                dst = append(dst, expr)</span>
                        }
                }
                <span class="cov1" title="2">return</span>
        }
        <span class="cov5" title="312">changeClausesMapping := map[string]func(cls clause.Clause){
                "WHERE": func(cls clause.Clause) </span><span class="cov1" title="2">{
                        whereClause, ok := cls.Expression.(clause.Where)
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov1" title="2">whereClause.Exprs = changeExprFunc(whereClause.Exprs)
                        cls.Expression = whereClause
                        db.Statement.Clauses["WHERE"] = cls</span>
                },
                "FROM": func(cls clause.Clause) <span class="cov0" title="0">{
                        fromClause, ok := cls.Expression.(clause.From)
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">tables := make([]clause.Table, 0, len(fromClause.Tables))
                        for _, table := range fromClause.Tables </span><span class="cov0" title="0">{
                                if table.Name == t.config.Table </span><span class="cov0" title="0">{
                                        table.Name = db.Statement.Table
                                        tables = append(tables, table)
                                }</span> else<span class="cov0" title="0"> {
                                        tables = append(tables, table)
                                }</span>
                        }
                        <span class="cov0" title="0">fromClause.Tables = tables
                        cls.Expression = fromClause
                        db.Statement.Clauses["FROM"] = cls</span>
                },
                // TODO: check if order by contains table name
                "ORDER BY": func(cls clause.Clause) <span class="cov0" title="0">{
                        _, ok := cls.Expression.(clause.OrderBy)
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                },
        }

        <span class="cov5" title="312">for name, cls := range db.Statement.Clauses </span><span class="cov3" title="32">{
                if mappingFunc, ok := changeClausesMapping[name]; ok </span><span class="cov1" title="2">{
                        mappingFunc(cls)
                }</span>
        }

        <span class="cov5" title="312">if opt.isInsert </span><span class="cov5" title="185">{
                db.Clauses(clause.Insert{Table: clause.Table{Name: db.Statement.Table}})
        }</span> else<span class="cov5" title="127"> {
                db.Clauses(clause.From{Tables: []clause.Table{{Name: db.Statement.Table}}})
        }</span>
}

func (t *tableSharding) replaceCondition(conditions sqlparser.Expr, oldTableName, newTableName string) (err error) <span class="cov4" title="75">{
        err = sqlparser.Walk(
                sqlparser.VisitFunc(func(node sqlparser.Node) (err error) </span><span class="cov6" title="845">{
                        n, ok := node.(*sqlparser.BinaryExpr)
                        if !ok </span><span class="cov6" title="550">{
                                return
                        }</span>

                        <span class="cov5" title="295">x, ok := n.X.(*sqlparser.QualifiedRef)
                        if !ok || x.Table == nil || x.Table.Name != oldTableName </span><span class="cov5" title="225">{
                                return
                        }</span>

                        <span class="cov4" title="70">x.Table.Name = newTableName
                        return</span>
                }),
                conditions,
        )
        <span class="cov4" title="75">return</span>
}

func (t *tableSharding) replaceConstraint(constraints sqlparser.Node, oldTableName, newTableName string) (err error) <span class="cov2" title="10">{
        return sqlparser.Walk(
                sqlparser.VisitFunc(func(node sqlparser.Node) (err error) </span><span class="cov4" title="80">{
                        n, ok := node.(*sqlparser.QualifiedRef)
                        if !ok || n.Table == nil || n.Table.Name != oldTableName </span><span class="cov4" title="70">{
                                return
                        }</span>

                        <span class="cov2" title="10">n.Table.Name = newTableName
                        return</span>
                }),
                constraints,
        )
}

func (t *tableSharding) insertValue(keys []string, names []*sqlparser.Ident, exprs []sqlparser.Expr, args ...any) (
        values []any, id uint64, err error) <span class="cov0" title="0">{
        if len(names) != len(exprs) </span><span class="cov0" title="0">{
                return nil, 0, ErrColumnAndExprMisMatch
        }</span>

        <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                found := false
                isPrimaryKey := key == t.shardingPrimaryKey
                for i, name := range names </span><span class="cov0" title="0">{
                        if name.Name != key </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">switch expr := exprs[i].(type) </span>{
                        case *sqlparser.BindExpr:<span class="cov0" title="0">
                                if !isPrimaryKey </span><span class="cov0" title="0">{
                                        values = append(values, args[expr.Pos])
                                }</span> else<span class="cov0" title="0"> {
                                        switch v := args[expr.Pos].(type) </span>{
                                        case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, string:<span class="cov0" title="0">
                                                if id, err = cast.ToUint64E(v); err != nil </span><span class="cov0" title="0">{
                                                        return nil, 0, errors.Wrapf(err, "parse id as uint64 failed [%v]", v)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                return nil, 0, ErrInvalidID</span>
                                        }
                                        <span class="cov0" title="0">if id != 0 </span><span class="cov0" title="0">{
                                                values = append(values, args[expr.Pos])
                                        }</span>
                                }
                        case *sqlparser.StringLit:<span class="cov0" title="0">
                                if !isPrimaryKey </span><span class="cov0" title="0">{
                                        values = append(values, expr.Value)
                                }</span> else<span class="cov0" title="0"> {
                                        if id, err = cast.ToUint64E(expr.Value); err != nil </span><span class="cov0" title="0">{
                                                return nil, 0, errors.Wrapf(err, "parse id as uint64 failed [%s]", expr.Value)
                                        }</span>
                                        <span class="cov0" title="0">if id != 0 </span><span class="cov0" title="0">{
                                                values = append(values, expr.Value)
                                        }</span>
                                }
                        case *sqlparser.NumberLit:<span class="cov0" title="0">
                                if !isPrimaryKey </span><span class="cov0" title="0">{
                                        values = append(values, expr.Value)
                                }</span> else<span class="cov0" title="0"> {
                                        if id, err = strconv.ParseUint(expr.Value, 10, 64); err != nil </span><span class="cov0" title="0">{
                                                return nil, 0, errors.Wrapf(err,
                                                        "parse id as uint64 failed [%s]", expr.Value)
                                        }</span>
                                        <span class="cov0" title="0">if id != 0 </span><span class="cov0" title="0">{
                                                values = append(values, expr.Value)
                                        }</span>
                                }
                        default:<span class="cov0" title="0">
                                return nil, 0, sqlparser.ErrNotImplemented</span>
                        }

                        <span class="cov0" title="0">found = true
                        break</span>
                }
                <span class="cov0" title="0">if !found &amp;&amp; !isPrimaryKey </span><span class="cov0" title="0">{
                        return nil, 0, ErrMissingShardingKey
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

func (t *tableSharding) nonInsertValue(condition sqlparser.Node, key, tableName string, args ...any) (
        value any, err error) <span class="cov4" title="85">{
        found := false
        err = sqlparser.Walk(
                sqlparser.VisitFunc(func(node sqlparser.Node) (err error) </span><span class="cov6" title="955">{
                        n, ok := node.(*sqlparser.BinaryExpr)
                        if !ok </span><span class="cov6" title="610">{
                                return
                        }</span>
                        <span class="cov5" title="345">if n.Op != sqlparser.EQ </span><span class="cov5" title="190">{
                                return
                        }</span>

                        <span class="cov5" title="155">switch x := n.X.(type) </span>{
                        case *sqlparser.Ident:<span class="cov4" title="120">
                                if x.Name != key </span><span class="cov4" title="45">{
                                        return
                                }</span>
                        case *sqlparser.QualifiedRef:<span class="cov3" title="35">
                                if !ok || x.Table.Name != tableName || x.Column.Name != key </span><span class="cov3" title="25">{
                                        return
                                }</span>
                        }

                        <span class="cov4" title="85">found = true
                        switch expr := n.Y.(type) </span>{
                        case *sqlparser.BindExpr:<span class="cov4" title="80">
                                value = args[expr.Pos]</span>
                        case *sqlparser.StringLit:<span class="cov2" title="5">
                                value = expr.Value</span>
                        case *sqlparser.NumberLit:<span class="cov0" title="0">
                                value = expr.Value</span>
                        default:<span class="cov0" title="0">
                                return sqlparser.ErrNotImplemented</span>
                        }

                        <span class="cov4" title="85">return</span>
                }),
                condition,
        )
        <span class="cov4" title="85">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="85">if !found </span><span class="cov0" title="0">{
                return nil, ErrMissingShardingKey
        }</span>
        <span class="cov4" title="85">return</span>
}

func (t *tableSharding) setPrimaryKeyByModel(db *gorm.DB, opt *tableShardingDispatchOption) (err error) <span class="cov4" title="92">{
        if !opt.isInsert || db.Statement.Model == nil ||
                db.Statement.Schema == nil || db.Statement.Schema.PrioritizedPrimaryField == nil </span><span class="cov3" title="35">{
                return
        }</span>
        <span class="cov4" title="57">setPrimaryKeyFunc := func(rv reflect.Value) (err error) </span><span class="cov4" title="82">{
                _, isZero := db.Statement.Schema.PrioritizedPrimaryField.ValueOf(db.Statement.Context, rv)
                if !isZero </span><span class="cov4" title="72">{
                        return
                }</span>
                <span class="cov2" title="10">if t.config.PrimaryKeyGenerator == nil </span><span class="cov0" title="0">{
                        return ErrIDGeneratorNotFound
                }</span>
                <span class="cov2" title="10">id, err := t.config.PrimaryKeyGenerator.Next(idgen.GormTx(db))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov2" title="10">return db.Statement.Schema.PrioritizedPrimaryField.Set(db.Statement.Context, rv, id)</span>
        }

        <span class="cov4" title="57">switch db.Statement.ReflectValue.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov4" title="47">
                for i := 0; i &lt; db.Statement.ReflectValue.Len(); i++ </span><span class="cov4" title="72">{
                        rv := db.Statement.ReflectValue.Index(i)
                        if reflect.Indirect(rv).Kind() != reflect.Struct </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov4" title="72">if err = setPrimaryKeyFunc(rv); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        case reflect.Struct:<span class="cov2" title="10">
                if err = setPrimaryKeyFunc(db.Statement.ReflectValue); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov4" title="57">return</span>
}

func (t *tableSharding) getModelReflectValue(db *gorm.DB) (reflectVal reflect.Value, ok bool) <span class="cov5" title="317">{
        reflectVal = utils.IndirectValue(db.Statement.ReflectValue)
        if reflectVal.Kind() == reflect.Array || reflectVal.Kind() == reflect.Slice </span><span class="cov5" title="217">{
                if reflectVal.Len() == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov5" title="217">reflectVal = utils.IndirectValue(reflectVal.Index(0))</span>
        }

        <span class="cov5" title="317">if reflectVal.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="317">return reflectVal, !utils.IsBlank(reflectVal.Interface())</span>
}

func (t *tableSharding) checkDiffSuffixesByModel(db *gorm.DB) (err error) <span class="cov5" title="317">{
        reflectVal := utils.IndirectValue(db.Statement.ReflectValue)
        if reflectVal.Kind() != reflect.Array &amp;&amp; reflectVal.Kind() != reflect.Slice </span><span class="cov4" title="100">{
                return
        }</span>

        <span class="cov5" title="217">suffix := ""
        for i := 0; i &lt; reflectVal.Len(); i++ </span><span class="cov5" title="405">{
                reflectItemVal := reflect.Indirect(reflectVal.Index(i))
                values := make([]any, 0, len(t.config.ShardingKeys))
                for _, key := range t.config.ShardingKeys </span><span class="cov6" title="537">{
                        val := reflectItemVal.FieldByNameFunc(func(v string) bool </span><span class="cov8" title="6520">{ return strings.EqualFold(v, key) }</span>)
                        <span class="cov6" title="537">if !val.IsValid() </span><span class="cov5" title="273">{
                                val, _ = utils.GetGormColumnValue(reflectItemVal, key)
                        }</span>
                        <span class="cov6" title="537">if !val.IsValid() </span><span class="cov0" title="0">{
                                return db.AddError(ErrMissingShardingKey)
                        }</span>
                        <span class="cov6" title="537">values = append(values, val.Interface())</span>
                }
                <span class="cov5" title="405">subSuffix, err := t.shardingFunc(db.Statement.Context, values...)
                if err != nil </span><span class="cov0" title="0">{
                        return db.AddError(err)
                }</span>
                <span class="cov5" title="405">if suffix != "" &amp;&amp; suffix != subSuffix </span><span class="cov2" title="5">{
                        return db.AddError(ErrDiffSuffixDML)
                }</span>
                <span class="cov5" title="400">suffix = subSuffix</span>
        }
        <span class="cov5" title="212">return</span>
}

func (t *tableSharding) replaceOrderByTableName(
        orderBy []*sqlparser.OrderingTerm, oldName, newName string) []*sqlparser.OrderingTerm <span class="cov4" title="65">{
        for i, term := range orderBy </span><span class="cov2" title="5">{
                if x, ok := term.X.(*sqlparser.QualifiedRef); ok </span><span class="cov2" title="5">{
                        if x.Table.Name == oldName </span><span class="cov2" title="5">{
                                x.Table.Name = newName
                                orderBy[i].X = x
                        }</span>
                }
        }
        <span class="cov4" title="65">return orderBy</span>
}

func (t *tableSharding) createTableIfNotExists(db *gorm.DB, tableName, suffix string) (err error) <span class="cov5" title="312">{
        shardingTableName := tableName + suffix
        t.shardingTableCreatedMutex.RLock()
        if _, ok := t.shardingTableCreated[shardingTableName]; ok </span><span class="cov5" title="257">{
                t.shardingTableCreatedMutex.RUnlock()
                return
        }</span>
        <span class="cov4" title="55">t.shardingTableCreatedMutex.RUnlock()
        t.shardingTableCreatedMutex.Lock()
        defer t.shardingTableCreatedMutex.Unlock()

        defer t.ignore(t.DB)() //nolint: revive // partial calling issue
        if t.DB.Migrator().HasTable(shardingTableName) </span><span class="cov4" title="55">{
                t.shardingTableCreated[shardingTableName] = struct{}{}
                return
        }</span>

        <span class="cov0" title="0">model := db.Statement.Model
        if model == nil </span><span class="cov0" title="0">{
                model = t.shardingTableModel
        }</span>
        <span class="cov0" title="0">if model == nil </span><span class="cov0" title="0">{
                return ErrShardingModelNotFound
        }</span>
        <span class="cov0" title="0">tx := t.DB.Session(&amp;gorm.Session{}).Table(shardingTableName)
        if err = db.Dialector.Migrator(tx).AutoMigrate(db.Statement.Model); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">t.shardingTableCreated[shardingTableName] = struct{}{}
        return</span>
}

func (t *tableSharding) suffixes() (suffixes []string, err error) <span class="cov5" title="320">{
        switch </span>{
        case t.config.ShardingKeyByRawValue:<span class="cov3" title="20">
                if len(t.config.ShardingKeysForMigrating) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("sharding key by raw value but do not configure keys for migrating")
                }</span>

                <span class="cov3" title="20">for _, shardingKey := range t.config.ShardingKeysForMigrating </span><span class="cov4" title="80">{
                        suffixes = append(suffixes, fmt.Sprintf(t.suffixFormat, shardingKey))
                }</span>
        default:<span class="cov5" title="300">
                for i := 0; i &lt; int(t.config.NumberOfShards); i++ </span><span class="cov7" title="1810">{
                        suffixes = append(suffixes, fmt.Sprintf(t.suffixFormat, i))
                }</span>
        }
        <span class="cov5" title="320">return</span>
}

func (t *tableSharding) ignore(db *gorm.DB) func() <span class="cov6" title="475">{
        if _, ok := db.Statement.Settings.Load(shardingIgnoreStoreKey); ok </span><span class="cov0" title="0">{
                return func() </span>{<span class="cov0" title="0">}</span>
        }
        <span class="cov6" title="475">db.Statement.Settings.Store(shardingIgnoreStoreKey, nil)
        return func() </span><span class="cov6" title="475">{
                db.Statement.Settings.Delete(shardingIgnoreStoreKey)
        }</span>
}
func (t *tableSharding) isIgnored(db *gorm.DB) func() bool <span class="cov10" title="51618">{
        return func() bool </span><span class="cov9" title="51616">{
                _, ok := db.Statement.Settings.Load(shardingIgnoreStoreKey)
                return ok
        }</span>
}

func (t *tableSharding) defaultShardingFunc() func(ctx context.Context, values ...any) (suffix string, err error) <span class="cov5" title="188">{
        if !t.config.ShardingKeyByRawValue &amp;&amp; t.config.NumberOfShards == 0 </span><span class="cov0" title="0">{
                panic(errors.New("missing number_of_shards config"))</span>
        }
        <span class="cov5" title="188">t.suffixFormat = constant.Underline

        switch </span>{
        case utils.IsStrNotBlank(t.config.CustomSuffix):<span class="cov3" title="36">
                t.suffixFormat += t.config.CustomSuffix</span>
        case t.config.ShardingKeyByRawValue:<span class="cov3" title="36">
                t.suffixFormat += "%s"</span>
        default:<span class="cov4" title="116">
                t.suffixFormat += strings.Join(t.config.ShardingKeys, constant.Underline)</span>
        }

        <span class="cov5" title="188">numberOfShards := t.config.NumberOfShards
        if !strings.Contains(t.suffixFormat, "%") </span><span class="cov4" title="116">{
                if t.config.ShardingKeyByRawValue </span><span class="cov0" title="0">{
                        t.suffixFormat += "_%s"
                }</span> else<span class="cov4" title="116"> if numberOfShards &lt; 10 </span><span class="cov4" title="116">{
                        t.suffixFormat += "_%01d"
                }</span> else<span class="cov0" title="0"> if numberOfShards &lt; 100 </span><span class="cov0" title="0">{
                        t.suffixFormat += "_%02d"
                }</span> else<span class="cov0" title="0"> if numberOfShards &lt; 1000 </span><span class="cov0" title="0">{
                        t.suffixFormat += "_%03d"
                }</span> else<span class="cov0" title="0"> if numberOfShards &lt; 10000 </span><span class="cov0" title="0">{
                        t.suffixFormat += "_%04d"
                }</span>
        }

        <span class="cov5" title="188">switch </span>{
        case t.config.ShardingKeyByRawValue:<span class="cov3" title="36">
                return func(ctx context.Context, values ...any) (suffix string, err error) </span><span class="cov4" title="40">{
                        data := make([]string, 0, len(values))
                        for _, value := range values </span><span class="cov4" title="40">{
                                v, err := cast.ToStringE(value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                                <span class="cov4" title="40">data = append(data, v)</span>
                        }
                        <span class="cov4" title="40">shardingKey := strings.Join(data, constant.Underline)
                        return fmt.Sprintf("_%s", shardingKey), nil</span>
                }
        case t.config.ShardingKeyExpr != nil:<span class="cov3" title="36">
                numberOfShardsFloat64 := float64(numberOfShards)
                return func(ctx context.Context, values ...any) (suffix string, err error) </span><span class="cov5" title="276">{
                        params := make(map[string]any, len(t.config.ShardingKeys))
                        for idx, column := range t.config.ShardingKeys </span><span class="cov6" title="552">{
                                params[column] = values[idx]
                        }</span>

                        <span class="cov5" title="276">result, err := t.config.ShardingKeyExpr(ctx, params)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov5" title="276">shardingKey := int64(math.Mod(cast.ToFloat64(result), numberOfShardsFloat64))
                        return fmt.Sprintf(t.suffixFormat, shardingKey), nil</span>
                }
        default:<span class="cov4" title="116">
                stringToByteSliceFunc := func(v string) (data []byte) </span><span class="cov6" title="625">{
                        utils.IfAny(
                                // number
                                func() (ok bool) </span><span class="cov6" title="625">{
                                        num := new(big.Float)
                                        if _, ok = num.SetString(v); !ok </span><span class="cov6" title="625">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">gobEncoded, err := num.GobEncode()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                        <span class="cov0" title="0">data = gobEncoded
                                        return</span>
                                },
                                // uuid
                                func() bool <span class="cov6" title="625">{
                                        uid, err := uuid.Parse(v)
                                        if err != nil </span><span class="cov6" title="625">{
                                                return false
                                        }</span>
                                        <span class="cov0" title="0">data = uid[:]
                                        return true</span>
                                },
                                // bytes
                                func() bool <span class="cov6" title="625">{ data = []byte(v); return true }</span>,
                        )
                        <span class="cov6" title="625">return</span>
                }
                <span class="cov4" title="116">return func(ctx context.Context, values ...any) (suffix string, err error) </span><span class="cov6" title="625">{
                        size := 0
                        for _, value := range values </span><span class="cov6" title="625">{
                                s := binary.Size(value)
                                if s &lt;= 0 </span><span class="cov6" title="625">{
                                        s = int(unsafe.Sizeof(value))
                                }</span>
                                <span class="cov6" title="625">size += s</span>
                        }
                        <span class="cov6" title="625">w := new(bytes.Buffer)
                        w.Grow(size)

                        for _, value := range values </span><span class="cov6" title="625">{
                                var data any
                                switch v := value.(type) </span>{
                                case int, *int:<span class="cov0" title="0">
                                        data = utils.IntNarrow(cast.ToInt(v))</span>
                                case uint, *uint:<span class="cov0" title="0">
                                        data = utils.UintNarrow(cast.ToUint(v))</span>
                                case []int:<span class="cov0" title="0">
                                        data = make([]any, len(v))
                                        for i := 0; i &lt; len(v); i++ </span><span class="cov0" title="0">{
                                                data.([]any)[i] = utils.IntNarrow(cast.ToInt(v))
                                        }</span>
                                case []uint:<span class="cov0" title="0">
                                        data = make([]any, len(v))
                                        for i := 0; i &lt; len(v); i++ </span><span class="cov0" title="0">{
                                                data.([]any)[i] = utils.UintNarrow(cast.ToUint(v))
                                        }</span>
                                case string:<span class="cov6" title="625">
                                        data = stringToByteSliceFunc(v)</span>
                                case []byte:<span class="cov0" title="0">
                                        data = stringToByteSliceFunc(utils.UnsafeBytesToString(v))</span>
                                case uuid.UUID:<span class="cov0" title="0">
                                        data = v[:]</span>
                                default:<span class="cov0" title="0">
                                        data = v</span>
                                }
                                <span class="cov6" title="625">if err = binary.Write(w, binary.BigEndian, data); err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }

                        // checksum mod shards
                        <span class="cov6" title="625">checksum := crc32.ChecksumIEEE(w.Bytes())
                        shardingKey := uint64(checksum) % uint64(numberOfShards)
                        suffix = fmt.Sprintf(t.suffixFormat, shardingKey)
                        return</span>
                }
        }
}

type shardingDialector struct {
        gorm.Dialector
        shardingMap map[string]*tableSharding
}

func newShardingDialector(d gorm.Dialector, s *tableSharding) shardingDialector <span class="cov5" title="188">{
        if sd, ok := d.(shardingDialector); ok </span><span class="cov5" title="144">{
                sd.shardingMap[s.config.Table] = s
                return sd
        }</span>

        <span class="cov4" title="44">return shardingDialector{
                Dialector:   d,
                shardingMap: map[string]*tableSharding{s.config.Table: s},
        }</span>
}

func (s shardingDialector) Migrator(db *gorm.DB) gorm.Migrator <span class="cov8" title="14047">{
        m := s.Dialector.Migrator(db)
        if (*tableSharding)(nil).isIgnored(db)() </span><span class="cov8" title="13627">{
                return m
        }</span>
        <span class="cov6" title="420">return &amp;shardingMigrator{
                Migrator:    m,
                db:          db,
                shardingMap: s.shardingMap,
                dialector:   s.Dialector,
        }</span>
}
func (s shardingDialector) SavePoint(tx *gorm.DB, name string) error <span class="cov0" title="0">{
        if savePointer, ok := s.Dialector.(gorm.SavePointerDialectorInterface); ok </span><span class="cov0" title="0">{
                return savePointer.SavePoint(tx, name)
        }</span> else<span class="cov0" title="0"> {
                return gorm.ErrUnsupportedDriver
        }</span>
}
func (s shardingDialector) RollbackTo(tx *gorm.DB, name string) error <span class="cov0" title="0">{
        if savePointer, ok := s.Dialector.(gorm.SavePointerDialectorInterface); ok </span><span class="cov0" title="0">{
                return savePointer.RollbackTo(tx, name)
        }</span> else<span class="cov0" title="0"> {
                return gorm.ErrUnsupportedDriver
        }</span>
}

type shardingMigrator struct {
        gorm.Migrator
        db          *gorm.DB
        dialector   gorm.Dialector
        shardingMap map[string]*tableSharding
}

func (s *shardingMigrator) AutoMigrate(dst ...any) (err error) <span class="cov5" title="210">{
        sharding, ok := s.shardingMap[s.tableName(s.db, dst[0])]
        if !ok </span><span class="cov4" title="50">{
                defer (*tableSharding)(nil).ignore(s.db)() //nolint: revive // partial calling issue
                return s.Migrator.AutoMigrate(dst...)
        }</span>

        <span class="cov5" title="160">stmt := &amp;gorm.Statement{DB: sharding.DB}
        if sharding.isIgnored(sharding.DB)() </span><span class="cov0" title="0">{
                return s.dialector.Migrator(stmt.DB.Session(&amp;gorm.Session{})).AutoMigrate(dst...)
        }</span>

        <span class="cov5" title="160">shardingDst, err := s.getShardingDst(sharding, dst...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="160">defer sharding.ignore(sharding.DB)() //nolint: revive // partial calling issue
        for _, sd := range shardingDst </span><span class="cov6" title="945">{
                tx := stmt.DB.Session(&amp;gorm.Session{}).Table(sd.table)
                if err = s.dialector.Migrator(tx).AutoMigrate(sd.dst); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="160">return</span>
}
func (s *shardingMigrator) DropTable(dst ...any) (err error) <span class="cov5" title="210">{
        sharding, ok := s.shardingMap[s.tableName(s.db, dst[0])]
        if !ok </span><span class="cov4" title="50">{
                defer (*tableSharding)(nil).ignore(s.db)() //nolint: revive // partial calling issue
                return s.Migrator.DropTable(dst...)
        }</span>

        <span class="cov5" title="160">stmt := &amp;gorm.Statement{DB: sharding.DB}
        if sharding.isIgnored(sharding.DB)() </span><span class="cov0" title="0">{
                return s.dialector.Migrator(stmt.DB.Session(&amp;gorm.Session{})).DropTable(dst...)
        }</span>
        <span class="cov5" title="160">shardingDst, err := s.getShardingDst(sharding, dst...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="160">defer sharding.ignore(sharding.DB)() //nolint: revive // partial calling issue
        for _, sd := range shardingDst </span><span class="cov6" title="945">{
                tx := stmt.DB.Session(&amp;gorm.Session{}).Table(sd.table)
                if err = s.dialector.Migrator(tx).DropTable(sd.table); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="160">return</span>
}

type shardingDst struct {
        table string
        dst   any
}

func (s *shardingMigrator) getShardingDst(sharding *tableSharding, src ...any) (dst []shardingDst, err error) <span class="cov5" title="320">{
        for _, model := range src </span><span class="cov5" title="320">{
                stmt := &amp;gorm.Statement{DB: sharding.DB}
                if err = stmt.Parse(model); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // support sharding table
                <span class="cov5" title="320">suffixes, err := sharding.suffixes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="320">if len(suffixes) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sharding table:%s suffixes are empty", stmt.Table)
                }</span>
                <span class="cov5" title="320">for _, suffix := range suffixes </span><span class="cov7" title="1890">{
                        dst = append(dst, shardingDst{
                                table: stmt.Table + suffix,
                                dst:   model,
                        })
                }</span>
        }
        <span class="cov5" title="320">return</span>
}
func (s *shardingMigrator) tableName(db *gorm.DB, m any) (name string) <span class="cov6" title="420">{
        if tabler, ok := m.(schema.Tabler); ok </span><span class="cov6" title="420">{
                name = tabler.TableName()
        }</span>
        <span class="cov6" title="420">if tabler, ok := m.(schema.TablerWithNamer); ok </span><span class="cov0" title="0">{
                name = tabler.TableName(db.NamingStrategy)
        }</span>
        <span class="cov6" title="420">namingStrategy := reflect.ValueOf(db.NamingStrategy)
        if namingStrategy.CanConvert(gormSchemaEmbeddedNamer) </span><span class="cov0" title="0">{
                name = reflect.Indirect(namingStrategy.Convert(gormSchemaEmbeddedNamer)).FieldByName("Table").String()
        }</span>
        <span class="cov6" title="420">return</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package softdelete

import (
        "database/sql/driver"
        "strconv"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"

        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

type Deleted bool

// Scan implements the Scanner interface.
func (s *Deleted) Scan(value any) (err error) <span class="cov6" title="30">{
        var b bool
        if err = convertAssignRows(&amp;b, value, nil); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="30">*s = Deleted(b)
        return</span>
}

// Value implements the driver Valuer interface.
func (s Deleted) Value() (driver.Value, error) <span class="cov9" title="219">{
        return bool(s), nil
}</span>

func (s Deleted) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(bool(s))
}</span>
func (s *Deleted) UnmarshalJSON(bs []byte) error <span class="cov0" title="0">{
        if string(bs) == "null" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var b bool
        err := json.Unmarshal(bs, &amp;b)
        if err == nil </span><span class="cov0" title="0">{
                *s = Deleted(b)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (Deleted) QueryClauses(f *schema.Field) []clause.Interface <span class="cov4" title="11">{
        return []clause.Interface{deletedQueryClause{Field: f, ZeroValue: parseStatusZeroValueTag(f)}}
}</span>

type deletedQueryClause struct {
        ZeroValue Deleted
        Field     *schema.Field
}

func (s deletedQueryClause) Name() string <span class="cov0" title="0">{
        return ""
}</span>
func (s deletedQueryClause) Build(clause.Builder) {<span class="cov0" title="0">
}</span>
func (s deletedQueryClause) MergeClause(*clause.Clause) {<span class="cov0" title="0">
}</span>
func (s deletedQueryClause) ModifyStatement(stmt *gorm.Statement) <span class="cov10" title="320">{
        if _, ok := stmt.Clauses[statusEnabledFlag]; ok || stmt.Statement.Unscoped </span><span class="cov9" title="255">{
                return
        }</span>

        <span class="cov7" title="65">if c, ok := stmt.Clauses["WHERE"]; ok </span><span class="cov7" title="65">{
                if where, ok := c.Expression.(clause.Where); ok &amp;&amp; len(where.Exprs) &gt;= 1 </span><span class="cov7" title="65">{
                        for _, expr := range where.Exprs </span><span class="cov8" title="110">{
                                if orCond, ok := expr.(clause.OrConditions); ok &amp;&amp; len(orCond.Exprs) == 1 </span><span class="cov0" title="0">{
                                        where.Exprs = []clause.Expression{clause.And(where.Exprs...)}
                                        c.Expression = where
                                        stmt.Clauses["WHERE"] = c
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="65">stmt.AddClause(clause.Where{Exprs: []clause.Expression{
                clause.Eq{Column: clause.Column{Table: clause.CurrentTable, Name: s.Field.DBName}, Value: s.ZeroValue},
        }})
        stmt.Clauses[statusEnabledFlag] = clause.Clause{}</span>
}

func (Deleted) UpdateClauses(f *schema.Field) []clause.Interface <span class="cov4" title="11">{
        return []clause.Interface{deletedUpdateClause{Field: f, ZeroValue: parseStatusZeroValueTag(f)}}
}</span>

type deletedUpdateClause struct {
        ZeroValue Deleted
        Field     *schema.Field
}

func (s deletedUpdateClause) Name() string <span class="cov0" title="0">{
        return ""
}</span>
func (s deletedUpdateClause) Build(clause.Builder) {<span class="cov0" title="0">
}</span>
func (s deletedUpdateClause) MergeClause(*clause.Clause) {<span class="cov0" title="0">
}</span>
func (s deletedUpdateClause) ModifyStatement(stmt *gorm.Statement) <span class="cov4" title="10">{
        if stmt.SQL.Len() == 0 &amp;&amp; !stmt.Statement.Unscoped </span><span class="cov4" title="10">{
                deletedQueryClause(s).ModifyStatement(stmt)
        }</span>
}

func (Deleted) DeleteClauses(f *schema.Field) []clause.Interface <span class="cov4" title="11">{
        return []clause.Interface{deletedDeleteClause{Field: f, ZeroValue: parseStatusZeroValueTag(f)}}
}</span>

type deletedDeleteClause struct {
        ZeroValue Deleted
        Field     *schema.Field
}

func (s deletedDeleteClause) Name() string <span class="cov0" title="0">{
        return ""
}</span>
func (s deletedDeleteClause) Build(clause.Builder) {<span class="cov0" title="0">
}</span>
func (s deletedDeleteClause) MergeClause(*clause.Clause) {<span class="cov0" title="0">
}</span>
func (s deletedDeleteClause) ModifyStatement(stmt *gorm.Statement) <span class="cov6" title="40">{
        deleted := true
        setClauses := clause.Set{{Column: clause.Column{Name: s.Field.DBName}, Value: deleted}}
        if clauses, ok := stmt.Clauses[setClauses.Name()]; ok </span><span class="cov6" title="25">{
                if exprClauses, ok := clauses.Expression.(clause.Set); ok </span><span class="cov6" title="25">{
                        setClauses = append(setClauses, exprClauses...)
                }</span>
        }
        <span class="cov6" title="40">stmt.AddClause(setClauses)
        stmt.SetColumn(s.Field.DBName, deleted, true)

        deletedQueryClause(s).ModifyStatement(stmt)</span>
}

func parseStatusZeroValueTag(f *schema.Field) (s Deleted) <span class="cov6" title="33">{
        if v, ok := f.TagSettings["ZEROVALUE"]; ok </span><span class="cov0" title="0">{
                if vv, err := strconv.ParseBool(v); err == nil </span><span class="cov0" title="0">{
                        return Deleted(vv)
                }</span>
        }
        <span class="cov6" title="33">return Deleted(false)</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package softdelete

import (
        "log"
        "sync"
        "syscall"

        "github.com/pkg/errors"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/gomonkey"
        "github.com/wfusion/gofusion/config"
)

var (
        PatchGormDeleteAtOnce = new(sync.Once)
)

func PatchGormDeleteAt() (patches *gomonkey.Patches) <span class="cov10" title="34">{
        PatchGormDeleteAtOnce.Do(func() </span><span class="cov9" title="32">{
                pid := syscall.Getpid()
                _, err := utils.Catch(func() </span><span class="cov9" title="32">{
                        patches = gomonkey.ApplyMethod(gorm.SoftDeleteDeleteClause{},
                                "ModifyStatement", gormSoftDeleteDeleteClauseModifyStatement)
                        log.Printf("%v [Gofusion] %s patch gorm.SoftDeleteDeleteClause success", pid, config.ComponentDB)
                }</span>)
                <span class="cov9" title="32">if err != nil </span><span class="cov9" title="32">{
                        log.Printf("%v [Gofusion] %s patch gorm.SoftDeleteDeleteClause failed: %s",
                                pid, config.ComponentDB, errors.Cause(err))
                }</span>
        })

        <span class="cov10" title="34">return</span>
}

func gormSoftDeleteDeleteClauseModifyStatement(sd gorm.SoftDeleteDeleteClause, stmt *gorm.Statement) <span class="cov0" title="0">{
        if stmt.Statement.Unscoped || stmt.SQL.Len() &gt; 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">curTime := stmt.DB.NowFunc()
        setClauses := clause.Set{{Column: clause.Column{Name: sd.Field.DBName}, Value: curTime}}
        if clauses, ok := stmt.Clauses[setClauses.Name()]; ok </span><span class="cov0" title="0">{
                if exprClauses, ok := clauses.Expression.(clause.Set); ok </span><span class="cov0" title="0">{
                        setClauses = append(setClauses, exprClauses...)
                }</span>
        }
        <span class="cov0" title="0">stmt.AddClause(setClauses)
        stmt.SetColumn(sd.Field.DBName, curTime, true)

        gorm.SoftDeleteQueryClause(sd).ModifyStatement(stmt)</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package softdelete

import (
        "database/sql"
        "database/sql/driver"
        "strconv"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

type Timestamp sql.NullInt64

// Scan implements the Scanner interface.
func (t *Timestamp) Scan(value any) error <span class="cov5" title="15">{
        return (*sql.NullInt64)(t).Scan(value)
}</span>

// Value implements the driver Valuer interface.
func (t Timestamp) Value() (driver.Value, error) <span class="cov6" title="44">{
        if !t.Valid </span><span class="cov6" title="44">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return t.Int64, nil</span>
}

func (t Timestamp) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if t.Valid </span><span class="cov0" title="0">{
                return json.Marshal(t.Int64)
        }</span>
        <span class="cov0" title="0">return json.Marshal(nil)</span>
}
func (t *Timestamp) UnmarshalJSON(bs []byte) error <span class="cov0" title="0">{
        if string(bs) == "null" </span><span class="cov0" title="0">{
                t.Valid = false
                return nil
        }</span>
        <span class="cov0" title="0">err := json.Unmarshal(bs, &amp;t.Int64)
        if err == nil </span><span class="cov0" title="0">{
                t.Valid = true
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (Timestamp) QueryClauses(f *schema.Field) []clause.Interface <span class="cov4" title="11">{
        return []clause.Interface{TimestampQueryClause{Field: f, ZeroValue: parseTimestampZeroValueTag(f)}}
}</span>

type TimestampQueryClause struct {
        ZeroValue sql.NullInt64
        Field     *schema.Field
}

func (t TimestampQueryClause) Name() string <span class="cov0" title="0">{
        return ""
}</span>
func (t TimestampQueryClause) Build(clause.Builder) {<span class="cov0" title="0">
}</span>
func (t TimestampQueryClause) MergeClause(*clause.Clause) {<span class="cov0" title="0">
}</span>
func (t TimestampQueryClause) ModifyStatement(stmt *gorm.Statement) <span class="cov10" title="295">{
        if _, ok := stmt.Clauses[timestampEnabledFlag]; ok || stmt.Statement.Unscoped </span><span class="cov9" title="230">{
                return
        }</span>
        <span class="cov7" title="65">if c, ok := stmt.Clauses["WHERE"]; ok </span><span class="cov7" title="45">{
                if where, ok := c.Expression.(clause.Where); ok &amp;&amp; len(where.Exprs) &gt;= 1 </span><span class="cov7" title="45">{
                        for _, expr := range where.Exprs </span><span class="cov7" title="45">{
                                if orCond, ok := expr.(clause.OrConditions); ok &amp;&amp; len(orCond.Exprs) == 1 </span><span class="cov0" title="0">{
                                        where.Exprs = []clause.Expression{clause.And(where.Exprs...)}
                                        c.Expression = where
                                        stmt.Clauses["WHERE"] = c
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="65">stmt.AddClause(clause.Where{Exprs: []clause.Expression{
                clause.Eq{Column: clause.Column{Table: clause.CurrentTable, Name: t.Field.DBName}, Value: t.ZeroValue},
        }})
        stmt.Clauses[timestampEnabledFlag] = clause.Clause{}</span>
}

func (Timestamp) UpdateClauses(f *schema.Field) []clause.Interface <span class="cov4" title="11">{
        return []clause.Interface{TimestampUpdateClause{Field: f, ZeroValue: parseTimestampZeroValueTag(f)}}
}</span>

type TimestampUpdateClause struct {
        ZeroValue sql.NullInt64
        Field     *schema.Field
}

func (t TimestampUpdateClause) Name() string <span class="cov0" title="0">{
        return ""
}</span>
func (t TimestampUpdateClause) Build(clause.Builder) {<span class="cov0" title="0">
}</span>
func (t TimestampUpdateClause) MergeClause(*clause.Clause) {<span class="cov0" title="0">
}</span>
func (t TimestampUpdateClause) ModifyStatement(stmt *gorm.Statement) <span class="cov4" title="10">{
        if stmt.SQL.Len() == 0 &amp;&amp; !stmt.Statement.Unscoped </span><span class="cov4" title="10">{
                TimestampQueryClause(t).ModifyStatement(stmt)
        }</span>
}

func (Timestamp) DeleteClauses(f *schema.Field) []clause.Interface <span class="cov4" title="11">{
        return []clause.Interface{TimestampDeleteClause{Field: f, ZeroValue: parseTimestampZeroValueTag(f)}}
}</span>

type TimestampDeleteClause struct {
        ZeroValue sql.NullInt64
        Field     *schema.Field
}

func (t TimestampDeleteClause) Name() string <span class="cov0" title="0">{
        return ""
}</span>
func (t TimestampDeleteClause) Build(clause.Builder) {<span class="cov0" title="0">
}</span>
func (t TimestampDeleteClause) MergeClause(*clause.Clause) {<span class="cov0" title="0">
}</span>
func (t TimestampDeleteClause) ModifyStatement(stmt *gorm.Statement) <span class="cov6" title="40">{
        if stmt.Statement.Unscoped || stmt.SQL.Len() &gt; 0 </span><span class="cov6" title="25">{
                return
        }</span>

        <span class="cov5" title="15">curTimestamp := utils.GetTimeStamp(stmt.DB.NowFunc())
        setClauses := clause.Set{{Column: clause.Column{Name: t.Field.DBName}, Value: curTimestamp}}
        if clauses, ok := stmt.Clauses[setClauses.Name()]; ok </span><span class="cov0" title="0">{
                if exprClauses, ok := clauses.Expression.(clause.Set); ok </span><span class="cov0" title="0">{
                        setClauses = append(setClauses, exprClauses...)
                }</span>
        }
        <span class="cov5" title="15">stmt.AddClause(setClauses)
        stmt.SetColumn(t.Field.DBName, curTimestamp, true)

        TimestampQueryClause(t).ModifyStatement(stmt)</span>
}

func parseTimestampZeroValueTag(f *schema.Field) sql.NullInt64 <span class="cov6" title="33">{
        if v, ok := f.TagSettings["ZEROVALUE"]; ok </span><span class="cov0" title="0">{
                if vv, err := strconv.ParseInt(v, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return sql.NullInt64{Int64: vv, Valid: true}
                }</span>
        }
        <span class="cov6" title="33">return sql.NullInt64{Valid: false}</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package softdelete

import (
        "gorm.io/gorm/clause"

        "github.com/wfusion/gofusion/common/utils"
)

const (
        defaultEnabledFlag   = "soft_delete_enabled"
        statusEnabledFlag    = "soft_delete_enabled_status"
        timestampEnabledFlag = "soft_delete_enabled_timestamp"
        deletedAtEnabledFlag = "soft_delete_enabled_deletedat"
)

func IsClausesWithSoftDelete(clauses map[string]clause.Clause) (withSoftDelete bool) <span class="cov9" title="1372">{
        utils.IfAny(
                func() (ok bool) </span><span class="cov9" title="1372">{ _, withSoftDelete = clauses[defaultEnabledFlag]; return withSoftDelete }</span>,
                func() (ok bool) <span class="cov9" title="1331">{ _, withSoftDelete = clauses[statusEnabledFlag]; return withSoftDelete }</span>,
                func() (ok bool) <span class="cov9" title="1319">{ _, withSoftDelete = clauses[timestampEnabledFlag]; return withSoftDelete }</span>,
                func() (ok bool) <span class="cov9" title="1319">{ _, withSoftDelete = clauses[deletedAtEnabledFlag]; return withSoftDelete }</span>,
        )
        <span class="cov10" title="1374">return</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package db

import (
        "context"

        "gorm.io/gorm"

        "github.com/wfusion/gofusion/common/infra/drivers/orm"
        "github.com/wfusion/gofusion/common/utils"
)

type txOption struct {
        dbName string
}

func TxUse(name string) utils.OptionFunc[txOption] <span class="cov10" title="5">{
        return func(o *txOption) </span><span class="cov10" title="5">{
                o.dbName = name
        }</span>
}

// WithinTx  DAL 
func WithinTx(ctx context.Context, cb func(ctx context.Context) (err error), opts ...utils.OptionExtender) error <span class="cov10" title="5">{
        var db *DB

        o := utils.ApplyOptions[useOption](opts...)
        opt := utils.ApplyOptions[txOption](opts...)
        if opt.dbName == "" </span><span class="cov0" title="0">{
                db = GetCtxGormDB(ctx)
        }</span> else<span class="cov10" title="5"> {
                utils.IfAny(
                        func() bool </span><span class="cov10" title="5">{ db = GetCtxGormDBByName(ctx, opt.dbName); return db != nil }</span>,
                        func() bool <span class="cov0" title="0">{ db = Use(ctx, opt.dbName, AppName(o.appName)); return db != nil }</span>,
                )
        }
        <span class="cov10" title="5">if db == nil </span><span class="cov0" title="0">{
                panic(ErrDatabaseNotFound)</span>
        }

        <span class="cov10" title="5">return db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov10" title="5">{
                return cb(SetCtxGormDB(ctx, &amp;DB{
                        DB:                   &amp;orm.DB{DB: tx},
                        Name:                 db.Name,
                        tableShardingPlugins: db.tableShardingPlugins,
                }))
        }</span>)
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package http

import (
        "context"

        "github.com/gin-gonic/gin"
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/asynq/asynqmon"
        "github.com/wfusion/gofusion/redis"

        rdsDrv "github.com/redis/go-redis/v9"
)

func initAsynq(ctx context.Context, appName string, r IRouter, confs []asynqConf) <span class="cov7" title="10">{
        if len(confs) == 0 || r == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov7" title="10">for _, conf := range confs </span><span class="cov7" title="10">{
                switch conf.InstanceType </span>{
                case instanceTypeRedis:<span class="cov7" title="10"></span>
                default:<span class="cov0" title="0">
                        panic(errors.Errorf("unknown asynq instance type: %+v", conf.InstanceType))</span>
                }
                <span class="cov7" title="10">connOpt := &amp;asynqRedisConnOpt{UniversalClient: redis.Use(ctx, conf.Instance, redis.AppName(appName))}
                h := asynqmon.New(asynqmon.Options{
                        RootPath:          conf.Path,
                        RedisConnOpt:      connOpt,
                        PayloadFormatter:  nil,
                        ResultFormatter:   nil,
                        PrometheusAddress: conf.PrometheusAddress,
                        ReadOnly:          conf.Readonly,
                })

                r.Any(h.RootPath()+"/*any", gin.WrapH(h))</span>
        }
}

type asynqRedisConnOpt struct{ rdsDrv.UniversalClient }

func (a *asynqRedisConnOpt) MakeRedisClient() any <span class="cov10" title="20">{ return a.UniversalClient }</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package http

import (
        "context"
        "fmt"
        "net/http"
        "sync"

        "github.com/gin-contrib/pprof"
        "github.com/gin-gonic/gin"
        "github.com/pkg/errors"
        "golang.org/x/text/language"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/http/middleware"
        "github.com/wfusion/gofusion/i18n"
)

var (
        Router IRouter

        locker  sync.RWMutex
        routers = map[string]IRouter{}
)

func Construct(ctx context.Context, conf Conf, opts ...utils.OptionExtender) func() <span class="cov10" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov5" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov10" title="34">engine := gin.New()
        engine.Use(
                gin.Recovery(),
                middleware.Gateway,
                middleware.Trace(),
                middleware.Logging(opt.AppName, conf.LogInstance),
                middleware.Cors(),
                middleware.XSS(conf.XSSWhiteURLList),
                middleware.Recover(opt.AppName, conf.LogInstance),
        )
        if config.Use(opt.AppName).Debug() </span><span class="cov4" title="4">{
                gin.SetMode(gin.DebugMode)
        }</span> else<span class="cov9" title="30"> {
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov10" title="34">if !conf.ColorfulConsole </span><span class="cov10" title="34">{
                gin.DisableConsoleColor()
        }</span> else<span class="cov0" title="0"> {
                gin.ForceConsoleColor()
        }</span>

        <span class="cov10" title="34">engine.NoMethod(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Status(http.StatusMethodNotAllowed)
                Error(c, opt.AppName, -1, nil, 0, 0, fmt.Sprintf(", Method: %s", c.Request.Method))
        }</span>)
        <span class="cov10" title="34">engine.NoRoute(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Status(http.StatusNotFound)
                Error(c, opt.AppName, -1, nil, 0, 0, fmt.Sprintf(", URL: %s", c.Request.URL.String()))
        }</span>)

        <span class="cov10" title="34">engine.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                Success(c, opt.AppName, nil, 0, -1, "Api ")
        }</span>)

        <span class="cov10" title="34">if conf.Pprof </span><span class="cov0" title="0">{
                pprof.Register(engine)
        }</span>
        <span class="cov10" title="34">router := newRouter(engine, opt.AppName)

        locker.Lock()
        defer locker.Unlock()
        if len(conf.Asynq) &gt; 0 </span><span class="cov6" title="10">{
                initAsynq(ctx, opt.AppName, router, conf.Asynq)
        }</span>
        <span class="cov10" title="34">if _, ok := routers[opt.AppName]; ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("duplicated http name: %s", opt.AppName))</span>
        }
        <span class="cov10" title="34">routers[opt.AppName] = router
        if opt.AppName == "" </span><span class="cov5" title="5">{
                Router = router
        }</span>

        <span class="cov10" title="34">bundle := i18n.NewBundle[Errcode](i18n.DefaultLang(i18n.AppName(opt.AppName)))
        if I18n == nil </span><span class="cov8" title="16">{
                I18n = bundle
        }</span>
        <span class="cov10" title="34">if i18ns == nil </span><span class="cov7" title="12">{
                i18ns = make(map[string]i18n.Localizable[Errcode])
        }</span>
        <span class="cov10" title="34">i18ns[opt.AppName] = bundle

        // ioc
        if opt.DI != nil </span><span class="cov10" title="34">{
                opt.DI.MustProvide(func() i18n.Localizable[Errcode] </span><span class="cov1" title="1">{ return bundle }</span>)
                <span class="cov10" title="34">opt.DI.MustProvide(func() IRouter </span><span class="cov0" title="0">{ return Use(AppName(opt.AppName)) }</span>)
        }

        // initialize http internal error
        <span class="cov10" title="34">bundle.AddMessages(errParam, map[language.Tag]*i18n.Message{
                language.English: {Other: "Invalid request parameters{{.err}}"},
                language.Chinese: {Other: "{{.err}}"},
        }, i18n.Var("err"))

        // gracefully exit outside gofusion
        return func() </span><span class="cov10" title="34">{
                locker.Lock()
                defer locker.Unlock()
                if i18ns != nil </span><span class="cov10" title="34">{
                        delete(i18ns, opt.AppName)
                }</span>
                <span class="cov10" title="34">if routers != nil </span><span class="cov10" title="34">{
                        delete(routers, opt.AppName)
                }</span>
                <span class="cov10" title="34">if opt.AppName == "" </span><span class="cov5" title="5">{
                        I18n = nil
                        Router = nil
                }</span>
        }
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov7" title="11">{
        return func(o *useOption) </span><span class="cov7" title="11">{
                o.appName = name
        }</span>
}

func Use(opts ...utils.OptionExtender) IRouter <span class="cov7" title="11">{
        opt := utils.ApplyOptions[useOption](opts...)
        locker.RLock()
        defer locker.RUnlock()

        router, ok := routers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("router not found"))</span>
        }
        <span class="cov7" title="11">return router</span>
}

func init() <span class="cov7" title="14">{
        config.AddComponent(config.ComponentHttp, Construct)
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">package consts

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/spf13/cast"
)

const (
        ctxReqStartAtKey = "http:req_start_at"
        ctxReqCostKey    = "http:req_cost"
)

func SetReqStartTime(c *gin.Context) <span class="cov8" title="1">{
        c.Set(ctxReqStartAtKey, time.Now())
}</span>

func GetReqCost(c *gin.Context) time.Duration <span class="cov8" title="1">{
        if cost, ok := c.Get(ctxReqCostKey); ok </span><span class="cov0" title="0">{
                return cast.ToDuration(cost)
        }</span>

        <span class="cov8" title="1">start := time.Now()
        if _, ok := c.Get(ctxReqStartAtKey); ok </span><span class="cov8" title="1">{
                start = c.GetTime(ctxReqStartAtKey)
        }</span>
        <span class="cov8" title="1">cost := time.Since(start)
        c.Set(ctxReqCostKey, cost)
        return cost</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package http

import (
        "context"
        "strconv"

        "github.com/gin-gonic/gin"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/i18n"

        fmkCtx "github.com/wfusion/gofusion/context"
)

const (
        errParam Errcode = 10000 // 00010000
)

type Errcode int

// String Here, i18n cannot be used for localization,
// because in Localize, since the code is of string type, the process of doing toString will lead to stack overflow.
func (e Errcode) String() (r string) <span class="cov10" title="35">{
        return strconv.Itoa(int(e))
}</span>
func (e Errcode) Error() (r string) <span class="cov0" title="0">{
        return I18n.Localize(e)
}</span>

type errOption struct {
        msg   string
        langs []string
        param map[string]any
}

func Langs(c *gin.Context) utils.OptionFunc[errOption] <span class="cov0" title="0">{
        return func(e *errOption) </span><span class="cov0" title="0">{
                e.langs = langs(c)
        }</span>
}

func Param(param map[string]any) utils.OptionFunc[errOption] <span class="cov0" title="0">{
        return func(e *errOption) </span><span class="cov0" title="0">{
                e.param = param
        }</span>
}

func Msg(msg string) utils.OptionFunc[errOption] <span class="cov0" title="0">{
        return func(e *errOption) </span><span class="cov0" title="0">{
                e.msg = msg
        }</span>
}

// Err customized message
func Err(c *gin.Context, code Errcode, opts ...utils.OptionExtender) error <span class="cov0" title="0">{
        opt := utils.ApplyOptions[errOption](opts...)
        if len(opt.langs) == 0 </span><span class="cov0" title="0">{
                opt.langs = langs(c)
        }</span>
        <span class="cov0" title="0">return &amp;bizErr{
                code:      code,
                errOption: opt,
        }</span>
}

// ErrCtx customized message
func ErrCtx(ctx context.Context, code Errcode, opts ...utils.OptionExtender) error <span class="cov0" title="0">{
        opt := utils.ApplyOptions[errOption](opts...)
        if len(opt.langs) == 0 </span><span class="cov0" title="0">{
                opt.langs = fmkCtx.GetLangs(ctx)
        }</span>
        <span class="cov0" title="0">return &amp;bizErr{
                code:      code,
                errOption: opt,
        }</span>
}

type bizErr struct {
        *errOption
        code Errcode
}

func (b *bizErr) Error() (r string) <span class="cov0" title="0">{
        if b.msg != "" </span><span class="cov0" title="0">{
                return b.msg
        }</span>
        <span class="cov0" title="0">return I18n.Localize(b.code, i18n.Langs(b.langs), i18n.Param(b.param))</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">// fork from github.com/fvbock/endless@v0.0.0-20170109170031-447134032cb6
// modified:
// 1. support windows signals
// 2. log content
// 3. close by http.Serve.ShutDown() rather than listener.Close()
// 4. make sure Serve() exit after Shutdown() triggered by signals
// 5. implement *net.TcpConn all public methods

package gracefully

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "os"
        "os/exec"
        "runtime"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/routine"
)

const (
        PreSignal = iota
        PostSignal

        StateInit
        StateRunning
        StateShuttingDown
        StateTerminate
)

var (
        DefaultReadTimeOut    time.Duration
        DefaultWriteTimeOut   time.Duration
        DefaultMaxHeaderBytes int
        DefaultHammerTime     time.Duration

        runningServerReg     sync.RWMutex
        runningServers       map[string]*endlessServer
        runningServersOrder  []string
        socketPtrOffsetMap   map[string]uint
        runningServersForked bool

        isChild     bool
        socketOrder string
)

func init() <span class="cov10" title="14">{
        runningServerReg = sync.RWMutex{}
        runningServers = make(map[string]*endlessServer)
        runningServersOrder = []string{}
        socketPtrOffsetMap = make(map[string]uint)

        DefaultMaxHeaderBytes = 0 // use http.DefaultMaxHeaderBytes - which currently is 1 &lt;&lt; 20 (1MB)

        // after a restart the parent will finish ongoing requests before
        // shutting down. set to a negative value to disable
        DefaultHammerTime = 60 * time.Second
}</span>

type endlessServer struct {
        *http.Server
        SignalHooks map[int]map[os.Signal][]func()
        BeforeBegin func(addr string)
        AppName     string

        endlessListener  net.Listener
        tlsInnerListener *endlessListener
        close            chan struct{}
        wg               sync.WaitGroup
        sigChan          chan os.Signal
        isChild          bool
        state            uint8
        lock             *sync.RWMutex
}

// NewServer returns an initialized endlessServer Object. Calling Serve on it will
// actually "start" the server.
func NewServer(appName string, handler http.Handler, addr string, nextProtos []string) (srv *endlessServer) <span class="cov0" title="0">{
        runningServerReg.Lock()
        defer runningServerReg.Unlock()

        socketOrder = os.Getenv("ENDLESS_SOCKET_ORDER")
        isChild = os.Getenv("ENDLESS_CONTINUE") != ""

        if len(socketOrder) &gt; 0 </span><span class="cov0" title="0">{
                for i, addr := range strings.Split(socketOrder, ",") </span><span class="cov0" title="0">{
                        socketPtrOffsetMap[addr] = uint(i)
                }</span>
        } else<span class="cov0" title="0"> {
                socketPtrOffsetMap[addr] = uint(len(runningServersOrder))
        }</span>

        <span class="cov0" title="0">srv = &amp;endlessServer{
                AppName: appName,
                Server: &amp;http.Server{
                        Addr:           addr,
                        ReadTimeout:    DefaultReadTimeOut,
                        WriteTimeout:   DefaultWriteTimeOut,
                        MaxHeaderBytes: DefaultMaxHeaderBytes,
                        Handler:        handler,
                        TLSConfig:      &amp;tls.Config{NextProtos: nextProtos},
                },
                sigChan:     make(chan os.Signal),
                isChild:     isChild,
                SignalHooks: newSignalHookFunc(),
                state:       StateInit,
                lock:        new(sync.RWMutex),
        }

        runningServersOrder = append(runningServersOrder, addr)
        runningServers[addr] = srv

        return</span>
}

// ListenAndServe listens on the TCP network address addr and then calls Serve
// with handler to handle requests on incoming connections. Handler is typically
// nil, in which case the DefaultServeMux is used.
func ListenAndServe(appName string, handler http.Handler, addr string, nextProtos []string) error <span class="cov0" title="0">{
        server := NewServer(appName, handler, addr, nextProtos)
        return server.ListenAndServe()
}</span>

// ListenAndServeTLS acts identically to ListenAndServe, except that it expects
// HTTPS connections. Additionally, files containing a certificate and matching
// private key for the server must be provided. If the certificate is signed by a
// certificate authority, the certFile should be the concatenation of the server's
// certificate followed by the CA's certificate.
func ListenAndServeTLS(appName string, handler http.Handler, addr, certFile, keyFile string, nextProtos []string) error <span class="cov0" title="0">{
        server := NewServer(appName, handler, addr, nextProtos)
        return server.ListenAndServeTLS(certFile, keyFile)
}</span>

// Serve accepts incoming HTTP connections on the listener l, creating a new
// service goroutine for each. The service goroutines read requests and then call
// handler to reply to them. Handler is typically nil, in which case the
// DefaultServeMux is used.
//
// In addition to the stl Serve behaviour each connection is added to a
// sync.WaitGroup so that all outstanding connections can be served before shutting
// down the server.
func (e *endlessServer) Serve() (err error) <span class="cov0" title="0">{
        defer log.Println(syscall.Getpid(), "[Common] endless exited.")

        e.setState(StateRunning)
        log.Println(syscall.Getpid(), "[Common] endless listening", e.endlessListener.Addr())

        // ignore server closed error because it happened when we call Server.Shutdown or Server.Close
        if err = e.Server.Serve(e.endlessListener); err != nil </span><span class="cov0" title="0">{
                // http: Server closed
                // use of closed network connection
                if errors.Is(err, http.ErrServerClosed) || isClosedConnError(err) </span><span class="cov0" title="0">{
                        err = nil
                }</span>
        }
        <span class="cov0" title="0">log.Println(syscall.Getpid(), "[Common] endless waiting for connections to finish...")
        e.wg.Wait()
        e.setState(StateTerminate)

        if e.close != nil </span><span class="cov0" title="0">{
                &lt;-e.close
        }</span>
        <span class="cov0" title="0">e.close = nil

        return</span>
}

// ListenAndServe listens on the TCP network address srv.Addr and then calls Serve
// to handle requests on incoming connections. If srv.Addr is blank, ":http" is
// used.
func (e *endlessServer) ListenAndServe() (err error) <span class="cov0" title="0">{
        addr := e.Addr
        if addr == "" </span><span class="cov0" title="0">{
                addr = ":http"
        }</span>

        <span class="cov0" title="0">if err = setupHTTP2_Serve(e.Server); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">routine.Go(e.handleSignals, routine.AppName(e.AppName))

        l, err := e.getListener(addr)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(syscall.Getpid(), "[Common] endless", err)
                return
        }</span>

        <span class="cov0" title="0">e.endlessListener = newEndlessListener(l, e)
        if e.isChild </span><span class="cov0" title="0">{
                _ = syscallKill(syscall.Getppid())
        }</span>

        <span class="cov0" title="0">if e.BeforeBegin != nil </span><span class="cov0" title="0">{
                e.BeforeBegin(e.Addr)
        }</span>

        <span class="cov0" title="0">return e.Serve()</span>
}

// ListenAndServeTLS listens on the TCP network address srv.Addr and then calls
// Serve to handle requests on incoming TLS connections.
//
// Filenames containing a certificate and matching private key for the server must
// be provided. If the certificate is signed by a certificate authority, the
// certFile should be the concatenation of the server's certificate followed by the
// CA's certificate.
//
// If srv.Addr is blank, ":https" is used.
func (e *endlessServer) ListenAndServeTLS(certFile, keyFile string) (err error) <span class="cov0" title="0">{
        addr := e.Addr
        if addr == "" </span><span class="cov0" title="0">{
                addr = ":https"
        }</span>

        // Setup HTTP/2 before srv.Serve, to initialize srv.TLSConfig
        // before we clone it and create the TLS Listener.
        <span class="cov0" title="0">if err = setupHTTP2_ServeTLS(e.Server); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">config := new(tls.Config)
        if e.Server.TLSConfig != nil </span><span class="cov0" title="0">{
                *config = *e.Server.TLSConfig.Clone()
        }</span>
        <span class="cov0" title="0">if !utils.NewSet(config.NextProtos...).Contains("http/1.1") </span><span class="cov0" title="0">{
                config.NextProtos = append(config.NextProtos, "http/1.1")
        }</span>

        <span class="cov0" title="0">configHasCert := len(config.Certificates) &gt; 0 || config.GetCertificate != nil
        if !configHasCert || certFile != "" || keyFile != "" </span><span class="cov0" title="0">{
                config.Certificates = make([]tls.Certificate, 1)
                config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">routine.Go(e.handleSignals, routine.AppName(e.AppName))

        l, err := e.getListener(addr)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(syscall.Getpid(), "[Common] endless error occur when get listener:", err)
                return
        }</span>

        <span class="cov0" title="0">e.tlsInnerListener = newEndlessListener(l, e)
        e.endlessListener = tls.NewListener(e.tlsInnerListener, config)
        if e.isChild </span><span class="cov0" title="0">{
                _ = syscallKill(syscall.Getppid())
        }</span>

        <span class="cov0" title="0">return e.Serve()</span>
}

// Shutdown closes the listener so that none new connections are accepted. it also
// starts a goroutine that will hammer (stop all running requests) the server
// after DefaultHammerTime.
func (e *endlessServer) Shutdown() <span class="cov0" title="0">{
        // make sure server Shutdown &amp; log printed before Serve() return
        e.close = make(chan struct{})
        defer close(e.close)

        if e.getState() != StateRunning </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">e.setState(StateShuttingDown)
        if DefaultHammerTime &gt;= 0 </span><span class="cov0" title="0">{
                routine.Loop(e.hammerTime, routine.Args(DefaultHammerTime), routine.AppName(e.AppName))
        }</span>
        // disable keep-alive on existing connections
        <span class="cov0" title="0">e.Server.SetKeepAlivesEnabled(false)

        // TODO: new context with timeout because system may forcefully kill the program
        if err := e.Server.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                log.Println(syscall.Getpid(), "[Common] endless close listener error:", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println(syscall.Getpid(), "[Common] endless", e.endlessListener.Addr(), "listener closed.")
        }</span>
}

// RegisterSignalHook registers a function to be run PreSignal or PostSignal for
// a given signal. PRE or POST in this case means before or after the signal
// related code endless itself runs
func (e *endlessServer) RegisterSignalHook(prePost int, sig os.Signal, f func()) (err error) <span class="cov0" title="0">{
        if prePost != PreSignal &amp;&amp; prePost != PostSignal </span><span class="cov0" title="0">{
                err = fmt.Errorf("cannot use %v for prePost arg. Must be endless.PRE_SIGNAL or endless.POST_SIGNAL", sig)
                return
        }</span>
        <span class="cov0" title="0">for _, s := range hookableSignals </span><span class="cov0" title="0">{
                if s == sig </span><span class="cov0" title="0">{
                        e.SignalHooks[prePost][sig] = append(e.SignalHooks[prePost][sig], f)
                        return
                }</span>
        }
        <span class="cov0" title="0">err = fmt.Errorf("signal %v is not supported", sig)
        return</span>
}

// getListener either opens a new socket to listen on, or takes the acceptor socket
// it got passed when restarted.
func (e *endlessServer) getListener(addr string) (l net.Listener, err error) <span class="cov0" title="0">{
        if e.isChild </span><span class="cov0" title="0">{
                ptrOffset := uint(0)
                runningServerReg.RLock()
                defer runningServerReg.RUnlock()
                if len(socketPtrOffsetMap) &gt; 0 </span><span class="cov0" title="0">{
                        ptrOffset = socketPtrOffsetMap[addr]
                        log.Println(syscall.Getpid(), "[Common] endless addr:", addr, "ptr offset:", socketPtrOffsetMap[addr])
                }</span>

                <span class="cov0" title="0">f := os.NewFile(uintptr(3+ptrOffset), "")
                l, err = net.FileListener(f)
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("net.FileListener error: %v", err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                l, err = net.Listen("tcp", addr)
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("net.Listen error: %v", err)
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (e *endlessServer) signalHooks(ppFlag int, sig os.Signal) <span class="cov0" title="0">{
        if _, notSet := e.SignalHooks[ppFlag][sig]; !notSet </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, f := range e.SignalHooks[ppFlag][sig] </span><span class="cov0" title="0">{
                f()
        }</span>
}

// hammerTime forces the server to shut down in a given timeout - whether it
// finished outstanding requests or not. if Read/WriteTimeout are not set or the
// max header size is very big a connection could hang...
//
// srv.Serve() will not return until all connections are served. this will
// unblock the srv.wg.Wait() in Serve() thus causing ListenAndServe(TLS) to
// return.
func (e *endlessServer) hammerTime(d time.Duration) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // we are calling e.wg.Done() until it panics which means we called
                // Done() when the counter was already at 0, and we're done.
                // (and thus Serve() will return and the parent will exit)
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Println(syscall.Getpid(), "[Common] endless wait group at 0", r)
                }</span>
        }()
        <span class="cov0" title="0">if e.getState() != StateShuttingDown </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">time.Sleep(d)
        log.Println(syscall.Getpid(), "[Common] endless harmerTime() forcefully shutting down parent")
        for </span><span class="cov0" title="0">{
                if e.getState() == StateTerminate </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">e.wg.Done()
                runtime.Gosched()</span>
        }
}

func (e *endlessServer) fork() (err error) <span class="cov0" title="0">{
        runningServerReg.Lock()
        defer runningServerReg.Unlock()

        // only one server instance should fork!
        if runningServersForked </span><span class="cov0" title="0">{
                return errors.New("another process already forked, ignoring this one")
        }</span>

        <span class="cov0" title="0">runningServersForked = true

        var files = make([]*os.File, len(runningServers))
        var orderArgs = make([]string, len(runningServers))
        // get the accessor socket fds for _all_ server instances
        for _, srvPtr := range runningServers </span><span class="cov0" title="0">{
                // introspect.PrintTypeDump(srvPtr.endlessListener)
                switch srvPtr.endlessListener.(type) </span>{
                case *endlessListener:<span class="cov0" title="0">
                        // normal listener
                        files[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.endlessListener.(*endlessListener).File()</span>
                default:<span class="cov0" title="0">
                        // tls listener
                        files[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.tlsInnerListener.File()</span>
                }
                <span class="cov0" title="0">orderArgs[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.Server.Addr</span>
        }

        <span class="cov0" title="0">env := append(
                os.Environ(),
                "ENDLESS_CONTINUE=1",
        )
        if len(runningServers) &gt; 1 </span><span class="cov0" title="0">{
                env = append(env, fmt.Sprintf(`ENDLESS_SOCKET_ORDER=%s`, strings.Join(orderArgs, ",")))
        }</span>

        <span class="cov0" title="0">path := os.Args[0]
        var args []string
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                args = os.Args[1:]
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(path, args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.ExtraFiles = files
        cmd.Env = env

        if err = cmd.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%v [Common] endless restart: failed to launch, error: %v", syscall.Getpid(), err)
        }</span>

        <span class="cov0" title="0">return</span>
}

func (e *endlessServer) getState() uint8 <span class="cov0" title="0">{
        e.lock.RLock()
        defer e.lock.RUnlock()

        return e.state
}</span>

func (e *endlessServer) setState(st uint8) <span class="cov0" title="0">{
        e.lock.Lock()
        defer e.lock.Unlock()

        e.state = st
}</span>

type endlessListener struct {
        net.Listener
        stopped bool
        server  *endlessServer
}

func newEndlessListener(l net.Listener, srv *endlessServer) (el *endlessListener) <span class="cov0" title="0">{
        return &amp;endlessListener{
                Listener: l,
                server:   srv,
        }
}</span>

func (e *endlessListener) Accept() (c net.Conn, err error) <span class="cov0" title="0">{
        tc, err := e.Listener.(*net.TCPListener).AcceptTCP()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // see net/http.tcpKeepAliveListener
        <span class="cov0" title="0">_ = tc.SetKeepAlive(true)
        // see net/http.tcpKeepAliveListener
        _ = tc.SetKeepAlivePeriod(3 * time.Minute)

        c = endlessConn{
                Conn:     tc,
                doneOnce: new(sync.Once),
                server:   e.server,
        }

        e.server.wg.Add(1)
        return</span>
}

func (e *endlessListener) File() *os.File <span class="cov0" title="0">{
        // returns a dup(2) - FD_CLOEXEC flag *not* set
        tl := e.Listener.(*net.TCPListener)
        fl, _ := tl.File()
        return fl
}</span>

type endlessConn struct {
        net.Conn
        doneOnce *sync.Once
        server   *endlessServer
}

// Read reads data from the connection.
// Read can be made to time out and return an error after a fixed
// time limit; see SetDeadline and SetReadDeadline.
func (e endlessConn) Read(b []byte) (n int, err error) <span class="cov0" title="0">{ return e.Conn.Read(b) }</span>

// Write writes data to the connection.
// Write can be made to time out and return an error after a fixed
// time limit; see SetDeadline and SetWriteDeadline.
func (e endlessConn) Write(b []byte) (n int, err error) <span class="cov0" title="0">{ return e.Conn.Write(b) }</span>

// Close closes the connection.
// Any blocked Read or Write operations will be unblocked and return errors.
func (e endlessConn) Close() (err error) <span class="cov0" title="0">{
        defer e.doneOnce.Do(func() </span><span class="cov0" title="0">{ e.server.wg.Done() }</span>)
        <span class="cov0" title="0">return e.Conn.Close()</span>
}

// LocalAddr returns the local network address, if known.
func (e endlessConn) LocalAddr() net.Addr <span class="cov0" title="0">{ return e.Conn.LocalAddr() }</span>

// RemoteAddr returns the remote network address, if known.
func (e endlessConn) RemoteAddr() net.Addr <span class="cov0" title="0">{ return e.Conn.RemoteAddr() }</span>

// SetDeadline sets the read and write deadlines associated
// with the connection. It is equivalent to calling both
// SetReadDeadline and SetWriteDeadline.
//
// A deadline is an absolute time after which I/O operations
// fail instead of blocking. The deadline applies to all future
// and pending I/O, not just the immediately following call to
// Read or Write. After a deadline has been exceeded, the
// connection can be refreshed by setting a deadline in the future.
//
// If the deadline is exceeded a call to Read or Write or to other
// I/O methods will return an error that wraps os.ErrDeadlineExceeded.
// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
// The error's Timeout method will return true, but note that there
// are other possible errors for which the Timeout method will
// return true even if the deadline has not been exceeded.
//
// An idle timeout can be implemented by repeatedly extending
// the deadline after successful Read or Write calls.
//
// A zero value for t means I/O operations will not time out.
func (e endlessConn) SetDeadline(t time.Time) error <span class="cov0" title="0">{ return e.Conn.SetDeadline(t) }</span>

// SetReadDeadline sets the deadline for future Read calls
// and any currently-blocked Read call.
// A zero value for t means Read will not time out.
func (e endlessConn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{ return e.Conn.SetReadDeadline(t) }</span>

// SetWriteDeadline sets the deadline for future Write calls
// and any currently-blocked Write call.
// Even if write times out, it may return n &gt; 0, indicating that
// some of the data was successfully written.
// A zero value for t means Write will not time out.
func (e endlessConn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{ return e.Conn.SetWriteDeadline(t) }</span>

// SyscallConn returns a raw network connection.
// This implements the syscall.Conn interface.
func (e endlessConn) SyscallConn() (syscall.RawConn, error) <span class="cov0" title="0">{
        return e.Conn.(*net.TCPConn).SyscallConn()
}</span>

// ReadFrom implements the io.ReaderFrom ReadFrom method.
func (e endlessConn) ReadFrom(r io.Reader) (int64, error) <span class="cov0" title="0">{
        return e.Conn.(*net.TCPConn).ReadFrom(r)
}</span>

// SetLinger sets the behavior of Close on a connection which still
// has data waiting to be sent or to be acknowledged.
//
// If sec &lt; 0 (the default), the operating system finishes sending the
// data in the background.
//
// If sec == 0, the operating system discards any unsent or
// unacknowledged data.
//
// If sec &gt; 0, the data is sent in the background as with sec &lt; 0. On
// some operating systems after sec seconds have elapsed any remaining
// unsent data may be discarded.
func (e endlessConn) SetLinger(sec int) error <span class="cov0" title="0">{
        return e.Conn.(*net.TCPConn).SetLinger(sec)
}</span>

// SetKeepAlive sets whether the operating system should send
// keep-alive messages on the connection.
func (e endlessConn) SetKeepAlive(keepalive bool) error <span class="cov0" title="0">{
        return e.Conn.(*net.TCPConn).SetKeepAlive(keepalive)
}</span>

// SetKeepAlivePeriod sets period between keep-alives.
func (e endlessConn) SetKeepAlivePeriod(d time.Duration) error <span class="cov0" title="0">{
        return e.Conn.(*net.TCPConn).SetKeepAlivePeriod(d)
}</span>

// SetNoDelay controls whether the operating system should delay
// packet transmission in hopes of sending fewer packets (Nagle's
// algorithm).  The default is true (no delay), meaning that data is
// sent as soon as possible after a Write.
func (e endlessConn) SetNoDelay(noDelay bool) error <span class="cov0" title="0">{
        return e.Conn.(*net.TCPConn).SetNoDelay(noDelay)
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package gracefully

import (
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"
)

var (
        hookableSignals []os.Signal
)

func init() <span class="cov10" title="14">{
        hookableSignals = []os.Signal{
                syscall.SIGHUP,
                syscall.SIGUSR1,
                syscall.SIGUSR2,
                syscall.SIGINT,
                syscall.SIGQUIT,
                syscall.SIGTERM,
                syscall.SIGTSTP,
        }
}</span>

func newSignalHookFunc() map[int]map[os.Signal][]func() <span class="cov0" title="0">{
        return map[int]map[os.Signal][]func(){
                PreSignal: {
                        syscall.SIGHUP:  []func(){},
                        syscall.SIGUSR1: []func(){},
                        syscall.SIGUSR2: []func(){},
                        syscall.SIGINT:  []func(){},
                        syscall.SIGQUIT: []func(){},
                        syscall.SIGTERM: []func(){},
                        syscall.SIGTSTP: []func(){},
                },
                PostSignal: {
                        syscall.SIGHUP:  []func(){},
                        syscall.SIGUSR1: []func(){},
                        syscall.SIGUSR2: []func(){},
                        syscall.SIGINT:  []func(){},
                        syscall.SIGQUIT: []func(){},
                        syscall.SIGTERM: []func(){},
                        syscall.SIGTSTP: []func(){},
                },
        }
}</span>

// handleSignals listens for os Signals and calls any hooked in function that the
// user had registered with the signal.
func (e *endlessServer) handleSignals() <span class="cov0" title="0">{
        var sig os.Signal

        signal.Notify(
                e.sigChan,
                hookableSignals...,
        )

        pid := syscall.Getpid()
        for </span><span class="cov0" title="0">{
                sig = &lt;-e.sigChan
                e.signalHooks(PreSignal, sig)
                switch sig </span>{
                case syscall.SIGHUP:<span class="cov0" title="0">
                        signal.Stop(e.sigChan)
                        close(e.sigChan)
                        log.Println(pid, "[Common] endless received SIGHUP. forking...")
                        if err := e.fork(); err != nil </span><span class="cov0" title="0">{
                                log.Println("[Common] endless fork err:", err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                case syscall.SIGUSR1:<span class="cov0" title="0">
                        log.Println(pid, "[Common] endless received SIGUSR1.")</span>
                case syscall.SIGUSR2:<span class="cov0" title="0">
                        signal.Stop(e.sigChan)
                        close(e.sigChan)
                        log.Println(pid, "[Common] endless received SIGUSR2.")
                        e.hammerTime(0 * time.Second)
                        return</span>
                case syscall.SIGINT:<span class="cov0" title="0">
                        signal.Stop(e.sigChan)
                        close(e.sigChan)
                        log.Println(pid, "[Common] endless received SIGINT.")
                        e.Shutdown()
                        return</span>
                case syscall.SIGQUIT:<span class="cov0" title="0">
                        signal.Stop(e.sigChan)
                        close(e.sigChan)
                        log.Println(pid, "[Common] endless received SIGQUIT.")
                        e.Shutdown()
                        return</span>
                case syscall.SIGTERM:<span class="cov0" title="0">
                        signal.Stop(e.sigChan)
                        close(e.sigChan)
                        log.Println(pid, "[Common] endless received SIGTERM.")
                        e.Shutdown()
                        return</span>
                case syscall.SIGTSTP:<span class="cov0" title="0">
                        log.Println(pid, "[Common] endless received SIGTSTP.")</span>
                default:<span class="cov0" title="0">
                        log.Printf("[Common] endless received %v: nothing we care about...\n", sig)</span>
                }
                <span class="cov0" title="0">e.signalHooks(PostSignal, sig)</span>
        }
}

func (e *endlessListener) Close() error <span class="cov0" title="0">{
        if e.stopped </span><span class="cov0" title="0">{
                return syscall.EINVAL
        }</span>

        <span class="cov0" title="0">e.stopped = true
        return e.Listener.Close()</span>
}

func syscallKill(ppid int) error <span class="cov0" title="0">{
        return syscall.Kill(ppid, syscall.SIGTERM)
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package http

import (
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/i18n"
)

var (
        I18n  i18n.Localizable[Errcode]
        i18ns map[string]i18n.Localizable[Errcode]
)

func Localizable(opts ...utils.OptionExtender) i18n.Localizable[Errcode] <span class="cov0" title="0">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        i, ok := i18ns[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("http i18n not founc: %s", opt.appName))</span>
        }
        <span class="cov0" title="0">return i</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package http

import (
        "context"
        "net/http"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/metrics"
)

var (
        metricsCodeCounterKey = []string{"http", "code", "counter"}
)

func metricsCode(ctx context.Context, appName, path, method string, code, status, rspSize int, reqSize int64) <span class="cov10" title="33">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov10" title="33"></span>

        }

        // skip health check logging
        <span class="cov10" title="33">if path == "/health" &amp;&amp; method == http.MethodGet </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="33">app := config.Use(appName).AppName()
        labels := []metrics.Label{
                {Key: "path", Value: path},
                {Key: "method", Value: method},
                {Key: "code", Value: cast.ToString(code)},
                {Key: "status", Value: cast.ToString(status)},
                {Key: "req_size", Value: cast.ToString(reqSize)},
                {Key: "rsp_size", Value: cast.ToString(rspSize)},
        }
        counterKey := append([]string{app}, metricsCodeCounterKey...)
        for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov9" title="32">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov9" title="32">
                        if m.IsEnableServiceLabel() </span><span class="cov9" title="32">{
                                m.IncrCounter(ctx, counterKey, 1, metrics.Labels(labels))
                        }</span> else<span class="cov0" title="0"> {
                                m.IncrCounter(ctx, metricsCodeCounterKey, 1, metrics.Labels(labels))
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

func Cors() gin.HandlerFunc <span class="cov10" title="34">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                origin := c.Request.Header.Get("Origin")
                var headerKeys []string
                for k := range c.Request.Header </span><span class="cov1" title="1">{
                        headerKeys = append(headerKeys, k)
                }</span>
                <span class="cov1" title="1">corsHeader := c.GetHeader("Access-Control-Request-Headers")
                headerKeys = append(headerKeys, strings.Split(corsHeader, ",")...)

                headerStr := strings.Join(headerKeys, ", ")
                if headerStr != "" </span><span class="cov1" title="1">{
                        headerStr = fmt.Sprintf("access-control-allow-origin, access-control-allow-headers, %s", headerStr)
                }</span> else<span class="cov0" title="0"> {
                        headerStr = "access-control-allow-origin, access-control-allow-headers"
                }</span>
                <span class="cov1" title="1">if origin != "" </span><span class="cov0" title="0">{
                        c.Writer.Header().Set("Access-Control-Allow-Origin", origin)
                        c.Writer.Header().Set("Access-Control-Allow-Headers", headerStr)
                        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")
                        c.Writer.Header().Set("Access-Control-Expose-Headers",
                                "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type")
                        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                }</span>

                <span class="cov1" title="1">if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusNoContent, "no content")
                }</span>
                <span class="cov1" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"

        "github.com/wfusion/gofusion/http/consts"
)

func Gateway(c *gin.Context) <span class="cov8" title="1">{
        consts.SetReqStartTime(c)
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/spf13/cast"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/metrics"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
        "github.com/wfusion/gofusion/http/consts"
        "github.com/wfusion/gofusion/log"

        fmkCtx "github.com/wfusion/gofusion/context"
)

var (
        metricsLatencyKey     = []string{"http", "latency"}
        metricsCounterKey     = []string{"http", "request", "counter"}
        metricsLatencyBuckets = []float64{
                10, 15, 20, 30, 40, 50, 60, 70, 80, 90, 99, 99.9,
                100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 990, 999,
                1000, 1500, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 9900, 9990,
                10000, 15000, 20000, 30000, 40000, 50000, 60000,
        }
)

func logging(c *gin.Context, logger log.Logable, rawURL *url.URL, appName string) <span class="cov1" title="1">{
        ctx := fmkCtx.New(fmkCtx.Gin(c))
        cost := float64(consts.GetReqCost(c)) / float64(time.Millisecond)
        status := c.Writer.Status()
        fields := log.Fields{
                "path":        rawURL.Path,
                "method":      c.Request.Method,
                "status":      status,
                "referer":     c.Request.Referer(),
                "req_size":    c.Request.ContentLength,
                "rsp_size":    c.Writer.Size(),
                "cost":        cost,
                "user_agent":  c.Request.UserAgent(),
                "client_addr": c.ClientIP(),
        }

        // skip health check logging
        if rawURL.Path == "/health" &amp;&amp; c.Request.Method == http.MethodGet </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">msg := fmt.Sprintf(
                "%s -&gt; %s %s %d %d %d (%.2fms)",
                c.ClientIP(), utils.LocalIP.String(),
                strconv.Quote(fmt.Sprintf("%s %s", c.Request.Method, rawURL)),
                c.Request.ContentLength, c.Writer.Size(), status, cost,
        )

        switch </span>{
        case status &lt; http.StatusBadRequest:<span class="cov1" title="1">
                logger.Info(ctx, msg, fields)</span>
        case status &gt;= http.StatusBadRequest &amp;&amp; status &lt; http.StatusInternalServerError:<span class="cov0" title="0">
                logger.Warn(ctx, msg, fields)</span>
        default:<span class="cov0" title="0">
                logger.Error(ctx, msg, fields)</span>
        }

        <span class="cov1" title="1">go metricsLogging(ctx, appName, rawURL.Path, c.Request.Method, status,
                c.Writer.Size(), c.Request.ContentLength, cost)</span>
}

func metricsLogging(ctx context.Context, appName, path, method string,
        status, rspSize int, reqSize int64, cost float64) <span class="cov1" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov1" title="1"></span>

        }

        <span class="cov1" title="1">labels := []metrics.Label{
                {Key: "path", Value: path},
                {Key: "method", Value: method},
                {Key: "status", Value: cast.ToString(status)},
                {Key: "req_size", Value: cast.ToString(reqSize)},
                {Key: "rsp_size", Value: cast.ToString(rspSize)},
        }
        app := config.Use(appName).AppName()
        latencyKey := append([]string{app}, metricsLatencyKey...)
        counterKey := append([]string{app}, metricsCounterKey...)
        for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov1" title="1">
                        if m.IsEnableServiceLabel() </span><span class="cov1" title="1">{
                                m.IncrCounter(ctx, counterKey, 1, metrics.Labels(labels))
                                m.AddSample(ctx, latencyKey, cost, metrics.Labels(labels),
                                        metrics.PrometheusBuckets(metricsLatencyBuckets))
                        }</span> else<span class="cov0" title="0"> {
                                m.IncrCounter(ctx, metricsCounterKey, 1, metrics.Labels(labels))
                                m.AddSample(ctx, metricsLatencyKey, cost, metrics.Labels(labels),
                                        metrics.PrometheusBuckets(metricsLatencyBuckets))
                        }</span>
                }
        }
}

func Logging(appName, logInstance string) gin.HandlerFunc <span class="cov10" title="34">{
        logger := log.Use(logInstance, log.AppName(appName))
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                reqURL := clone.Clone(c.Request.URL)
                defer logging(c, logger, reqURL, appName)

                c.Next()
        }</span>

}
</pre>
		
		<pre class="file" id="file126" style="display: none">package middleware

import (
        "fmt"
        "net"
        "net/http"
        "os"
        "runtime/debug"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "golang.org/x/text/language"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/i18n"
        "github.com/wfusion/gofusion/log"

        fmkCtx "github.com/wfusion/gofusion/context"
)

func Recover(appName, logInstance string) gin.HandlerFunc <span class="cov10" title="34">{
        logger := log.Use(logInstance, log.AppName(appName))
        tag := i18n.DefaultLang(i18n.AppName(appName))
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                defer func() </span><span class="cov1" title="1">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                // Check for a broken connection, as it is not really a
                                // condition that warrants a panic stack trace.
                                var brokenPipe bool
                                if ne, ok := err.(*net.OpError); ok </span><span class="cov0" title="0">{
                                        if se, ok := ne.Err.(*os.SyscallError); ok </span><span class="cov0" title="0">{
                                                if strings.Contains(strings.ToLower(se.Error()), "broken pipe") ||
                                                        strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") </span><span class="cov0" title="0">{
                                                        brokenPipe = true
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if brokenPipe </span><span class="cov0" title="0">{
                                        c.Abort()
                                        return
                                }</span>
                                <span class="cov0" title="0">debugStack := ""
                                for _, v := range strings.Split(string(debug.Stack()), "\n") </span><span class="cov0" title="0">{
                                        debugStack += "&gt; " + v + "\n"
                                }</span>
                                <span class="cov0" title="0">hostname, hostnameErr := os.Hostname()
                                if hostnameErr != nil </span><span class="cov0" title="0">{
                                        hostname = "unknown"
                                }</span>
                                <span class="cov0" title="0">buffer, cb := utils.BytesBufferPool.Get(nil)
                                defer cb()

                                if tag == language.Chinese </span><span class="cov0" title="0">{
                                        buffer.WriteString(fmt.Sprintf("%v \n", err))
                                        buffer.WriteString(fmt.Sprintf("%v \n", time.Now().Format(constant.StdTimeLayout)))
                                        buffer.WriteString(fmt.Sprintf("%v \n", hostname))
                                        buffer.WriteString(fmt.Sprintf("%v \n", c.GetString(fmkCtx.KeyTraceID)))
                                        buffer.WriteString(fmt.Sprintf("%v \n",
                                                c.Request.Method+"  "+c.Request.Host+c.Request.RequestURI))
                                        buffer.WriteString(fmt.Sprintf("UA%v \n", c.Request.UserAgent()))
                                        buffer.WriteString(fmt.Sprintf("IP%v \n", c.ClientIP()))
                                        buffer.WriteString(fmt.Sprintf("\n%v", debugStack))
                                }</span> else<span class="cov0" title="0"> {
                                        buffer.WriteString(fmt.Sprintf("%v \n", err))
                                        buffer.WriteString(fmt.Sprintf("RequstTime%v \n", time.Now().Format(constant.StdTimeLayout)))
                                        buffer.WriteString(fmt.Sprintf("Hostname%v \n", hostname))
                                        buffer.WriteString(fmt.Sprintf("TraceID%v \n", c.GetString(fmkCtx.KeyTraceID)))
                                        buffer.WriteString(fmt.Sprintf("RequestURI%v \n",
                                                c.Request.Method+"  "+c.Request.Host+c.Request.RequestURI))
                                        buffer.WriteString(fmt.Sprintf("UA%v \n", c.Request.UserAgent()))
                                        buffer.WriteString(fmt.Sprintf("IP%v \n", c.ClientIP()))
                                        buffer.WriteString(fmt.Sprintf("ErrorStack\n%v", debugStack))
                                }</span>

                                <span class="cov0" title="0">ctx := fmkCtx.New(fmkCtx.Gin(c))
                                logger.Error(ctx, buffer.String())

                                c.AbortWithStatusJSON(http.StatusInternalServerError, map[string]any{
                                        "code":    http.StatusInternalServerError,
                                        "message": "service internal error",
                                })</span>
                        }
                }()
                <span class="cov1" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"

        "github.com/wfusion/gofusion/common/utils"

        fmkCtx "github.com/wfusion/gofusion/context"
)

func Trace() gin.HandlerFunc <span class="cov10" title="34">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                var (
                        userID, traceID string
                )
                utils.IfAny(
                        func() bool </span><span class="cov1" title="1">{ traceID = c.GetHeader(fmkCtx.KeyTraceID); return traceID != "" }</span>,
                        func() bool <span class="cov1" title="1">{ traceID = c.GetHeader("HTTP_TRACE_ID"); return traceID != "" }</span>,
                        func() bool <span class="cov1" title="1">{
                                traceID = utils.LookupByFuzzyKeyword[string](c.GetHeader, "trace_id")
                                return traceID != ""
                        }</span>,
                        func() bool <span class="cov1" title="1">{ traceID = utils.NginxID(); return traceID != "" }</span>,
                )
                <span class="cov1" title="1">c.Header("Trace-Id", traceID)
                c.Set(fmkCtx.KeyTraceID, traceID)

                utils.IfAny(
                        func() bool </span><span class="cov1" title="1">{ userID = c.GetHeader(fmkCtx.KeyUserID); return userID != "" }</span>,
                        func() bool <span class="cov1" title="1">{
                                userID = utils.LookupByFuzzyKeyword[string](c.GetHeader, "user_id")
                                return userID != ""
                        }</span>,
                        func() bool <span class="cov1" title="1">{
                                userID = utils.LookupByFuzzyKeyword[string](c.GetQuery, "user_id")
                                return userID != ""
                        }</span>,
                        func() bool <span class="cov1" title="1">{
                                userID = utils.LookupByFuzzyKeyword[string](c.GetPostForm, "user_id")
                                return userID != ""
                        }</span>,
                )
                <span class="cov1" title="1">c.Set(fmkCtx.KeyUserID, userID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package middleware

import (
        "html"
        "io/ioutil"
        "net/url"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/gin-gonic/gin/binding"
        "github.com/microcosm-cc/bluemonday"
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

func XSS(whitelistURLs []string) gin.HandlerFunc <span class="cov10" title="34">{
        // Do this once for each unique policy, and use the policy for the life of the
        // program Policy creation/editing is not safe to use in multiple goroutines.
        p := bluemonday.UGCPolicy()

        return func(c *gin.Context) </span><span class="cov1" title="1">{
                for _, u := range whitelistURLs </span><span class="cov1" title="1">{
                        if strings.HasPrefix(c.Request.URL.String(), u) </span><span class="cov1" title="1">{
                                c.Next()
                                return
                        }</span>
                }

                <span class="cov0" title="0">sanitizedQuery, err := xssFilterQuery(p, c.Request.URL.RawQuery)
                if err != nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(err, "filter query")
                        _ = c.Error(err)
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">c.Request.URL.RawQuery = sanitizedQuery

                var sanitizedBody string
                body, err := c.GetRawData()
                if err != nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(err, "read body")
                        _ = c.Error(err)
                        c.Abort()
                        return
                }</span>

                // xssFilterJSON() will return error when body is empty.
                <span class="cov0" title="0">if len(body) == 0 </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">switch binding.Default(c.Request.Method, c.ContentType()) </span>{
                case binding.JSON:<span class="cov0" title="0">
                        if sanitizedBody, err = xssFilterJSON(p, string(body)); err != nil </span><span class="cov0" title="0">{
                                err = errors.Wrap(err, "filter json")
                        }</span>
                case binding.FormMultipart:<span class="cov0" title="0">
                        sanitizedBody = xssFilterPlain(p, string(body))</span>
                case binding.Form:<span class="cov0" title="0">
                        if sanitizedBody, err = xssFilterQuery(p, string(body)); err != nil </span><span class="cov0" title="0">{
                                err = errors.Wrap(err, "filter form")
                        }</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        _ = c.Error(err)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Request.Body = ioutil.NopCloser(strings.NewReader(sanitizedBody))
                c.Next()</span>
        }
}

func xssFilterQuery(p *bluemonday.Policy, s string) (string, error) <span class="cov0" title="0">{
        values, err := url.ParseQuery(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for k, v := range values </span><span class="cov0" title="0">{
                values.Del(k)
                for _, vv := range v </span><span class="cov0" title="0">{
                        values.Add(k, xssFilterPlain(p, vv))
                }</span>
        }

        <span class="cov0" title="0">return values.Encode(), nil</span>
}

func xssFilterJSON(p *bluemonday.Policy, s string) (string, error) <span class="cov0" title="0">{
        var data any
        if err := json.Unmarshal([]byte(s), &amp;data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">b := strings.Builder{}
        e := json.NewEncoder(&amp;b)
        e.SetEscapeHTML(false)
        if err := e.Encode(xssFilterJSONData(p, data)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // use `TrimSpace` to trim newline char add by `Encode`.
        <span class="cov0" title="0">return strings.TrimSpace(b.String()), nil</span>
}

func xssFilterJSONData(p *bluemonday.Policy, d any) any <span class="cov0" title="0">{
        switch data := d.(type) </span>{
        case []any:<span class="cov0" title="0">
                for i, v := range data </span><span class="cov0" title="0">{
                        data[i] = xssFilterJSONData(p, v)
                }</span>
                <span class="cov0" title="0">return data</span>
        case map[string]any:<span class="cov0" title="0">
                for k, v := range data </span><span class="cov0" title="0">{
                        data[k] = xssFilterJSONData(p, v)
                }</span>
                <span class="cov0" title="0">return data</span>
        case string:<span class="cov0" title="0">
                return xssFilterPlain(p, data)</span>
        default:<span class="cov0" title="0">
                return data</span>
        }
}

func xssFilterPlain(p *bluemonday.Policy, s string) string <span class="cov0" title="0">{
        sanitized := p.Sanitize(s)
        return html.UnescapeString(sanitized)
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package parser

import (
        "io"
        "reflect"

        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

type ApplicationJsonParser struct{}

func (a *ApplicationJsonParser) PreParse(args map[string]string) error <span class="cov0" title="0">{
        return nil
}</span>

func (a *ApplicationJsonParser) Parse(src io.Reader, dst reflect.Value) (err error) <span class="cov0" title="0">{
        if err = json.NewDecoder(src).Decode(dst.Addr().Interface()); err != nil </span><span class="cov0" title="0">{
                return malformedRequest(err.Error())
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package parser

import (
        "io"
        "net/url"
        "reflect"
)

type ApplicationFormUrlencodedParser struct{}

func (a *ApplicationFormUrlencodedParser) PreParse(args map[string]string) error <span class="cov10" title="4">{
        return nil
}</span>

func (a *ApplicationFormUrlencodedParser) Parse(src io.Reader, dst reflect.Value) (err error) <span class="cov10" title="4">{
        body, err := io.ReadAll(src)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="4">vals, err := url.ParseQuery(string(body))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="4">return MapFormByTag(dst.Addr().Interface(), vals, "json")</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// Fork from github.com/gin-gonic/gin@v1.7.7/binding/form_mapping.go

// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

package parser

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

var errUnknownType = errors.New("unknown type")

var (
        emptyField                  = reflect.StructField{}
        mapStringInterfaceSliceType = reflect.TypeOf(([]map[string]any)(nil))
)

func MapFormByTag(ptr any, form map[string][]string, tag string) error <span class="cov6" title="14">{
        // Check if ptr is a map
        ptrVal := reflect.ValueOf(ptr)
        var pointed any
        if ptrVal.Kind() == reflect.Ptr </span><span class="cov6" title="14">{
                ptrVal = ptrVal.Elem()
                pointed = ptr
        }</span>
        <span class="cov6" title="14">if ptrVal.Type() == mapStringInterfaceSliceType ||
                (ptrVal.Kind() == reflect.Map &amp;&amp; ptrVal.Type().Key().Kind() == reflect.String) </span><span class="cov5" title="6">{
                if pointed != nil </span><span class="cov5" title="6">{
                        ptr = pointed
                }</span>
                <span class="cov5" title="6">return setFormMap(ptr, form)</span>
        }

        <span class="cov5" title="8">return mappingByPtr(ptr, formSource(form), tag)</span>
}

// setter tries to set value on a walking by fields of a struct
type setter interface {
        TrySet(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error)
}

type formSource map[string][]string

var _ setter = formSource(nil)

// TrySet tries to set a value by request's form source (like map[string][]string)
func (form formSource) TrySet(value reflect.Value, field reflect.StructField,
        tagValue string, opt setOptions) (isSetted bool, err error) <span class="cov8" title="24">{
        return setByForm(value, field, form, tagValue, opt)
}</span>

func mappingByPtr(ptr any, setter setter, tag string) error <span class="cov5" title="8">{
        _, err := mapping(reflect.ValueOf(ptr), emptyField, setter, tag)
        return err
}</span>

func mapping(value reflect.Value, field reflect.StructField, setter setter, tag string) (bool, error) <span class="cov10" title="56">{
        if field.Tag.Get(tag) == "-" </span><span class="cov0" title="0">{ // just ignoring this field
                return false, nil
        }</span>

        <span class="cov10" title="56">var vKind = value.Kind()

        if vKind == reflect.Ptr </span><span class="cov8" title="24">{
                var isNew bool
                vPtr := value
                if value.IsNil() </span><span class="cov7" title="15">{
                        isNew = true
                        vPtr = reflect.New(value.Type().Elem())
                }</span>
                <span class="cov8" title="24">isSetted, err := mapping(vPtr.Elem(), field, setter, tag)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="24">if isNew &amp;&amp; isSetted </span><span class="cov6" title="10">{
                        value.Set(vPtr)
                }</span>
                <span class="cov8" title="24">return isSetted, nil</span>
        }

        <span class="cov8" title="32">if vKind != reflect.Struct || !field.Anonymous </span><span class="cov8" title="32">{
                ok, err := tryToSetValue(value, field, setter, tag)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="32">if ok </span><span class="cov7" title="15">{
                        return true, nil
                }</span>
        }

        <span class="cov7" title="17">if vKind == reflect.Struct </span><span class="cov5" title="8">{
                tValue := value.Type()

                var isSetted bool
                for i := 0; i &lt; value.NumField(); i++ </span><span class="cov8" title="24">{
                        sf := tValue.Field(i)
                        if sf.PkgPath != "" &amp;&amp; !sf.Anonymous </span><span class="cov0" title="0">{ // unexported
                                continue</span>
                        }
                        <span class="cov8" title="24">ok, err := mapping(value.Field(i), tValue.Field(i), setter, tag)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="24">isSetted = isSetted || ok</span>
                }
                <span class="cov5" title="8">return isSetted, nil</span>
        }
        <span class="cov5" title="9">return false, nil</span>
}

type setOptions struct {
        isDefaultExists bool
        defaultValue    string
}

func tryToSetValue(value reflect.Value, field reflect.StructField, setter setter, tag string) (bool, error) <span class="cov8" title="32">{
        var tagValue string
        var setOpt setOptions

        tagValue = field.Tag.Get(tag)
        tagValue, opts := head(tagValue, ",")

        if tagValue == "" </span><span class="cov5" title="8">{ // default value is FieldName
                tagValue = field.Name
        }</span>
        <span class="cov8" title="32">if tagValue == "" </span><span class="cov5" title="8">{ // when field is "emptyField" variable
                return false, nil
        }</span>

        <span class="cov8" title="24">var opt string
        for len(opts) &gt; 0 </span><span class="cov0" title="0">{
                opt, opts = head(opts, ",")

                if k, v := head(opt, "="); k == "default" </span><span class="cov0" title="0">{
                        setOpt.isDefaultExists = true
                        setOpt.defaultValue = v
                }</span>
        }

        <span class="cov8" title="24">return setter.TrySet(value, field, tagValue, setOpt)</span>
}

func setByForm(value reflect.Value, field reflect.StructField, form map[string][]string,
        tagValue string, opt setOptions) (isSetted bool, err error) <span class="cov8" title="24">{
        vs, ok := form[tagValue]
        if !ok &amp;&amp; !opt.isDefaultExists </span><span class="cov5" title="9">{
                return false, nil
        }</span>

        <span class="cov7" title="15">switch value.Kind() </span>{
        case reflect.Slice:<span class="cov4" title="5">
                if !ok </span><span class="cov0" title="0">{
                        vs = []string{opt.defaultValue}
                }</span>
                <span class="cov4" title="5">return true, setSlice(vs, value, field)</span>
        case reflect.Array:<span class="cov0" title="0">
                if !ok </span><span class="cov0" title="0">{
                        vs = []string{opt.defaultValue}
                }</span>
                <span class="cov0" title="0">if len(vs) != value.Len() </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("%q is not valid value for %s", vs, value.Type().String())
                }</span>
                <span class="cov0" title="0">return true, setArray(vs, value, field)</span>
        default:<span class="cov6" title="10">
                var val string
                if !ok </span><span class="cov0" title="0">{
                        val = opt.defaultValue
                }</span>

                <span class="cov6" title="10">if len(vs) &gt; 0 </span><span class="cov6" title="10">{
                        val = vs[0]
                }</span>
                <span class="cov6" title="10">return true, setWithProperType(val, value, field)</span>
        }
}

func setWithProperType(val string, value reflect.Value, field reflect.StructField) error <span class="cov9" title="40">{
        switch value.Kind() </span>{
        case reflect.Int:<span class="cov8" title="30">
                return setIntField(val, 0, value)</span>
        case reflect.Int8:<span class="cov0" title="0">
                return setIntField(val, 8, value)</span>
        case reflect.Int16:<span class="cov0" title="0">
                return setIntField(val, 16, value)</span>
        case reflect.Int32:<span class="cov0" title="0">
                return setIntField(val, 32, value)</span>
        case reflect.Int64:<span class="cov0" title="0">
                switch value.Interface().(type) </span>{
                case time.Duration:<span class="cov0" title="0">
                        return setTimeDuration(val, value, field)</span>
                }
                <span class="cov0" title="0">return setIntField(val, 64, value)</span>
        case reflect.Uint:<span class="cov0" title="0">
                return setUintField(val, 0, value)</span>
        case reflect.Uint8:<span class="cov0" title="0">
                return setUintField(val, 8, value)</span>
        case reflect.Uint16:<span class="cov0" title="0">
                return setUintField(val, 16, value)</span>
        case reflect.Uint32:<span class="cov0" title="0">
                return setUintField(val, 32, value)</span>
        case reflect.Uint64:<span class="cov0" title="0">
                return setUintField(val, 64, value)</span>
        case reflect.Bool:<span class="cov0" title="0">
                return setBoolField(val, value)</span>
        case reflect.Float32:<span class="cov0" title="0">
                return setFloatField(val, 32, value)</span>
        case reflect.Float64:<span class="cov0" title="0">
                return setFloatField(val, 64, value)</span>
        case reflect.String:<span class="cov6" title="10">
                value.SetString(val)</span>
        case reflect.Struct:<span class="cov0" title="0">
                switch value.Interface().(type) </span>{
                case time.Time:<span class="cov0" title="0">
                        return setTimeField(val, field, value)</span>
                }
                <span class="cov0" title="0">return json.Unmarshal(utils.UnsafeStringToBytes(val), value.Addr().Interface())</span>
        case reflect.Map:<span class="cov0" title="0">
                return json.Unmarshal(utils.UnsafeStringToBytes(val), value.Addr().Interface())</span>
        default:<span class="cov0" title="0">
                return errUnknownType</span>
        }
        <span class="cov6" title="10">return nil</span>
}

func setIntField(val string, bitSize int, field reflect.Value) error <span class="cov8" title="30">{
        if val == "" </span><span class="cov0" title="0">{
                val = "0"
        }</span>
        <span class="cov8" title="30">intVal, err := strconv.ParseInt(val, 10, bitSize)
        if err == nil </span><span class="cov8" title="30">{
                field.SetInt(intVal)
        }</span>
        <span class="cov8" title="30">return err</span>
}

func setUintField(val string, bitSize int, field reflect.Value) error <span class="cov0" title="0">{
        if val == "" </span><span class="cov0" title="0">{
                val = "0"
        }</span>
        <span class="cov0" title="0">uintVal, err := strconv.ParseUint(val, 10, bitSize)
        if err == nil </span><span class="cov0" title="0">{
                field.SetUint(uintVal)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func setBoolField(val string, field reflect.Value) error <span class="cov0" title="0">{
        if val == "" </span><span class="cov0" title="0">{
                val = "false"
        }</span>
        <span class="cov0" title="0">boolVal, err := strconv.ParseBool(val)
        if err == nil </span><span class="cov0" title="0">{
                field.SetBool(boolVal)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func setFloatField(val string, bitSize int, field reflect.Value) error <span class="cov0" title="0">{
        if val == "" </span><span class="cov0" title="0">{
                val = "0.0"
        }</span>
        <span class="cov0" title="0">floatVal, err := strconv.ParseFloat(val, bitSize)
        if err == nil </span><span class="cov0" title="0">{
                field.SetFloat(floatVal)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func setTimeField(val string, structField reflect.StructField, value reflect.Value) error <span class="cov0" title="0">{
        timeFormat := structField.Tag.Get("time_format")
        if timeFormat == "" </span><span class="cov0" title="0">{
                timeFormat = time.RFC3339
        }</span>

        <span class="cov0" title="0">switch tf := strings.ToLower(timeFormat); tf </span>{
        case "unix", "unixnano":<span class="cov0" title="0">
                tv, err := strconv.ParseInt(val, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">d := time.Duration(1)
                if tf == "unixnano" </span><span class="cov0" title="0">{
                        d = time.Second
                }</span>

                <span class="cov0" title="0">t := time.Unix(tv/int64(d), tv%int64(d))
                value.Set(reflect.ValueOf(t))
                return nil</span>

        }

        <span class="cov0" title="0">if val == "" </span><span class="cov0" title="0">{
                value.Set(reflect.ValueOf(time.Time{}))
                return nil
        }</span>

        <span class="cov0" title="0">l := time.Local
        if isUTC, _ := strconv.ParseBool(structField.Tag.Get("time_utc")); isUTC </span><span class="cov0" title="0">{
                l = time.UTC
        }</span>

        <span class="cov0" title="0">if locTag := structField.Tag.Get("time_location"); locTag != "" </span><span class="cov0" title="0">{
                loc, err := time.LoadLocation(locTag)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">l = loc</span>
        }

        <span class="cov0" title="0">t, err := time.ParseInLocation(timeFormat, val, l)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">value.Set(reflect.ValueOf(t))
        return nil</span>
}

func setArray(vals []string, value reflect.Value, field reflect.StructField) error <span class="cov4" title="5">{
        for i, s := range vals </span><span class="cov8" title="30">{
                err := setWithProperType(s, value.Index(i), field)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="5">return nil</span>
}

func setSlice(vals []string, value reflect.Value, field reflect.StructField) error <span class="cov4" title="5">{
        slice := reflect.MakeSlice(value.Type(), len(vals), len(vals))
        err := setArray(vals, slice, field)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">value.Set(slice)
        return nil</span>
}

func setTimeDuration(val string, value reflect.Value, field reflect.StructField) error <span class="cov0" title="0">{
        d, err := time.ParseDuration(val)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">value.Set(reflect.ValueOf(d))
        return nil</span>
}

func head(str, sep string) (head string, tail string) <span class="cov8" title="32">{
        idx := strings.Index(str, sep)
        if idx &lt; 0 </span><span class="cov8" title="32">{
                return str, ""
        }</span>
        <span class="cov0" title="0">return str[:idx], str[idx+len(sep):]</span>
}

func setFormMap(ptr any, form map[string][]string) error <span class="cov5" title="6">{
        switch ptrMap := ptr.(type) </span>{
        case *map[string]any:<span class="cov3" title="3">
                *ptrMap = make(map[string]any, len(form))
                for k, v := range form </span><span class="cov5" title="6">{
                        (*ptrMap)[k] = v
                }</span>
        case *[]map[string]any:<span class="cov3" title="3">
                *ptrMap = make([]map[string]any, 0, 1)
                tmp := make(map[string]any, len(form))
                for k, v := range form </span><span class="cov5" title="6">{
                        tmp[k] = v
                }</span>
                <span class="cov3" title="3">*ptrMap = append(*ptrMap, tmp)</span>
        case *map[string][]string:<span class="cov0" title="0">
                *ptrMap = make(map[string][]string, len(form))
                for k, v := range form </span><span class="cov0" title="0">{
                        (*ptrMap)[k] = v
                }</span>
        case *map[string]string:<span class="cov0" title="0">
                *ptrMap = make(map[string]string, len(form))
                for k, v := range form </span><span class="cov0" title="0">{
                        (*ptrMap)[k] = v[len(v)-1] // pick last
                }</span>
        default:<span class="cov0" title="0">
                return errors.New("cannot convert to map slices of strings")</span>
        }

        <span class="cov5" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package parser

import (
        "io"
        "io/ioutil"
        "mime/multipart"
        "reflect"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

const (
        keyBoundary = "boundary"
)

var (
        byteSliceType = reflect.TypeOf(([]byte)(nil))
)

type MultipartFormDataParser struct {
        boundary string
}

func (m *MultipartFormDataParser) PreParse(args map[string]string) error <span class="cov3" title="2">{
        boundary, ok := args[keyBoundary]
        if !ok </span><span class="cov0" title="0">{
                return malformedRequest("missing boundary in multipart/form-data")
        }</span>
        <span class="cov3" title="2">m.boundary = boundary
        return nil</span>
}

func (m *MultipartFormDataParser) Parse(src io.Reader, dst reflect.Value) (err error) <span class="cov3" title="2">{
        for dst.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                dst.Set(reflect.New(dst.Type().Elem()))
                dst = dst.Elem()
        }</span>

        <span class="cov3" title="2">var (
                part   *multipart.Part
                body   []byte
                dt     = reflect.TypeOf(dst.Interface())
                reader = multipart.NewReader(src, m.boundary)
        )
        defer func() </span><span class="cov3" title="2">{
                if part != nil </span><span class="cov0" title="0">{
                        utils.CloseAnyway(part)
                }</span>
        }()

        <span class="cov3" title="2">for </span><span class="cov7" title="10">{
                part, err = reader.NextPart()
                if err != nil </span><span class="cov3" title="2">{
                        if err == io.EOF </span><span class="cov3" title="2">{
                                err = nil
                        }</span>
                        <span class="cov3" title="2">break</span>
                }

                <span class="cov7" title="8">k := part.FormName()
                fNum := m.lookupFieldByTag(dt, k, "json")
                if fNum == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="8">fv := dst.Field(fNum)
                if !fv.IsValid() || !fv.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // transform
                <span class="cov7" title="8">if body, err = ioutil.ReadAll(part); err != nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov7" title="8"> if err = m.transformField(fv, body); err != nil </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov7" title="8"> if err = part.Close(); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov3" title="2">return</span>
}

func (m *MultipartFormDataParser) lookupFieldByTag(t reflect.Type, key, tag string) (fNum int) <span class="cov7" title="8">{
        n := t.NumField()
        for i := 0; i &lt; n; i++ </span><span class="cov10" title="20">{
                f := t.Field(i)
                if v, ok := f.Tag.Lookup(tag); ok &amp;&amp; v == key </span><span class="cov7" title="8">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

var (
        castReflectTypeMap = map[reflect.Kind]func(reflect.Value, []byte) error{
                reflect.Bool:    func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToBoolE(b); f.SetBool(v); return }</span>,
                reflect.String:  func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToStringE(b); f.SetString(v); return }</span>,
                reflect.Int:     func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToInt64E(b); f.SetInt(v); return }</span>,
                reflect.Int8:    func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToInt64E(b); f.SetInt(v); return }</span>,
                reflect.Int16:   func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToInt64E(b); f.SetInt(v); return }</span>,
                reflect.Int32:   func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToInt64E(b); f.SetInt(v); return }</span>,
                reflect.Int64:   func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToInt64E(b); f.SetInt(v); return }</span>,
                reflect.Uint:    func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToUint64E(b); f.SetUint(v); return }</span>,
                reflect.Uint8:   func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToUint64E(b); f.SetUint(v); return }</span>,
                reflect.Uint16:  func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToUint64E(b); f.SetUint(v); return }</span>,
                reflect.Uint32:  func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToUint64E(b); f.SetUint(v); return }</span>,
                reflect.Uint64:  func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToUint64E(b); f.SetUint(v); return }</span>,
                reflect.Float32: func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToFloat64E(b); f.SetFloat(v); return }</span>,
                reflect.Float64: func(f reflect.Value, b []byte) (e error) <span class="cov0" title="0">{ v, e := cast.ToFloat64E(b); f.SetFloat(v); return }</span>,
        }
)

func (m *MultipartFormDataParser) transformField(f reflect.Value, param []byte) (err error) <span class="cov7" title="8">{
        ft := f.Type()
        if ft.Kind() == reflect.Ptr </span><span class="cov5" title="4">{
                ft = ft.Elem()
                if f.IsNil() </span><span class="cov5" title="4">{
                        f.Set(reflect.New(ft))
                }</span>
                <span class="cov5" title="4">f = f.Elem()</span>
        }

        <span class="cov7" title="8">if byteSliceType.ConvertibleTo(ft) </span><span class="cov6" title="6">{
                f.Set(reflect.ValueOf(param).Convert(ft))
                return
        }</span>

        <span class="cov3" title="2">caster, ok := castReflectTypeMap[ft.Kind()]
        if !ok </span><span class="cov3" title="2">{
                return json.Unmarshal(param, f.Addr().Interface())
        }</span>

        <span class="cov0" title="0">return caster(f, param)</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package parser

import (
        "fmt"
        "io"
        "reflect"

        "github.com/gin-gonic/gin"
)

type Parser interface {
        PreParse(args map[string]string) error
        Parse(src io.Reader, dst reflect.Value) error
}

func malformedRequest(msg string) error <span class="cov0" title="0">{
        return fmt.Errorf("malformed request %s", msg)
}</span>

func unsupportedContentType(typ string) error <span class="cov0" title="0">{
        return fmt.Errorf("unsupported content-type %s", typ)
}</span>

var (
        parserMap = map[string]reflect.Type{
                gin.MIMEJSON:              reflect.TypeOf((*ApplicationJsonParser)(nil)),
                gin.MIMEPOSTForm:          reflect.TypeOf((*ApplicationFormUrlencodedParser)(nil)),
                gin.MIMEMultipartPOSTForm: reflect.TypeOf((*MultipartFormDataParser)(nil)),
        }
)

func GetByContentType(typ string) (parser Parser, err error) <span class="cov10" title="6">{
        parserType, ok := parserMap[typ]
        if !ok </span><span class="cov0" title="0">{
                return nil, unsupportedContentType(typ)
        }</span>

        <span class="cov10" title="6">return reflect.New(parserType.Elem()).Interface().(Parser), nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package http

import (
        "net/http"
        "reflect"

        "github.com/gin-gonic/gin"
        "github.com/mitchellh/mapstructure"
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/constraint"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/i18n"

        fmkCtx "github.com/wfusion/gofusion/context"
)

type Response struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Data    any    `json:"data"`

        // pagination
        Page  *int `json:"page,omitempty"`
        Count *int `json:"count,omitempty"`

        // Trace
        TraceID string `json:"traceid"`
}

type Embed struct {
}

var (
        embedType    = reflect.TypeOf(Embed{})
        responseType = reflect.TypeOf(Response{})
)

func Success(c *gin.Context, appName string, data any, page, count int, msg string) <span class="cov7" title="9">{
        status := c.Writer.Status()
        if status &lt;= 0 </span><span class="cov0" title="0">{
                status = http.StatusOK
        }</span>
        <span class="cov7" title="9">if msg == "" </span><span class="cov1" title="1">{
                msg = "ok"
        }</span>
        <span class="cov7" title="9">var (
                pagePtr  *int
                countPtr *int
        )
        if page &gt; 0 </span><span class="cov6" title="8">{
                pagePtr = utils.AnyPtr(page)
        }</span>
        <span class="cov7" title="9">if count &gt;= 0 </span><span class="cov7" title="9">{
                countPtr = utils.AnyPtr(count)
        }</span>

        <span class="cov7" title="9">code := Use(AppName(appName)).Config().SuccessCode
        c.PureJSON(status, &amp;Response{
                Code:    code,
                Message: msg,
                Data:    data,
                Page:    pagePtr,
                Count:   countPtr,
                TraceID: c.GetString(fmkCtx.KeyTraceID),
        })

        go metricsCode(fmkCtx.New(fmkCtx.Gin(c)), appName, c.Request.URL.Path, c.Request.Method, code,
                c.Writer.Status(), c.Writer.Size(), c.Request.ContentLength)</span>
}

func Error[T constraint.Integer](c *gin.Context, appName string, code T, data any, page, count int, msg string) <span class="cov10" title="23">{
        status := c.Writer.Status()
        if status &lt;= 0 </span><span class="cov0" title="0">{
                status = http.StatusBadRequest
        }</span>

        <span class="cov10" title="23">if msg == "" </span><span class="cov0" title="0">{
                msg = Localizable(AppName(appName)).Localize(Errcode(code), i18n.Langs(langs(c)))
        }</span>
        <span class="cov10" title="23">var (
                pagePtr  *int
                countPtr *int
        )
        if page &gt; 0 </span><span class="cov1" title="1">{
                pagePtr = utils.AnyPtr(page)
        }</span>
        <span class="cov10" title="23">if count &gt;= 0 </span><span class="cov10" title="23">{
                countPtr = utils.AnyPtr(count)
        }</span>

        <span class="cov10" title="23">c.PureJSON(status, &amp;Response{
                Code:    cast.ToInt(code),
                Message: msg,
                Data:    data,
                Page:    pagePtr,
                Count:   countPtr,
                TraceID: c.GetString(fmkCtx.KeyTraceID),
        })

        go metricsCode(fmkCtx.New(fmkCtx.Gin(c)), appName, c.Request.URL.Path, c.Request.Method, cast.ToInt(code),
                c.Writer.Status(), c.Writer.Size(), c.Request.ContentLength)</span>
}

func embedResponse(c *gin.Context, appName string, data any, err error) <span class="cov1" title="1">{
        status := c.Writer.Status()
        if status == 0 </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        status = http.StatusOK
                }</span> else<span class="cov0" title="0"> {
                        status = http.StatusBadRequest
                }</span>
        }

        <span class="cov1" title="1">ctx := fmkCtx.New(fmkCtx.Gin(c))
        switch rsp := data.(type) </span>{
        case Response:<span class="cov0" title="0">
                go metricsCode(ctx, appName, c.Request.URL.Path, c.Request.Method, rsp.Code,
                        c.Writer.Status(), c.Writer.Size(), c.Request.ContentLength)</span>
        case *Response:<span class="cov0" title="0">
                go metricsCode(ctx, appName, c.Request.URL.Path, c.Request.Method, rsp.Code,
                        c.Writer.Status(), c.Writer.Size(), c.Request.ContentLength)</span>
        default:<span class="cov1" title="1">
                rspData := make(map[string]any)
                dec, err := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig{
                        Result:  &amp;rspData,
                        TagName: "json",
                })
                if err == nil &amp;&amp; dec != nil </span><span class="cov1" title="1">{
                        _ = dec.Decode(data)
                }</span>
                <span class="cov1" title="1">var code any
                utils.IfAny(
                        func() (ok bool) </span><span class="cov1" title="1">{ code, ok = rspData["code"]; return ok }</span>,
                        func() (ok bool) <span class="cov1" title="1">{ code, ok = rspData["Code"]; return ok }</span>,
                )
                <span class="cov1" title="1">if code == nil </span><span class="cov1" title="1">{
                        code = -2
                }</span>
                <span class="cov1" title="1">go metricsCode(ctx, appName, c.Request.URL.Path, c.Request.Method, cast.ToInt(code),
                        c.Writer.Status(), c.Writer.Size(), c.Request.ContentLength)</span>
        }

        <span class="cov1" title="1">c.PureJSON(status, data)</span>
}

func langs(c *gin.Context) (langs []string) <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">langs = c.Request.Header.Values("Accept-Language")
        if lang := c.GetString("lang"); utils.IsStrNotBlank(lang) </span><span class="cov0" title="0">{
                langs = append(langs, lang)
        }</span>
        <span class="cov0" title="0">if lang := c.GetString(fmkCtx.KeyLangs); utils.IsStrNotBlank(lang) </span><span class="cov0" title="0">{
                langs = append(langs, lang)
        }</span>
        <span class="cov0" title="0">return langs</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package http

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "mime"
        "net/http"
        "reflect"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gin-gonic/gin/binding"
        "github.com/pkg/errors"
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/http/gracefully"
        "github.com/wfusion/gofusion/http/parser"
        "github.com/wfusion/gofusion/routine"
)

type parseFrom int

const (
        parseFromBody parseFrom = 1 + iota
        parseFromQuery
)

type dispatch int

const (
        dispatchIRouter dispatch = iota
        dispatchGroup
        dispatchRoutes
)

type routerHandler any
type routerRequestParser func(*gin.Context, reflect.Type) (reflect.Value, error)

var (
        methodWithBody = map[string]bool{
                http.MethodPut:   true,
                http.MethodPost:  true,
                http.MethodPatch: true,
        }
)

type router struct {
        gin.IRouter

        appName string
        routes  gin.IRoutes      `optional:"true"`
        group   *gin.RouterGroup `optional:"true"`
        ptr     dispatch         `optional:"true"`
}

func newRouter(r gin.IRouter, appName string) IRouter <span class="cov10" title="70">{
        return &amp;router{IRouter: r, appName: appName}
}</span>

func (r *router) Use(middlewares ...gin.HandlerFunc) IRouter <span class="cov0" title="0">{
        return &amp;router{routes: r.use().Use(middlewares...), ptr: dispatchRoutes}
}</span>

func (r *router) Handle(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov0" title="0">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().HEAD(uri, r.convertMulti("Handle", uri, fn, opt)...)
        return r
}</span>
func (r *router) Any(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov5" title="10">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().Any(uri, r.convertMulti("Any", uri, fn, opt)...)
        return r
}</span>
func (r *router) GET(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov5" title="7">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().GET(uri, r.convertMulti(http.MethodGet, uri, fn, opt)...)
        return r
}</span>
func (r *router) POST(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov8" title="29">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().POST(uri, r.convertMulti(http.MethodPost, uri, fn, opt)...)
        return r
}</span>
func (r *router) DELETE(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov0" title="0">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().DELETE(uri, r.convertMulti(http.MethodDelete, uri, fn, opt)...)
        return r
}</span>
func (r *router) PATCH(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov0" title="0">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().PATCH(uri, r.convertMulti(http.MethodPatch, uri, fn, opt)...)
        return r
}</span>
func (r *router) PUT(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov0" title="0">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().PUT(uri, r.convertMulti(http.MethodPut, uri, fn, opt)...)
        return r
}</span>
func (r *router) OPTIONS(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov0" title="0">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().OPTIONS(uri, r.convertMulti(http.MethodOptions, uri, fn, opt)...)
        return r
}</span>
func (r *router) HEAD(uri string, fn routerHandler, opts ...utils.OptionExtender) IRouter <span class="cov0" title="0">{
        opt := utils.ApplyOptions[routerOption](opts...)
        r.use().HEAD(uri, r.convertMulti(http.MethodHead, uri, fn, opt)...)
        return r
}</span>
func (r *router) Group(relativePath string, handlers ...gin.HandlerFunc) IRouter <span class="cov1" title="1">{
        return &amp;router{group: r.useIRouter().Group(relativePath, handlers...), ptr: dispatchGroup}
}</span>

func (r *router) StaticFile(uri, file string) IRouter <span class="cov3" title="3">{ r.use().StaticFile(uri, file); return r }</span>
func (r *router) StaticFileFS(uri, file string, fs http.FileSystem) IRouter <span class="cov0" title="0">{
        r.use().StaticFileFS(uri, file, fs)
        return r
}</span>
func (r *router) Static(uri, file string) IRouter <span class="cov0" title="0">{ r.use().Static(uri, file); return r }</span>
func (r *router) StaticFS(uri string, fs http.FileSystem) IRouter <span class="cov0" title="0">{
        r.use().StaticFS(uri, fs)
        return r
}</span>

func (r *router) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="37">{
        r.IRouter.(*gin.Engine).ServeHTTP(w, req)
}</span>
func (r *router) ListenAndServe() error <span class="cov0" title="0">{
        conf := r.Config()
        gracefully.DefaultReadTimeOut = conf.ReadTimeout
        gracefully.DefaultWriteTimeOut = conf.WriteTimeout
        gracefully.DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // use http.DefaultMaxHeaderBytes - which currently is 1 &lt;&lt; 20 (1MB)

        port := fmt.Sprintf(":%v", conf.Port)
        srv := gracefully.NewServer(r.appName, r.IRouter.(*gin.Engine), port, conf.NextProtos)
        if conf.TLS </span><span class="cov0" title="0">{
                return srv.ListenAndServeTLS(conf.Cert, conf.Key)
        }</span> else<span class="cov0" title="0"> {
                return srv.ListenAndServe()
        }</span>
}
func (r *router) Start() <span class="cov0" title="0">{
        conf := r.Config()
        gracefully.DefaultReadTimeOut = conf.ReadTimeout
        gracefully.DefaultWriteTimeOut = conf.WriteTimeout
        gracefully.DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // use http.DefaultMaxHeaderBytes - which currently is 1 &lt;&lt; 20 (1MB)

        port := fmt.Sprintf(":%v", conf.Port)
        srv := gracefully.NewServer(r.appName, r.IRouter.(*gin.Engine), port, conf.NextProtos)
        if conf.TLS </span><span class="cov0" title="0">{
                routine.Go(srv.ListenAndServeTLS, routine.Args(conf.Cert, conf.Key), routine.AppName(r.appName))
        }</span> else<span class="cov0" title="0"> {
                routine.Go(srv.ListenAndServe, routine.AppName(r.appName))
        }</span>
}
func (r *router) Config() OutputConf <span class="cov5" title="9">{
        cfg := new(Conf)
        _ = config.Use(r.appName).LoadComponentConfig(config.ComponentHttp, cfg)

        return OutputConf{
                Port:         cfg.Port,
                TLS:          cfg.TLS,
                Cert:         cfg.Cert,
                Key:          cfg.Key,
                NextProtos:   cfg.NextProtos,
                SuccessCode:  cfg.SuccessCode,
                ReadTimeout:  utils.Must(time.ParseDuration(cfg.ReadTimeout)),
                WriteTimeout: utils.Must(time.ParseDuration(cfg.WriteTimeout)),
                AsynqConf:    clone.Slowly(cfg.Asynq),
        }
}</span>

func (r *router) use() gin.IRoutes <span class="cov9" title="49">{
        switch r.ptr </span>{
        case dispatchIRouter:<span class="cov9" title="48">
                return r.IRouter</span>
        case dispatchGroup:<span class="cov1" title="1">
                return r.group</span>
        case dispatchRoutes:<span class="cov0" title="0">
                return r.routes</span>
        default:<span class="cov0" title="0">
                return r.IRouter</span>
        }
}

func (r *router) useIRouter() gin.IRouter <span class="cov1" title="1">{
        switch r.ptr </span>{
        case dispatchIRouter:<span class="cov1" title="1">
                return r.IRouter</span>
        case dispatchGroup:<span class="cov0" title="0">
                return r.group</span>
        case dispatchRoutes:<span class="cov0" title="0">
                panic(errors.New("group method unsupported for gin.Routes interface"))</span>
        default:<span class="cov0" title="0">
                return r.IRouter</span>
        }
}

// convert
// Warning: MultipartFormDataBody only support Struct or *Struct
// support router handler signature as follows:
// - be compatible with native func(c *gin.Context) without any in&amp;out parameters parsed
// - func(c *gin.Context, req Struct FromQuery) error
// - func(c *gin.Context, req Struct FromJsonBody) error
// - func(c *gin.Context, req Struct FromFormUrlDecodedBody) error
// - func(c *gin.Context, req Struct FromMultipartFormDataBody) error
// - func(c *gin.Context, req *Struct FromQuery) error
// - func(c *gin.Context, req *Struct FromParam) error
// - func(c *gin.Context, req *Struct FromJsonBody) error
// - func(c *gin.Context, req *Struct FromFormUrlDecodedBody) error
// - func(c *gin.Context, req *Struct FromMultipartFormDataBody) error
// - func(c *gin.Context, req map[string]any FromQuery) error
// - func(c *gin.Context, req map[string]any FromJsonBody) error
// - func(c *gin.Context, req map[string]any FromFormUrlDecodedBody) error
// - func(c *gin.Context, req []map[string]any FromQuery) error
// - func(c *gin.Context, req []map[string]any FromJsonBody) error
// - func(c *gin.Context, req []map[string]any FromFormUrlDecodedBody) error
// - func(c *gin.Context, req *FromQuery) (rsp *Struct{Data any; Page, Count int; Msg string}, err error)
// - func(c *gin.Context, req *FromQuery) (rsp *Struct{Embed}, err error)
// - func(c *gin.Context, req *FromQuery) (data any, page, count int, msg string, err error)
// - class.public.func(c *gin.Context, req Struct FromQuery) error
// - class.private.func(c *gin.Context, req Struct FromQuery) error
func (r *router) convert(method, uri string, handler routerHandler, opt *routerOption) gin.HandlerFunc <span class="cov9" title="46">{
        // check IRouter handler type
        typ := reflect.TypeOf(handler)
        if err := r.checkHandlerType(method, uri, typ); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // return raw gin handler
        <span class="cov9" title="46">if typ.NumIn() == 1 &amp;&amp; typ.NumOut() == 0 </span><span class="cov6" title="13">{
                return func(c *gin.Context) </span><span class="cov3" title="3">{
                        reflect.ValueOf(handler).Call([]reflect.Value{reflect.ValueOf(c)})
                        c.Next()
                }</span>
        }

        // parse request&amp;response
        <span class="cov8" title="33">if typ.NumIn() == 1 </span><span class="cov0" title="0">{
                return r.wrapHandlerFunc(handler, nil)
        }</span>

        <span class="cov8" title="33">parseMap := map[parseFrom]routerRequestParser{
                parseFromBody:  r.parseReqFromBody,
                parseFromQuery: r.parseReqFromQuery,
        }

        var reqParse routerRequestParser
        if p, ok := parseMap[opt.parseFrom]; ok </span><span class="cov0" title="0">{
                reqParse = p
        }</span> else<span class="cov8" title="33"> if methodWithBody[method] </span><span class="cov8" title="28">{
                reqParse = r.parseReqFromBody
        }</span> else<span class="cov4" title="5"> {
                reqParse = r.parseReqFromQuery
        }</span>

        <span class="cov8" title="33">return r.wrapHandlerFunc(handler, reqParse)</span>
}

func (r *router) convertMulti(method, uri string, hdr routerHandler, opt *routerOption) (result gin.HandlersChain) <span class="cov9" title="46">{
        result = make(gin.HandlersChain, 0, len(opt.beforeHandlers)+len(opt.aftersHandlers)+1)
        for _, hdr := range opt.beforeHandlers </span><span class="cov0" title="0">{
                result = append(result, r.convert(method, uri, hdr, opt))
        }</span>
        <span class="cov9" title="46">result = append(result, r.convert(method, uri, hdr, opt))
        for _, hdr := range opt.aftersHandlers </span><span class="cov0" title="0">{
                result = append(result, r.convert(method, uri, hdr, opt))
        }</span>
        <span class="cov9" title="46">return</span>
}

func (r *router) checkHandlerType(method, uri string, typ reflect.Type) (err error) <span class="cov9" title="46">{
        if typ.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return errors.Errorf("router handler should be a function [method[%s] uri[%s]]", method, uri)
        }</span>

        // check in
        <span class="cov9" title="46">if typ.NumIn() &lt; 1 </span><span class="cov0" title="0">{
                return errors.Errorf("router handler should have at least 1 parameter in "+
                        "[method[%s] uri[%s]]", method, uri)
        }</span>
        <span class="cov9" title="46">if typ.NumIn() &gt; 2 </span><span class="cov0" title="0">{
                return errors.Errorf("router handler should not have more than 2 parameters in "+
                        "[method[%s] uri[%s]]", method, uri)
        }</span>
        <span class="cov9" title="46">if typ.In(0) != constant.GinContextType </span><span class="cov0" title="0">{
                return errors.Errorf("router handler first parameter in should be *gin.Context "+
                        "[method[%s] uri[%s]]", method, uri)
        }</span>
        <span class="cov9" title="46">if typ.NumIn() == 2 </span><span class="cov8" title="33">{
                if !r.checkParamType(typ.In(1), supportParamType) </span><span class="cov0" title="0">{
                        return errors.Errorf("router handler second parameter in type not supportted "+
                                "[method[%s] uri[%s]]", method, uri)
                }</span>
        }

        // check out

        // check error
        <span class="cov9" title="46">if typ.NumOut() &gt; 0 &amp;&amp; !typ.Out(typ.NumOut()-1).AssignableTo(constant.ErrorType) </span><span class="cov0" title="0">{
                return errors.Errorf("router handler last paramater out should be error type "+
                        "[method[%s] uri[%s]]", method, uri)
        }</span>

        // check (data any, page, count int, msg string, err error)
        <span class="cov9" title="46">if numOut := typ.NumOut(); numOut &gt; 1 </span><span class="cov6" title="12">{
                supportTypes := supportReturnTypeList[numOut-1]
                for i := 0; i &lt; numOut-1; i++ </span><span class="cov7" title="27">{
                        if !r.checkParamType(typ.Out(i), supportTypes[i]) </span><span class="cov0" title="0">{
                                return errors.Errorf("router handler paramater out format is illegal "+
                                        "[method[%s] uri[%s] index[%v] unsupported[%s] suppoted[%+v]]",
                                        method, uri, i+1, typ.Out(i).Kind(), supportTypes[i])
                        }</span>
                }
        }

        <span class="cov9" title="46">return</span>
}

var (
        supportReturnTypeList = map[int][]map[reflect.Kind]struct{}{
                1: {supportDataType},                                                 // data
                2: {supportDataType, supportMsgType},                                 // data, msg
                3: {supportDataType, supportIntType, supportMsgType},                 // data, count, msg
                4: {supportDataType, supportIntType, supportIntType, supportMsgType}, // data, page, count, msg
        }
        supportIntType = map[reflect.Kind]struct{}{
                reflect.Int:   {},
                reflect.Int8:  {},
                reflect.Int16: {},
                reflect.Int32: {},
                reflect.Int64: {},
        }
        supportDataType = map[reflect.Kind]struct{}{
                reflect.Map:       {},
                reflect.Array:     {},
                reflect.Slice:     {},
                reflect.Struct:    {},
                reflect.Interface: {},
        }
        supportMsgType = map[reflect.Kind]struct{}{
                reflect.String: {},
        }
        supportParamType = map[reflect.Kind]struct{}{
                reflect.Map:    {},
                reflect.Array:  {},
                reflect.Slice:  {},
                reflect.Struct: {},
        }
)

func (r *router) checkParamType(typ reflect.Type, supportType map[reflect.Kind]struct{}) bool <span class="cov9" title="60">{
        if typ.Kind() == reflect.Ptr </span><span class="cov8" title="31">{
                typ = typ.Elem()
        }</span>
        <span class="cov9" title="60">_, ok := supportType[typ.Kind()]
        return ok</span>
}

func (r *router) parseReqFromBody(c *gin.Context, typ reflect.Type) (dst reflect.Value, err error) <span class="cov8" title="28">{
        ptrDepth := 0
        for typ.Kind() == reflect.Ptr </span><span class="cov7" title="20">{
                typ = typ.Elem()
                ptrDepth++
        }</span>
        <span class="cov8" title="28">defer func() </span><span class="cov8" title="28">{
                for ptrDepth &gt; 0 </span><span class="cov7" title="20">{
                        dst = dst.Addr()
                        ptrDepth--
                }</span>
        }()

        <span class="cov8" title="28">bodyBytes, _ := io.ReadAll(c.Request.Body)
        c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

        dst = reflect.Indirect(reflect.New(typ))
        if err = c.ShouldBind(dst.Addr().Interface()); err != nil &amp;&amp;
                !(errors.Is(err, binding.ErrConvertToMapString) || (errors.Is(err, binding.ErrConvertMapStringSlice))) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="28">defer func() </span><span class="cov8" title="28">{ c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes)) }</span>()

        <span class="cov8" title="28">if dst.IsZero() </span><span class="cov4" title="6">{
                var (
                        p           parser.Parser
                        param       map[string]string
                        contentType string
                )
                if contentType, param, err = mime.ParseMediaType(c.GetHeader("Content-Type")); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov4" title="6">if p, err = parser.GetByContentType(contentType); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov4" title="6">if err = p.PreParse(param); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov4" title="6">c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
                if err = p.Parse(c.Request.Body, dst); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="28">err = utils.ParseTag(
                dst.Addr().Interface(),
                utils.ParseTagName("default"),
                utils.ParseTagUnmarshalType(utils.UnmarshalTypeYaml),
        )

        return</span>
}

func (r *router) parseReqFromQuery(c *gin.Context, typ reflect.Type) (dst reflect.Value, err error) <span class="cov4" title="5">{
        ptrDepth := 0
        for typ.Kind() == reflect.Ptr </span><span class="cov2" title="2">{
                typ = typ.Elem()
                ptrDepth++
        }</span>
        <span class="cov4" title="5">defer func() </span><span class="cov4" title="5">{
                for ptrDepth &gt; 0 </span><span class="cov2" title="2">{
                        dst = dst.Addr()
                        ptrDepth--
                }</span>
        }()

        <span class="cov4" title="5">dst = reflect.Indirect(reflect.New(typ))
        if err = c.ShouldBindUri(dst.Addr().Interface()); err != nil &amp;&amp;
                !(errors.Is(err, binding.ErrConvertToMapString) || (errors.Is(err, binding.ErrConvertMapStringSlice))) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="5">if err = c.ShouldBindQuery(dst.Addr().Interface()); err != nil &amp;&amp;
                !(errors.Is(err, binding.ErrConvertToMapString) || (errors.Is(err, binding.ErrConvertMapStringSlice))) </span><span class="cov0" title="0">{
                return
        }</span>
        // support query with json tag
        <span class="cov4" title="5">if dst.IsZero() </span><span class="cov4" title="5">{
                m := make(map[string][]string)
                for _, v := range c.Params </span><span class="cov1" title="1">{
                        m[v.Key] = []string{v.Value}
                }</span>
                <span class="cov4" title="5">err = utils.CheckIfAny(
                        func() error </span><span class="cov4" title="5">{ return parser.MapFormByTag(dst.Addr().Interface(), m, "json") }</span>,
                        func() error <span class="cov4" title="5">{ return parser.MapFormByTag(dst.Addr().Interface(), c.Request.URL.Query(), "json") }</span>,
                )
        }

        // parse default tag
        <span class="cov4" title="5">err = utils.ParseTag(
                dst.Addr().Interface(),
                utils.ParseTagName("default"),
                utils.ParseTagUnmarshalType(utils.UnmarshalTypeYaml),
        )

        return</span>
}

func (r *router) wrapHandlerFunc(handler routerHandler, reqParse routerRequestParser) gin.HandlerFunc <span class="cov8" title="33">{
        typ := reflect.TypeOf(handler)
        numOut := typ.NumOut()
        return func(c *gin.Context) </span><span class="cov8" title="33">{
                var (
                        err     error
                        reqVal  reflect.Value
                        rspVals []reflect.Value
                )

                // deal with request &amp; call handler
                if reqParse == nil </span><span class="cov0" title="0">{
                        rspVals = reflect.ValueOf(handler).Call([]reflect.Value{reflect.ValueOf(c)})
                }</span> else<span class="cov8" title="33"> if reqVal, err = reqParse(c, typ.In(1)); err == nil </span><span class="cov8" title="33">{
                        rspVals = reflect.ValueOf(handler).Call([]reflect.Value{reflect.ValueOf(c), reqVal})
                }</span> else<span class="cov0" title="0"> {
                        switch e := err.(type) </span>{
                        case *json.UnmarshalTypeError:<span class="cov0" title="0">
                                msg := fmt.Sprintf(": %s field type should be %s", e.Value, e.Type.String())
                                Error(parseRspError(c, r.appName, nil, Err(c, errParam, Param(map[string]any{"err": msg}))))</span>
                        default:<span class="cov0" title="0">
                                Error(parseRspError(c, r.appName, nil, Err(c, errParam,
                                        Param(map[string]any{"err": fmt.Sprintf(": %s", err.Error())}))))</span>
                        }
                        <span class="cov0" title="0">c.Next()
                        return</span>
                }

                // deal with response
                <span class="cov8" title="33">errVal := rspVals[numOut-1]
                if !errVal.IsNil() </span><span class="cov7" title="23">{
                        err = errVal.Interface().(error)
                }</span>
                <span class="cov8" title="33">rspVals = rspVals[:numOut-1]

                var rspType reflect.Type
                isEmbed, isResponse := false, false
                if len(rspVals) &gt; 0 </span><span class="cov6" title="12">{
                        rspType = utils.IndirectType(rspVals[0].Type())
                        isEmbed = utils.EmbedsType(rspType, embedType)
                        isResponse = utils.EmbedsType(rspType, responseType)
                }</span>

                <span class="cov8" title="33">switch </span>{
                // directly json marshal embed response
                case isEmbed, isResponse:<span class="cov1" title="1">
                        rspVal := reflect.Indirect(rspVals[0])
                        var rsp any
                        if rspVal.IsValid() </span><span class="cov1" title="1">{
                                rsp = rspVal.Interface()
                        }</span> else<span class="cov0" title="0"> {
                                rsp = reflect.New(rspType).Interface()
                        }</span>
                        <span class="cov1" title="1">embedResponse(c, r.appName, rsp, err)</span>

                // business error
                case err != nil:<span class="cov7" title="23">
                        Error(parseRspError(c, r.appName, rspVals, err))</span>

                // success with response
                default:<span class="cov5" title="9">
                        Success(parseRspSuccess(c, r.appName, rspVals))</span>
                }

                <span class="cov8" title="33">c.Next()</span>
        }
}

// 0: return error
// 1: return any, error
//    parse as map/struct -&gt; data, msg, count, page
//    parse as others     -&gt; data -&gt; {"code": 0, "data": []} or {"code": 0, "data": {}}
// 2: return data, msg, error
// 3: return data, count, msg, error
// &gt;3: return data, page, count, msg, unknowns..., error
func parseRspSuccess(c *gin.Context, srcName string, rspVals []reflect.Value) (
        ctx *gin.Context, dstName string, data any, page, count int, msg string) <span class="cov8" title="32">{
        ctx = c
        dstName = srcName

        switch </span>{
        case len(rspVals) == 0:<span class="cov7" title="21"></span>
        case len(rspVals) == 2:<span class="cov0" title="0">
                data = transformData(rspVals[0])
                msg = reflect.Indirect(rspVals[1]).String()</span>
        case len(rspVals) == 3:<span class="cov0" title="0">
                data = transformData(rspVals[0])
                count = cast.ToInt(reflect.Indirect(rspVals[1]).Int())
                msg = reflect.Indirect(rspVals[2]).String()</span>
        case len(rspVals) &gt; 3:<span class="cov4" title="5">
                data = transformData(rspVals[0])
                page = cast.ToInt(reflect.Indirect(rspVals[1]).Int())
                count = cast.ToInt(reflect.Indirect(rspVals[2]).Int())
                msg = reflect.Indirect(rspVals[3]).String()</span>
        default:<span class="cov4" title="6">
                data, page, count, msg = lookupFieldByStruct(rspVals[0])</span>
        }

        <span class="cov8" title="32">return</span>
}

func parseRspError(c *gin.Context, srcName string, rspVals []reflect.Value, err error) (
        ctx *gin.Context, dstName string, code int, data any, page, count int, msg string) <span class="cov7" title="23">{
        ctx = c
        dstName = srcName
        switch e := err.(type) </span>{
        case Errcode:<span class="cov0" title="0">
                code, msg = int(e), e.Error()</span>
        case *bizErr:<span class="cov0" title="0">
                code, msg = int(e.code), e.Error()</span>
        default:<span class="cov7" title="23">
                code, msg = http.StatusBadRequest, e.Error()</span>
        }

        <span class="cov7" title="23">_, _, data, page, count, retMsg := parseRspSuccess(c, dstName, rspVals)
        if retMsg != "" </span><span class="cov0" title="0">{
                msg = retMsg
        }</span>

        <span class="cov7" title="23">return</span>
}

func lookupFieldByStruct(rspStruct reflect.Value) (data any, page, count int, msg string) <span class="cov4" title="6">{
        var (
                routerResponsePageName = map[string]bool{
                        "page": true,
                        "Page": true,
                }
                routerResponseCountName = map[string]bool{
                        "count": true,
                        "Count": true,
                }
                routerResponseDataName = map[string]bool{
                        "data": true,
                        "Data": true,
                }
                routerResponseMsgName = map[string]bool{
                        "msg":     true,
                        "Msg":     true,
                        "message": true,
                        "Message": true,
                }
        )

        type lookupFunc func(v reflect.Value, keywords map[string]bool) (reflect.Value, bool)
        lookupFuncMap := map[reflect.Kind]lookupFunc{
                reflect.Map:    lookupFieldByMap,
                reflect.Struct: lookupFieldByValue,
        }

        rsp := utils.IndirectValue(rspStruct)
        lookup, ok := lookupFuncMap[rsp.Kind()]
        if !ok </span><span class="cov1" title="1">{
                data = rspStruct.Interface()
                return
        }</span>

        // cannot parse response.Data, resolve all rspStruct as data
        <span class="cov4" title="5">if dataValue, ok := lookup(rsp, routerResponseDataName); ok </span><span class="cov3" title="4">{
                if dataValue.IsValid() </span><span class="cov3" title="4">{
                        data = transformData(reflect.ValueOf(valueInterface(dataValue, false)))
                }</span>
        } else<span class="cov1" title="1"> {
                data = rspStruct.Interface()
                return
        }</span>
        <span class="cov3" title="4">if pageValue, ok := lookup(rsp, routerResponsePageName); ok &amp;&amp; pageValue.IsValid() </span><span class="cov3" title="4">{
                page = cast.ToInt(pageValue.Int())
        }</span>
        <span class="cov3" title="4">if countValue, ok := lookup(rsp, routerResponseCountName); ok &amp;&amp; countValue.IsValid() </span><span class="cov3" title="4">{
                count = cast.ToInt(countValue.Int())
        }</span>
        <span class="cov3" title="4">if msgValue, ok := lookup(rsp, routerResponseMsgName); ok &amp;&amp; msgValue.IsValid() </span><span class="cov3" title="4">{
                msg = msgValue.String()
        }</span>

        <span class="cov3" title="4">return</span>
}

func lookupFieldByValue(v reflect.Value, keywords map[string]bool) (reflect.Value, bool) <span class="cov6" title="12">{
        f := reflect.Indirect(v.FieldByNameFunc(func(s string) bool </span><span class="cov9" title="48">{ return keywords[s] }</span>))
        <span class="cov6" title="12">if !f.IsValid() || f.IsZero() </span><span class="cov0" title="0">{
                return reflect.Value{}, false
        }</span>
        <span class="cov6" title="12">return reflect.Indirect(f), true</span>
}

func lookupFieldByMap(v reflect.Value, keywords map[string]bool) (reflect.Value, bool) <span class="cov4" title="5">{
        vMap, ok := v.Interface().(map[string]any)
        if !ok </span><span class="cov1" title="1">{
                return reflect.Value{}, false
        }</span>

        <span class="cov3" title="4">for key := range keywords </span><span class="cov3" title="4">{
                if vv, ok := vMap[key]; ok </span><span class="cov3" title="4">{
                        return reflect.ValueOf(vv), true
                }</span>
        }
        <span class="cov0" title="0">return reflect.Value{}, false</span>
}

func transformData(data reflect.Value) (transformed any) <span class="cov5" title="9">{
        if !data.IsValid() </span><span class="cov0" title="0">{
                return
        }</span>

        // some structs return as an interface
        <span class="cov5" title="9">if data.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                data = reflect.ValueOf(data.Interface())
        }</span>
        <span class="cov5" title="9">if data = utils.IndirectValue(data); !data.IsValid() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="9">return data.Interface()</span>
}

type routerOption struct {
        parseFrom      parseFrom
        beforeHandlers []routerHandler
        aftersHandlers []routerHandler
}

func ParseFromBody() utils.OptionFunc[routerOption] <span class="cov0" title="0">{
        return func(r *routerOption) </span><span class="cov0" title="0">{
                r.parseFrom = parseFromBody
        }</span>
}

func ParseFromQuery() utils.OptionFunc[routerOption] <span class="cov0" title="0">{
        return func(r *routerOption) </span><span class="cov0" title="0">{
                r.parseFrom = parseFromQuery
        }</span>
}

func HandleBefore(beforeHandlers ...routerHandler) utils.OptionFunc[routerOption] <span class="cov0" title="0">{
        return func(o *routerOption) </span><span class="cov0" title="0">{
                o.beforeHandlers = beforeHandlers
        }</span>
}

func HandleAfter(aftersHandlers ...routerHandler) utils.OptionFunc[routerOption] <span class="cov0" title="0">{
        return func(o *routerOption) </span><span class="cov0" title="0">{
                o.aftersHandlers = aftersHandlers
        }</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package http

import (
        "io"
        "net"
        "net/http"
        "path"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/multierr"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/http/gracefully"
)

type getContentFn func(c *gin.Context) (name string, modTime time.Time, content io.ReadSeeker, err error)

// StaticFileZeroCopy zero copy gin handler wrapper for static file
func StaticFileZeroCopy(filename string) func(c *gin.Context) <span class="cov1" title="1">{
        filename = path.Clean(filename)
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                http.ServeFile(&amp;ginZeroCopyWriter{ResponseWriter: c.Writer, ctx: c}, c.Request, filename)
        }</span>
}

// ContentZeroCopy zero copy gin handler wrapper for seeker
func ContentZeroCopy(fn getContentFn, opts ...utils.OptionExtender) func(c *gin.Context) <span class="cov1" title="1">{
        opt := utils.ApplyOptions[useOption](opts...)
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                name, modTime, content, err := fn(c)
                if err != nil </span><span class="cov0" title="0">{
                        Error(parseRspError(c, opt.appName, nil, err))
                        c.Abort()
                        return
                }</span>
                <span class="cov1" title="1">defer utils.CloseAnyway(content)
                http.ServeContent(&amp;ginZeroCopyWriter{ResponseWriter: c.Writer, ctx: c}, c.Request, name, modTime, content)</span>
        }
}

type ginZeroCopyWriter struct {
        gin.ResponseWriter

        ctx *gin.Context
}

func (z *ginZeroCopyWriter) ReadFrom(r io.Reader) (n int64, err error) <span class="cov10" title="2">{
        var size int64
        if limitedReader, ok := r.(*io.LimitedReader); ok </span><span class="cov10" title="2">{
                size = limitedReader.N
        }</span>

        // forces to write the http header (status code + headers)
        <span class="cov10" title="2">z.ResponseWriter.WriteHeaderNow()
        if z.ctx.Request.Method == http.MethodHead </span><span class="cov0" title="0">{
                return size, nil
        }</span>

        // hijack conn to call zero copy
        <span class="cov10" title="2">var conn net.Conn
        _, err = utils.Catch(func() (err error) </span><span class="cov10" title="2">{ conn, _, err = z.ResponseWriter.Hijack(); return }</span>)
        <span class="cov10" title="2">if err != nil || conn == nil </span><span class="cov10" title="2">{
                // write by memory buffer
                if size &gt; 0 </span><span class="cov10" title="2">{
                        return io.CopyN(z.ResponseWriter, r.(*io.LimitedReader), size)
                }</span>
                <span class="cov0" title="0">return io.Copy(z.ResponseWriter, r)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := conn.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = multierr.Append(err, closeErr)
                }</span>
        }()

        // set write timeout again because it is reset when hijack
        <span class="cov0" title="0">if err = conn.SetWriteDeadline(time.Now().Add(gracefully.DefaultWriteTimeOut)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // write body
        <span class="cov0" title="0">return io.Copy(conn, r)</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package i18n

import (
        "context"

        "github.com/BurntSushi/toml"
        "github.com/nicksnyder/go-i18n/v2/i18n"
        "golang.org/x/text/language"
        "gopkg.in/yaml.v3"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
        "github.com/wfusion/gofusion/config"
)

func Construct(ctx context.Context, conf Conf, opts ...utils.OptionExtender) func() <span class="cov8" title="34">{
        var err error
        lang := defaultLang
        if utils.IsStrNotBlank(conf.DefaultLang) </span><span class="cov8" title="34">{
                if lang, err = language.Parse(conf.DefaultLang); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov8" title="34">opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov4" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov8" title="34">locker.Lock()
        defer locker.Unlock()
        if Bundle == nil </span><span class="cov6" title="12">{
                Bundle = &amp;bundle[int]{
                        dup:    utils.NewSet[int](),
                        bundle: i18n.NewBundle(lang),
                }
                Bundle.bundle.RegisterUnmarshalFunc("json", json.Unmarshal)
                Bundle.bundle.RegisterUnmarshalFunc("toml", toml.Unmarshal)
                Bundle.bundle.RegisterUnmarshalFunc("yaml", yaml.Unmarshal)
                Bundle.bundle.RegisterUnmarshalFunc("yml", yaml.Unmarshal)
        }</span>

        // ioc
        <span class="cov8" title="34">if opt.DI != nil </span><span class="cov8" title="34">{
                opt.DI.
                        MustProvide(func() Localizable[int] </span><span class="cov0" title="0">{ return NewBundle[int](lang) }</span>).
                        MustProvide(func() Localizable[string] <span class="cov0" title="0">{ return NewBundle[string](lang) }</span>)
        }

        <span class="cov8" title="34">return func() </span><span class="cov8" title="34">{
                locker.Lock()
                defer locker.Unlock()
                Bundle = &amp;bundle[int]{
                        dup:    utils.NewSet[int](),
                        bundle: i18n.NewBundle(lang),
                }
        }</span>
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov10" title="68">{
        return func(o *useOption) </span><span class="cov10" title="68">{
                o.appName = name
        }</span>
}

func DefaultLang(opts ...utils.OptionExtender) (lang language.Tag) <span class="cov10" title="68">{
        opt := utils.ApplyOptions[useOption](opts...)

        conf := new(Conf)
        utils.MustSuccess(config.Use(opt.appName).LoadComponentConfig(config.ComponentI18n, conf))
        return utils.Must(language.Parse(conf.DefaultLang))
}</span>

func init() <span class="cov6" title="14">{
        config.AddComponent(config.ComponentI18n, Construct)
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">package i18n

import (
        "sync"

        "github.com/BurntSushi/toml"
        "github.com/nicksnyder/go-i18n/v2/i18n"
        "github.com/pkg/errors"
        "github.com/spf13/cast"
        "golang.org/x/text/language"
        "gopkg.in/yaml.v3"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

var (
        Bundle *bundle[int]

        locker               sync.RWMutex
        defaultLang          = language.Chinese
        defaultErrorMessages = map[language.Tag]string{
                language.Chinese: "",
                language.English: "System error! Please try again later and contact your account manager if you need help!",
        }
)

type bundle[T comparable] struct {
        dup    *utils.Set[T]
        bundle *i18n.Bundle

        vars  map[T][]string
        mutex sync.RWMutex
}

func NewBundle[T comparable](lang language.Tag) Localizable[T] <span class="cov8" title="34">{
        b := &amp;bundle[T]{
                dup:    utils.NewSet[T](),
                bundle: i18n.NewBundle(lang),
                vars:   make(map[T][]string),
        }

        b.bundle.RegisterUnmarshalFunc("json", json.Unmarshal)
        b.bundle.RegisterUnmarshalFunc("toml", toml.Unmarshal)
        b.bundle.RegisterUnmarshalFunc("yaml", yaml.Unmarshal)
        b.bundle.RegisterUnmarshalFunc("yml", yaml.Unmarshal)

        return b
}</span>

type addMessagesOption struct {
        vars []string
}

func Var(vars ...string) utils.OptionFunc[addMessagesOption] <span class="cov8" title="34">{
        return func(o *addMessagesOption) </span><span class="cov8" title="34">{
                o.vars = vars
        }</span>
}

func (i *bundle[T]) AddMessages(code T, trans map[language.Tag]*Message, opts ...utils.OptionExtender) Localizable[T] <span class="cov8" title="35">{
        o := utils.ApplyOptions[addMessagesOption](opts...)

        i.mutex.Lock()
        defer i.mutex.Unlock()
        i.checkDuplicated(code, trans)

        id := cast.ToString(code)
        i.vars[code] = o.vars
        for lang, msg := range trans </span><span class="cov10" title="68">{
                i.bundle.MustAddMessages(lang, &amp;i18n.Message{
                        ID:          id,
                        Hash:        msg.Hash,
                        Description: msg.Description,
                        LeftDelim:   msg.LeftDelim,
                        RightDelim:  msg.RightDelim,
                        Zero:        msg.Zero,
                        One:         msg.One,
                        Two:         msg.Two,
                        Few:         msg.Few,
                        Many:        msg.Many,
                        Other:       msg.Other,
                })
        }</span>
        <span class="cov8" title="35">return i</span>
}

func (i *bundle[T]) checkDuplicated(code T, trans map[language.Tag]*Message) <span class="cov8" title="35">{
        if !i.dup.Contains(code) </span><span class="cov8" title="35">{
                i.dup.Insert(code)
                return
        }</span>
        <span class="cov0" title="0">if trans == nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("%+v %s code translation is empty", code, cast.ToString(code)))</span>
        }

        // panic if duplicated
        <span class="cov0" title="0">var (
                cfg                = &amp;i18n.LocalizeConfig{MessageID: cast.ToString(code)}
                existMsgEn         = i18n.NewLocalizer(i.bundle, language.English.String()).MustLocalize(cfg)
                existMsgCn         = i18n.NewLocalizer(i.bundle, language.Chinese.String()).MustLocalize(cfg)
                dupMsgCn, dupMsgEn string
        )
        if dupMsg, ok := trans[language.Chinese]; ok </span><span class="cov0" title="0">{
                dupMsgCn = dupMsg.Other
        }</span>
        <span class="cov0" title="0">if dupMsg, ok := trans[language.English]; ok </span><span class="cov0" title="0">{
                dupMsgEn = dupMsg.Other
        }</span>

        <span class="cov0" title="0">panic(errors.Errorf("%s(%s)(%+v)(%v) is duplicated with %s(%s)",
                dupMsgCn, dupMsgEn, code, cast.ToString(code), existMsgCn, existMsgEn))</span>
}

type localizeOption struct {
        lang         language.Tag
        langs        []string
        pluralCount  any
        templateData map[string]any
}

func Param(data map[string]any) utils.OptionFunc[localizeOption] <span class="cov0" title="0">{
        return func(o *localizeOption) </span><span class="cov0" title="0">{
                o.templateData = data
        }</span>
}

func Plural(pluralCount any) utils.OptionFunc[localizeOption] <span class="cov0" title="0">{
        return func(o *localizeOption) </span><span class="cov0" title="0">{
                o.pluralCount = pluralCount
        }</span>
}

func Lang(lang language.Tag) utils.OptionFunc[localizeOption] <span class="cov0" title="0">{
        return func(o *localizeOption) </span><span class="cov0" title="0">{
                o.lang = lang
        }</span>
}

func Langs(langs []string) utils.OptionFunc[localizeOption] <span class="cov0" title="0">{
        return func(o *localizeOption) </span><span class="cov0" title="0">{
                if len(langs) &gt; 0 </span><span class="cov0" title="0">{
                        o.lang, _ = language.Parse(langs[0])
                }</span>
                <span class="cov0" title="0">o.langs = clone.SliceComparable(langs)</span>
        }
}

func (i *bundle[T]) Localize(code T, opts ...utils.OptionExtender) (message string) <span class="cov0" title="0">{
        option := utils.ApplyOptions[localizeOption](opts...)
        if option.templateData == nil &amp;&amp; len(i.vars) &gt; 0 </span><span class="cov0" title="0">{
                option.templateData = make(map[string]any, len(i.vars))
        }</span>

        // TODO: Access the third-party internationalization platform to obtain text
        <span class="cov0" title="0">cfg := &amp;i18n.LocalizeConfig{
                MessageID:    cast.ToString(code),
                TemplateData: option.templateData,
                PluralCount:  option.pluralCount,
        }

        i.mutex.RLock()
        defer i.mutex.RUnlock()
        // Assign an empty string to a variable to avoid rendering &lt; no value &gt; data
        for _, v := range i.vars[code] </span><span class="cov0" title="0">{
                if _, ok := option.templateData[v]; !ok </span><span class="cov0" title="0">{
                        option.templateData[v] = ""
                }</span>
        }
        <span class="cov0" title="0">message, err := i18n.NewLocalizer(i.bundle, option.langs...).Localize(cfg)
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">message, ok := defaultErrorMessages[option.lang]
        if ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return defaultErrorMessages[defaultLang]</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">// Fork from github.com/jinzhu/configor@v1.2.2-0.20230118083828-f7a0fc7c9fc6
// Here is the license:
//
// The MIT License (MIT)
//
// Copyright (c) 2013-NOW Jinzhu &lt;wosmvp@gmail.com&gt;
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package configor

import (
        "crypto/sha256"
        "fmt"
        "io"
        "io/fs"
        "os"
        "reflect"
        "regexp"
        "time"

        "github.com/wfusion/gofusion/common/utils"
)

type Configor struct {
        *Config
        configHash     map[string]string
        configModTimes map[string]time.Time

        statFunc func(name string) (fs.FileInfo, error)
        hashFunc func(name string) (string, error)
}

type Config struct {
        Environment        string
        ENVPrefix          string
        Debug              bool
        Verbose            bool
        Silent             bool
        AutoReload         bool
        AutoReloadInterval time.Duration
        AutoReloadCallback func(config any)

        // In case of json files, this field will be used only when compiled with
        // go 1.10 or later.
        // This field will be ignored when compiled with go versions lower than 1.10.
        ErrorOnUnmatchedKeys bool

        // You can use embed.FS or any other fs.FS to load configs from. Default - use "os" package
        FS fs.FS
}

// New initialize a Configor
func New(config *Config) *Configor <span class="cov6" title="68">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;Config{}
        }</span>

        <span class="cov6" title="68">if os.Getenv("CONFIGOR_DEBUG_MODE") != "" </span><span class="cov0" title="0">{
                config.Debug = true
        }</span>

        <span class="cov6" title="68">if os.Getenv("CONFIGOR_VERBOSE_MODE") != "" </span><span class="cov0" title="0">{
                config.Verbose = true
        }</span>

        <span class="cov6" title="68">if os.Getenv("CONFIGOR_SILENT_MODE") != "" </span><span class="cov0" title="0">{
                config.Silent = true
        }</span>

        <span class="cov6" title="68">if config.AutoReload &amp;&amp; config.AutoReloadInterval == 0 </span><span class="cov6" title="66">{
                config.AutoReloadInterval = time.Second
        }</span>

        <span class="cov6" title="68">cfg := &amp;Configor{
                Config:         config,
                configHash:     make(map[string]string),
                configModTimes: make(map[string]time.Time),
                statFunc:       os.Stat,
                hashFunc: func(name string) (h string, err error) </span><span class="cov9" title="878">{
                        var file fs.File
                        if file, err = os.Open(name); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov9" title="880">defer utils.CloseAnyway(file)
                        sha256Hash := sha256.New()
                        if _, err = io.Copy(sha256Hash, file); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov9" title="879">h = string(sha256Hash.Sum(nil))
                        return</span>
                },
        }
        <span class="cov6" title="68">if cfg.FS != nil </span><span class="cov0" title="0">{
                cfg.statFunc = func(name string) (os.FileInfo, error) </span><span class="cov0" title="0">{
                        return fs.Stat(cfg.FS, name)
                }</span>
                <span class="cov0" title="0">cfg.hashFunc = func(name string) (h string, err error) </span><span class="cov0" title="0">{
                        var file fs.File
                        if file, err = cfg.FS.Open(name); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">defer utils.CloseAnyway(file)
                        sha256Hash := sha256.New()
                        if _, err = io.Copy(sha256Hash, file); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">h = string(sha256Hash.Sum(nil))
                        return</span>
                }
        }

        <span class="cov6" title="68">return cfg</span>
}

var testRegexp = regexp.MustCompile(`_test|(\.test$)`)

// GetEnvironment get environment
func (c *Configor) GetEnvironment() string <span class="cov10" title="1726">{
        if c.Environment == "" </span><span class="cov1" title="2">{
                if env := os.Getenv("CONFIGOR_ENV"); env != "" </span><span class="cov0" title="0">{
                        return env
                }</span>

                <span class="cov1" title="2">if testRegexp.MatchString(os.Args[0]) </span><span class="cov1" title="2">{
                        return "test"
                }</span>

                <span class="cov0" title="0">return "development"</span>
        }
        <span class="cov9" title="1718">return c.Environment</span>
}

// GetErrorOnUnmatchedKeys returns a boolean indicating if an error should be
// thrown if there are keys in the config file that do not correspond to the
// config struct
func (c *Configor) GetErrorOnUnmatchedKeys() bool <span class="cov7" title="228">{
        return c.ErrorOnUnmatchedKeys
}</span>

// Load will unmarshal configurations to struct from files that you provide
func (c *Configor) Load(config any, files ...string) (err error) <span class="cov6" title="68">{
        defaultValue := reflect.Indirect(reflect.ValueOf(config))
        if !defaultValue.CanAddr() </span><span class="cov0" title="0">{
                return fmt.Errorf("config %v should be addressable", config)
        }</span>
        <span class="cov6" title="68">err, _ = c.load(config, false, files...)

        if c.Config.AutoReload </span><span class="cov6" title="66">{
                go func() </span><span class="cov6" title="66">{
                        timer := time.NewTimer(c.Config.AutoReloadInterval)
                        for range timer.C </span><span class="cov9" title="1580">{
                                reflectPtr := reflect.New(reflect.ValueOf(config).Elem().Type())
                                reflectPtr.Elem().Set(defaultValue)

                                var changed bool
                                if err, changed = c.load(reflectPtr.Interface(), true, files...); err == nil &amp;&amp; changed </span><span class="cov4" title="20">{
                                        reflect.ValueOf(config).Elem().Set(reflectPtr.Elem())
                                        if c.Config.AutoReloadCallback != nil </span><span class="cov4" title="20">{
                                                c.Config.AutoReloadCallback(config)
                                        }</span>
                                } else<span class="cov9" title="1546"> if err != nil </span><span class="cov0" title="0">{
                                        if !c.Silent </span><span class="cov0" title="0">{
                                                fmt.Printf("Failed to reload configuration from %v, got error %v\n", files, err)
                                        }</span>
                                }
                                <span class="cov9" title="1570">timer.Reset(c.Config.AutoReloadInterval)</span>
                        }
                }()
        }
        <span class="cov6" title="68">return</span>
}

// ENV return environment
func ENV() string <span class="cov0" title="0">{
        return New(nil).GetEnvironment()
}</span>

// Load will unmarshal configurations to struct from files that you provide
func Load(config any, files ...string) error <span class="cov0" title="0">{
        return New(nil).Load(config, files...)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">// Fork from github.com/jinzhu/configor@v1.2.2-0.20230118083828-f7a0fc7c9fc6
// Here is the license:
//
// The MIT License (MIT)
//
// Copyright (c) 2013-NOW Jinzhu &lt;wosmvp@gmail.com&gt;
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package configor

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "io/ioutil"
        "log"
        "os"
        "path"
        "reflect"
        "strings"
        "time"

        "github.com/BurntSushi/toml"
        "gopkg.in/yaml.v3"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/serialize/json"
)

// UnmatchedTomlKeysError errors are returned by the Load function when
// ErrorOnUnmatchedKeys is set to true and there are unmatched keys in the input
// toml config file. The string returned by Error() contains the names of the
// missing keys.
type UnmatchedTomlKeysError struct {
        Keys []toml.Key
}

func (e *UnmatchedTomlKeysError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("There are keys in the config file that do not match any field in the given struct: %v", e.Keys)
}</span>

func (c *Configor) getENVPrefix(config any) string <span class="cov5" title="88">{
        if c.Config.ENVPrefix == "" </span><span class="cov5" title="88">{
                if prefix := os.Getenv("CONFIGOR_ENV_PREFIX"); prefix != "" </span><span class="cov0" title="0">{
                        return prefix
                }</span>
                <span class="cov5" title="88">return "Configor"</span>
        }
        <span class="cov0" title="0">return c.Config.ENVPrefix</span>
}

func (c *Configor) getConfigurationFileWithENVPrefix(file, env string) (string, time.Time, string, error) <span class="cov9" title="2533">{
        var (
                envFile string
                extname = path.Ext(file)
        )

        if extname == "" </span><span class="cov0" title="0">{
                envFile = fmt.Sprintf("%v.%v", file, env)
        }</span> else<span class="cov9" title="2593"> {
                envFile = fmt.Sprintf("%v.%v%v", strings.TrimSuffix(file, extname), env, extname)
        }</span>

        <span class="cov9" title="2573">if fileInfo, err := c.statFunc(envFile); err == nil &amp;&amp; fileInfo.Mode().IsRegular() </span><span class="cov0" title="0">{
                fileHash, _ := c.hashFunc(envFile)
                return envFile, fileInfo.ModTime(), fileHash, nil
        }</span>
        <span class="cov9" title="2599">return "", time.Now(), "", fmt.Errorf("failed to find file %v", file)</span>
}

func (c *Configor) getConfigurationFiles(config *Config, watchMode bool, files ...string) (
        []string, map[string]time.Time, map[string]string) <span class="cov8" title="1647">{
        resultKeys := make([]string, 0, len(files))
        hashResult := make(map[string]string, len(files))
        modTimeResult := make(map[string]time.Time, len(files))
        if !watchMode &amp;&amp; (c.Config.Debug || c.Config.Verbose) </span><span class="cov0" title="0">{
                fmt.Printf("Current environment: '%v'\n", c.GetEnvironment())
        }</span>

        <span class="cov8" title="1647">for i := len(files) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1744">{
                foundFile := false
                file := files[i]

                // check configuration
                if fileInfo, err := c.statFunc(file); err == nil &amp;&amp; fileInfo.Mode().IsRegular() </span><span class="cov8" title="874">{
                        foundFile = true
                        resultKeys = append(resultKeys, file)
                        modTimeResult[file] = fileInfo.ModTime()
                        if hash, err := c.hashFunc(file); err == nil </span><span class="cov8" title="880">{
                                hashResult[file] = hash
                        }</span>
                }

                // check configuration with env
                <span class="cov8" title="1721">if file, modTime, hash, err := c.getConfigurationFileWithENVPrefix(file, c.GetEnvironment()); err == nil </span><span class="cov0" title="0">{
                        foundFile = true
                        resultKeys = append(resultKeys, file)
                        modTimeResult[file] = modTime
                        if hash != "" </span><span class="cov0" title="0">{
                                hashResult[file] = hash
                        }</span>
                }

                // check example configuration
                <span class="cov8" title="1733">if !foundFile </span><span class="cov8" title="858">{
                        if example, modTime, hash, err := c.getConfigurationFileWithENVPrefix(file, "example"); err == nil </span><span class="cov0" title="0">{
                                if !watchMode &amp;&amp; !c.Silent </span><span class="cov0" title="0">{
                                        log.Printf("Failed to find configuration %v, using example file %v\n", file, example)
                                }</span>
                                <span class="cov0" title="0">resultKeys = append(resultKeys, example)
                                modTimeResult[example] = modTime
                                if hash != "" </span><span class="cov0" title="0">{
                                        hashResult[file] = hash
                                }</span>
                        } else<span class="cov8" title="859"> if !c.Silent </span><span class="cov1" title="2">{
                                fmt.Printf("Failed to find configuration %v\n", file)
                        }</span>
                }
        }
        <span class="cov8" title="1642">return resultKeys, modTimeResult, hashResult</span>
}

func (c *Configor) processFile(config any, file string, errorOnUnmatchedKeys bool) error <span class="cov6" title="228">{
        readFile := ioutil.ReadFile
        if c.FS != nil </span><span class="cov0" title="0">{
                readFile = func(filename string) ([]byte, error) </span><span class="cov0" title="0">{
                        return fs.ReadFile(c.FS, filename)
                }</span>
        }
        <span class="cov6" title="228">data, err := readFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="228">switch </span>{
        case strings.HasSuffix(file, ".yaml") || strings.HasSuffix(file, ".yml"):<span class="cov6" title="164">
                if errorOnUnmatchedKeys </span><span class="cov0" title="0">{
                        decoder := yaml.NewDecoder(bytes.NewBuffer(data))
                        decoder.KnownFields(true)
                        return decoder.Decode(config)
                }</span>
                <span class="cov6" title="164">return yaml.Unmarshal(data, config)</span>
        case strings.HasSuffix(file, ".toml"):<span class="cov4" title="32">
                return unmarshalToml(data, config, errorOnUnmatchedKeys)</span>
        case strings.HasSuffix(file, ".json"):<span class="cov4" title="32">
                return unmarshalJSON(data, config, errorOnUnmatchedKeys)</span>
        default:<span class="cov0" title="0">
                if err := unmarshalToml(data, config, errorOnUnmatchedKeys); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> if errUnmatchedKeys, ok := err.(*UnmatchedTomlKeysError); ok </span><span class="cov0" title="0">{
                        return errUnmatchedKeys
                }</span>

                <span class="cov0" title="0">if err := unmarshalJSON(data, config, errorOnUnmatchedKeys); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> if strings.Contains(err.Error(), "json: unknown field") </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var yamlError error
                if errorOnUnmatchedKeys </span><span class="cov0" title="0">{
                        decoder := yaml.NewDecoder(bytes.NewBuffer(data))
                        decoder.KnownFields(true)
                        yamlError = decoder.Decode(config)
                }</span> else<span class="cov0" title="0"> {
                        yamlError = yaml.Unmarshal(data, config)
                }</span>

                <span class="cov0" title="0">if yamlError == nil </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> if yErr, ok := yamlError.(*yaml.TypeError); ok </span><span class="cov0" title="0">{
                        return yErr
                }</span>

                <span class="cov0" title="0">return errors.New("failed to decode config")</span>
        }
}

func unmarshalToml(data []byte, config any, errorOnUnmatchedKeys bool) error <span class="cov4" title="32">{
        metadata, err := toml.Decode(string(data), config)
        if err == nil &amp;&amp; len(metadata.Undecoded()) &gt; 0 &amp;&amp; errorOnUnmatchedKeys </span><span class="cov0" title="0">{
                return &amp;UnmatchedTomlKeysError{Keys: metadata.Undecoded()}
        }</span>
        <span class="cov4" title="32">return err</span>
}

// unmarshalJSON unmarshals the given data into the config interface.
// If the errorOnUnmatchedKeys boolean is true, an error will be returned if there
// are keys in the data that do not match fields in the config interface.
func unmarshalJSON(data []byte, config any, errorOnUnmatchedKeys bool) error <span class="cov4" title="32">{
        reader := strings.NewReader(string(data))
        decoder := json.NewDecoder(reader)

        if errorOnUnmatchedKeys </span><span class="cov0" title="0">{
                decoder.DisallowUnknownFields()
        }</span>

        <span class="cov4" title="32">err := decoder.Decode(config)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="32">return nil</span>
}

func getPrefixForStruct(prefixes []string, fieldStruct *reflect.StructField) []string <span class="cov7" title="332">{
        if fieldStruct.Anonymous &amp;&amp; fieldStruct.Tag.Get("anonymous") == "true" </span><span class="cov0" title="0">{
                return prefixes
        }</span>
        <span class="cov7" title="332">return append(prefixes, fieldStruct.Name)</span>
}

func (c *Configor) processTags(config any, prefixes ...string) error <span class="cov7" title="420">{
        configValue := reflect.Indirect(reflect.ValueOf(config))
        if configValue.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return errors.New("invalid config, should be struct")
        }</span>

        <span class="cov7" title="420">configType := configValue.Type()
        for i := 0; i &lt; configType.NumField(); i++ </span><span class="cov9" title="2288">{
                var (
                        envNames    []string
                        fieldStruct = configType.Field(i)
                        field       = configValue.Field(i)
                        envName     = fieldStruct.Tag.Get("env") // read configuration from shell env
                )

                if !field.CanAddr() || !field.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov9" title="2288">if envName == "" </span><span class="cov9" title="2288">{
                        envNames = append(envNames,
                                strings.Join(append(prefixes, fieldStruct.Name), "_")) // Configor_DB_Name
                        envNames = append(envNames,
                                strings.ToUpper(strings.Join(append(prefixes, fieldStruct.Name), "_"))) // CONFIGOR_DB_NAME
                }</span> else<span class="cov0" title="0"> {
                        envNames = []string{envName}
                }</span>

                <span class="cov9" title="2288">if c.Config.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Trying to load struct `%v`'s field `%v` from env %v\n",
                                configType.Name(), fieldStruct.Name, strings.Join(envNames, ", "))
                }</span>

                // Load From Shell ENV
                <span class="cov9" title="2288">for _, env := range envNames </span><span class="cov10" title="4576">{
                        if value := os.Getenv(env); value != "" </span><span class="cov0" title="0">{
                                if c.Config.Debug || c.Config.Verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Loading configuration for struct `%v`'s field `%v` from env %v...\n",
                                                configType.Name(), fieldStruct.Name, env)
                                }</span>

                                <span class="cov0" title="0">switch reflect.Indirect(field).Kind() </span>{
                                case reflect.Bool:<span class="cov0" title="0">
                                        switch strings.ToLower(value) </span>{
                                        case "", "0", "f", "false":<span class="cov0" title="0">
                                                field.Set(reflect.ValueOf(false))</span>
                                        default:<span class="cov0" title="0">
                                                field.Set(reflect.ValueOf(true))</span>
                                        }
                                case reflect.String:<span class="cov0" title="0">
                                        field.Set(reflect.ValueOf(value))</span>
                                default:<span class="cov0" title="0">
                                        if err := yaml.Unmarshal([]byte(value), field.Addr().Interface()); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }
                }

                <span class="cov9" title="2288">if isBlank := reflect.DeepEqual(field.Interface(), reflect.Zero(field.Type()).Interface()); isBlank &amp;&amp;
                        fieldStruct.Tag.Get("required") == "true" </span><span class="cov0" title="0">{
                        // return error if it is required but blank
                        return errors.New(fieldStruct.Name + " is required, but blank")
                }</span>

                <span class="cov9" title="2288">field = utils.IndirectValue(field)
                if field.Kind() == reflect.Struct </span><span class="cov7" title="288">{
                        if err := c.processTags(field.Addr().Interface(),
                                getPrefixForStruct(prefixes, &amp;fieldStruct)...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov9" title="2288">if field.Kind() == reflect.Slice </span><span class="cov6" title="156">{
                        if arrLen := field.Len(); arrLen &gt; 0 </span><span class="cov5" title="90">{
                                for i := 0; i &lt; arrLen; i++ </span><span class="cov5" title="90">{
                                        if reflect.Indirect(field.Index(i)).Kind() == reflect.Struct </span><span class="cov3" title="13">{
                                                if err := c.processTags(field.Index(i).Addr().Interface(),
                                                        append(getPrefixForStruct(prefixes, &amp;fieldStruct), fmt.Sprint(i))...); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                }
                        } else<span class="cov5" title="66"> {
                                defer func(field reflect.Value, fieldStruct reflect.StructField) </span><span class="cov5" title="66">{
                                        if !configValue.IsZero() </span><span class="cov5" title="66">{
                                                // load slice from env
                                                newVal := reflect.New(field.Type().Elem()).Elem()
                                                if newVal.Kind() == reflect.Struct </span><span class="cov4" title="31">{
                                                        idx := 0
                                                        for </span><span class="cov4" title="31">{
                                                                newVal = reflect.New(field.Type().Elem()).Elem()
                                                                if err := c.processTags(newVal.Addr().Interface(), append(
                                                                        getPrefixForStruct(prefixes, &amp;fieldStruct), fmt.Sprint(idx))...); err != nil </span><span class="cov0" title="0">{
                                                                        return // err
                                                                }</span> else<span class="cov4" title="31"> if reflect.DeepEqual(newVal.Interface(),
                                                                        reflect.New(field.Type().Elem()).Elem().Interface()) </span><span class="cov4" title="31">{
                                                                        break</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        idx++
                                                                        field.Set(reflect.Append(field, newVal))
                                                                }</span>
                                                        }
                                                }
                                        }
                                }(field, fieldStruct)
                        }
                }
        }
        <span class="cov7" title="420">return nil</span>
}

func (c *Configor) load(config any, watchMode bool, files ...string) (err error, changed bool) <span class="cov8" title="1648">{
        defer func() </span><span class="cov8" title="1642">{
                if c.Config.Debug || c.Config.Verbose </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to load configuration from %v, got %v\n", files, err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Configuration:\n  %#v\n", config)</span>
                }
        }()

        <span class="cov8" title="1648">configFiles, configModTimeMap, hashMap := c.getConfigurationFiles(c.Config, watchMode, files...)
        if watchMode &amp;&amp; len(configModTimeMap) == len(c.configModTimes) &amp;&amp; len(hashMap) == len(c.configHash) </span><span class="cov8" title="1553">{
                var changed bool
                for f, curModTime := range configModTimeMap </span><span class="cov8" title="766">{
                        curHash := hashMap[f]
                        preHash, ok1 := c.configHash[f]
                        preModTime, ok2 := c.configModTimes[f]
                        if changed = !ok1 || !ok2 || curModTime.After(preModTime) || curHash != preHash; changed </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov8" title="1545">if !changed </span><span class="cov8" title="1545">{
                        return nil, false
                }</span>
        }

        <span class="cov5" title="88">type withCallback interface {
                BeforeLoad(any)
                AfterLoad(any)
        }
        if cb, ok := config.(withCallback); ok </span><span class="cov3" title="14">{
                cb.BeforeLoad(config)
                defer cb.AfterLoad(config)
        }</span>

        <span class="cov5" title="88">for _, file := range configFiles </span><span class="cov6" title="114">{
                if c.Config.Debug || c.Config.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Loading configurations from file '%v'...\n", file)
                }</span>
                <span class="cov6" title="114">if err = c.processFile(config, file, c.GetErrorOnUnmatchedKeys()); err != nil </span><span class="cov0" title="0">{
                        return err, true
                }</span>
        }

        // process defaults after process file because map struct should be assigned first
        <span class="cov5" title="88">_ = utils.ParseTag(config, utils.ParseTagName("default"), utils.ParseTagUnmarshalType(utils.UnmarshalTypeYaml))

        // process file again to ensure read config from file
        for _, file := range configFiles </span><span class="cov6" title="114">{
                if c.Config.Debug || c.Config.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Loading configurations from file '%v'...\n", file)
                }</span>
                <span class="cov6" title="114">if err = c.processFile(config, file, c.GetErrorOnUnmatchedKeys()); err != nil </span><span class="cov0" title="0">{
                        return err, true
                }</span>
        }

        <span class="cov5" title="88">c.configHash = hashMap
        c.configModTimes = configModTimeMap

        if prefix := c.getENVPrefix(config); prefix == "-" </span><span class="cov0" title="0">{
                err = c.processTags(config)
        }</span> else<span class="cov5" title="88"> {
                err = c.processTags(config, prefix)
        }</span>

        // process defaults
        <span class="cov5" title="88">_ = utils.ParseTag(config, utils.ParseTagName("default"), utils.ParseTagUnmarshalType(utils.UnmarshalTypeYaml))

        return err, true</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package pd

import (
        "encoding/binary"
        "reflect"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/encode"
        "github.com/wfusion/gofusion/common/utils/serialize"

        fmkCtx "github.com/wfusion/gofusion/context"
)

func Seal(data any, opts ...utils.OptionExtender) (dst []byte, err error) <span class="cov9" title="5916">{
        opt := utils.ApplyOptions[option](opts...)

        dstBuffer, cb := utils.BytesBufferPool.Get(nil)
        defer cb()

        dbytes, ok1 := data.([]byte)
        dstring, ok2 := data.(string)
        isRaw := ok1 || ok2

        // magic number
        if err = binary.Write(dstBuffer, binary.LittleEndian, sealMagicNumber); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // seal info
        <span class="cov9" title="5915">inf := sealTypeNumber
        if opt.version &gt; 0 </span><span class="cov0" title="0">{
                inf[0] = opt.version
        }</span>
        <span class="cov9" title="5912">if isRaw </span><span class="cov0" title="0">{
                inf[3] = 1
        }</span> else<span class="cov9" title="5912"> {
                inf[1] = opt.serializeType.Value()
        }</span>
        <span class="cov9" title="5910">inf[2] = opt.compressType.Value()
        if err = binary.Write(dstBuffer, binary.LittleEndian, inf[:]); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // seal encrypted info TODO

        // seal context
        <span class="cov9" title="5916">if opt.ctx == nil </span><span class="cov9" title="5909">{
                if err = binary.Write(dstBuffer, binary.LittleEndian, uint64(0)); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov2" title="6"> {
                ctxBytes := fmkCtx.Flatten(opt.ctx).Marshal()
                if err = binary.Write(dstBuffer, binary.LittleEndian, uint64(len(ctxBytes))); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov2" title="6">if err = binary.Write(dstBuffer, binary.LittleEndian, ctxBytes); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // seal data type
        <span class="cov9" title="5916">dt := utils.IndirectValue(reflect.ValueOf(data)).Type()
        structName := dt.PkgPath() + "." + dt.Name()
        if err = binary.Write(dstBuffer, binary.LittleEndian, uint64(len(structName))); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="5913">if err = binary.Write(dstBuffer, binary.LittleEndian, []byte(structName)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // seal data
        <span class="cov9" title="5909">marshaledBuffer, cb := utils.BytesBufferPool.Get(nil)
        defer cb()

        if isRaw </span><span class="cov0" title="0">{
                switch </span>{
                case ok1:<span class="cov0" title="0">
                        marshaledBuffer.Write(dbytes)</span>
                case ok2:<span class="cov0" title="0">
                        marshaledBuffer.WriteString(dstring)</span>
                }
        } else<span class="cov9" title="5916"> {
                marshalFunc := serialize.MarshalStreamFunc(opt.serializeType, serialize.JsonEscapeHTML(false))
                if err = marshalFunc(marshaledBuffer, data); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov9" title="5916">var encoded []byte
        if opt.compressType.IsValid() </span><span class="cov9" title="4932">{
                encoded, err = encode.From(marshaledBuffer.Bytes()).Encode(encode.Compress(opt.compressType)).ToBytes()
        }</span> else<span class="cov8" title="985"> {
                encoded = marshaledBuffer.Bytes()
        }</span>
        <span class="cov10" title="5917">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="5917">if err = binary.Write(dstBuffer, binary.LittleEndian, uint64(len(encoded))); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="5916">if err = binary.Write(dstBuffer, binary.LittleEndian, encoded); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="5917">dst = make([]byte, dstBuffer.Len())
        copy(dst, dstBuffer.Bytes())
        return</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package pd

import (
        "context"
        "reflect"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/serialize"
)

var (
        // sealMagicNumber FF FF FF FB: magic number
        sealMagicNumber uint32 = 0xFFFFFFFB
        // sealTypeNumber 01 00 00 00: version, serialize type, compress type, raw flag, encrypted info length
        sealTypeNumber   = [8]byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
        sealPrefixLength = 4 + len(sealTypeNumber)
)

type option struct {
        ctx           context.Context
        serializeType serialize.Algorithm
        compressType  compress.Algorithm
        dataType      reflect.Type
        version       byte
}

func Context(ctx context.Context) utils.OptionFunc[option] <span class="cov2" title="6">{
        return func(o *option) </span><span class="cov2" title="6">{
                o.ctx = ctx
        }</span>
}

func Serialize(serializeType serialize.Algorithm) utils.OptionFunc[option] <span class="cov9" title="5996">{
        return func(o *option) </span><span class="cov9" title="5990">{
                o.serializeType = serializeType
        }</span>
}

func Compress(compressType compress.Algorithm) utils.OptionFunc[option] <span class="cov10" title="6036">{
        return func(o *option) </span><span class="cov9" title="5991">{
                o.compressType = compressType
        }</span>
}

func Type(typ reflect.Type) utils.OptionFunc[option] <span class="cov5" title="86">{
        return func(o *option) </span><span class="cov5" title="86">{
                o.dataType = typ
        }</span>
}

func Version(ver uint8) utils.OptionFunc[option] <span class="cov0" title="0">{
        return func(o *option) </span><span class="cov0" title="0">{
                o.version = ver
        }</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package pd

import (
        "context"
        "encoding/binary"
        "reflect"

        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/encode"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/common/utils/serialize"

        fmkCtx "github.com/wfusion/gofusion/context"
)

func Unseal(src []byte, opts ...utils.OptionExtender) (ctx context.Context, dst any, ok bool, err error) <span class="cov6" title="86">{
        if len(src) &lt;= sealPrefixLength </span><span class="cov0" title="0">{
                return defaultUnseal(src, opts...)
        }</span>

        // unseal magic number
        <span class="cov6" title="86">magicNumber, next := src[:4], src[4:]
        if binary.LittleEndian.Uint32(magicNumber) != sealMagicNumber </span><span class="cov0" title="0">{
                return defaultUnseal(src, opts...)
        }</span>

        // unseal info
        <span class="cov6" title="86">inf, next := next[:len(sealTypeNumber)], next[len(sealTypeNumber):]
        switch inf[0] </span>{
        case 1:<span class="cov6" title="86">
                return unsealV1(inf, next, opts...)</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unsupported message version for unseal: %v", inf[0]))</span>
        }
}

func unsealV1(inf, src []byte, opts ...utils.OptionExtender) (ctx context.Context, dst any, ok bool, err error) <span class="cov6" title="86">{
        opt := utils.ApplyOptions[option](opts...)
        serializeType := serialize.ParseAlgorithm(serialize.Algorithm(inf[1]))
        if opt.serializeType.IsValid() </span><span class="cov6" title="80">{
                serializeType = opt.serializeType
        }</span>
        <span class="cov6" title="86">compressType := compress.ParseAlgorithm(compress.Algorithm(inf[2]))
        if opt.compressType.IsValid() </span><span class="cov4" title="30">{
                compressType = opt.compressType
        }</span>

        <span class="cov6" title="86">isRaw := false
        if inf[3] == 1 </span><span class="cov0" title="0">{
                isRaw = true
        }</span>

        // unseal encrypted inf
        <span class="cov6" title="86">encryptedInfLength := binary.LittleEndian.Uint32(inf[4:])
        _, src = src[:encryptedInfLength], src[encryptedInfLength:]

        // unseal context
        contextLengthBytes, src := src[:8], src[8:]
        contextLength := binary.LittleEndian.Uint64(contextLengthBytes)
        if contextLength &gt; 0 </span><span class="cov3" title="6">{
                var contextBytes []byte
                contextBytes, src = src[:contextLength], src[contextLength:]
                ctx = fmkCtx.New(fmkCtx.Context(contextBytes))
        }</span>

        // unseal data type
        <span class="cov6" title="86">inf, src = src[:8], src[8:]
        structNameLength := binary.LittleEndian.Uint64(inf)
        structName, src := src[:structNameLength], src[structNameLength:]
        if !isRaw &amp;&amp; opt.dataType == nil </span><span class="cov0" title="0">{
                if opt.dataType = inspect.TypeOf(string(structName)); opt.dataType == nil </span><span class="cov0" title="0">{
                        opt.dataType = reflect.TypeOf((*any)(nil)).Elem()
                }</span>
        }

        // unseal data
        // unseal data length
        <span class="cov6" title="86">_, src = src[:8], src[8:]
        // binary.LittleEndian.Uint64(src[:8])

        // unseal data
        var decoded []byte
        if compressType.IsValid() </span><span class="cov5" title="32">{
                decoded, err = encode.From(src).Decode(encode.Compress(compressType)).ToBytes()
        }</span> else<span class="cov5" title="54"> {
                decoded = src
        }</span>
        <span class="cov6" title="86">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="86">if !serializeType.IsValid() </span><span class="cov0" title="0">{
                dst = decoded
        }</span> else<span class="cov6" title="86"> {
                dstBuffer, cb := utils.BytesBufferPool.Get(nil)
                defer cb()
                dstBuffer.Write(decoded)

                unmarshalFunc := serialize.UnmarshalStreamFuncByType(serializeType, opt.dataType)
                if dst, err = unmarshalFunc(dstBuffer); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov6" title="86">ok = true
        return</span>
}

func UnsealT[T any](src []byte, opts ...utils.OptionExtender) (ctx context.Context, dst T, ok bool, err error) <span class="cov10" title="2209">{
        if len(src) &lt;= sealPrefixLength </span><span class="cov0" title="0">{
                return
        }</span>

        // unseal magic number
        <span class="cov10" title="2209">magicNumber, src := src[:4], src[4:]
        if binary.LittleEndian.Uint32(magicNumber) != sealMagicNumber </span><span class="cov0" title="0">{
                return
        }</span>

        // unseal info
        <span class="cov10" title="2209">inf, src := src[:len(sealTypeNumber)], src[len(sealTypeNumber):]
        switch inf[0] </span>{
        case 1:<span class="cov10" title="2209">
                return unsealV1T[T](inf, src, opts...)</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unsupported message version for unseal: %v", inf[0]))</span>
        }
}

func unsealV1T[T any](inf, src []byte, opts ...utils.OptionExtender) (ctx context.Context, dst T, ok bool, err error) <span class="cov10" title="2209">{
        opt := utils.ApplyOptions[option](opts...)
        serializeType := serialize.ParseAlgorithm(serialize.Algorithm(inf[1]))
        if opt.serializeType.IsValid() </span><span class="cov0" title="0">{
                serializeType = opt.serializeType
        }</span>
        <span class="cov10" title="2209">compressType := compress.ParseAlgorithm(compress.Algorithm(inf[2]))
        if opt.compressType.IsValid() </span><span class="cov0" title="0">{
                compressType = opt.compressType
        }</span>

        <span class="cov10" title="2209">isRaw := false
        if inf[3] == 1 </span><span class="cov0" title="0">{
                isRaw = true
        }</span>

        // unseal encrypted inf
        <span class="cov10" title="2209">encryptedInfLength := binary.LittleEndian.Uint32(inf[4:])
        _, src = src[:encryptedInfLength], src[encryptedInfLength:]

        // unseal context
        contextLengthBytes, src := src[:8], src[8:]
        contextLength := binary.LittleEndian.Uint64(contextLengthBytes)
        if contextLength &gt; 0 </span><span class="cov0" title="0">{
                var contextBytes []byte
                contextBytes, src = src[:contextLength], src[contextLength:]
                ctx = fmkCtx.New(fmkCtx.Context(contextBytes))
        }</span>

        // unseal data type
        <span class="cov10" title="2209">inf, src = src[:8], src[8:]
        structNameLength := binary.LittleEndian.Uint64(inf)
        structName, src := src[:structNameLength], src[structNameLength:]
        if !isRaw &amp;&amp; opt.dataType == nil </span><span class="cov10" title="2209">{
                if opt.dataType = inspect.TypeOf(string(structName)); opt.dataType == nil </span><span class="cov0" title="0">{
                        opt.dataType = reflect.TypeOf((*any)(nil)).Elem()
                }</span>
        }

        // unseal data
        // unseal data length
        <span class="cov9" title="2208">_, src = src[:8], src[8:]
        // binary.LittleEndian.Uint64(src[:8])

        // unseal data
        var decoded []byte
        if compressType.IsValid() </span><span class="cov9" title="1599">{
                decoded, err = encode.From(src).Decode(encode.Compress(compressType)).ToBytes()
        }</span> else<span class="cov8" title="609"> {
                decoded = src
        }</span>
        <span class="cov10" title="2209">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="2209">if !serializeType.IsValid() </span><span class="cov0" title="0">{
                dst = reflect.ValueOf(decoded).Convert(reflect.TypeOf(new(T)).Elem()).Interface().(T)
        }</span> else<span class="cov10" title="2209"> {
                dstBuffer, cb := utils.BytesBufferPool.Get(nil)
                defer cb()
                dstBuffer.Write(decoded)

                unmarshalFunc := serialize.UnmarshalStreamFunc[T](serializeType)
                if dst, err = unmarshalFunc(dstBuffer); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov10" title="2209">ok = true
        return</span>
}

func UnsealRaw(src []byte, opts ...utils.OptionExtender) (ctx context.Context, dst []byte, isRaw bool, err error) <span class="cov5" title="40">{
        if len(src) &lt;= sealPrefixLength </span><span class="cov0" title="0">{
                return nil, src, true, nil
        }</span>

        // unseal magic number
        <span class="cov5" title="40">magicNumber, next := src[:4], src[4:]
        if binary.LittleEndian.Uint32(magicNumber) != sealMagicNumber </span><span class="cov5" title="40">{
                return nil, src, true, nil
        }</span>

        // unseal info
        <span class="cov0" title="0">inf, src := next[:len(sealTypeNumber)], next[len(sealTypeNumber):]
        switch inf[0] </span>{
        case 1:<span class="cov0" title="0">
                return unsealRawV1(inf, src, opts...)</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unsupported message version for unseal raw: %v", inf[0]))</span>
        }
        <span class="cov0" title="0">return</span>
}

func unsealRawV1(inf, src []byte, opts ...utils.OptionExtender) (
        ctx context.Context, dst []byte, isRaw bool, err error) <span class="cov0" title="0">{
        opt := utils.ApplyOptions[option](opts...)
        compressType := compress.ParseAlgorithm(compress.Algorithm(inf[2]))
        if opt.compressType.IsValid() </span><span class="cov0" title="0">{
                compressType = opt.compressType
        }</span>
        <span class="cov0" title="0">if src[3] == 1 </span><span class="cov0" title="0">{
                isRaw = true
        }</span>

        // unseal encrypted inf
        <span class="cov0" title="0">encryptedInfLength := binary.LittleEndian.Uint32(inf[4:])
        _, src = src[:encryptedInfLength], src[encryptedInfLength:]

        // unseal context
        contextLengthBytes, src := src[:8], src[8:]
        contextLength := binary.LittleEndian.Uint64(contextLengthBytes)
        if contextLength &gt; 0 </span><span class="cov0" title="0">{
                var contextBytes []byte
                contextBytes, src = src[:contextLength], src[contextLength:]
                ctx = fmkCtx.New(fmkCtx.Context(contextBytes))
        }</span>

        // unseal data type
        <span class="cov0" title="0">inf, src = src[:8], src[8:]
        structNameLength := binary.LittleEndian.Uint64(inf)
        _, src = src[:structNameLength], src[structNameLength:]

        // unseal data
        // unseal data length
        _, src = src[:8], src[8:]
        // binary.LittleEndian.Uint64(src[:8])

        // unseal data
        if compressType.IsValid() </span><span class="cov0" title="0">{
                dst, err = encode.From(src).Decode(encode.Compress(compressType)).ToBytes()
        }</span> else<span class="cov0" title="0"> {
                dst = src
        }</span>
        <span class="cov0" title="0">return</span>
}

func defaultUnseal(src []byte, opts ...utils.OptionExtender) (ctx context.Context, dst any, ok bool, err error) <span class="cov0" title="0">{
        opt := utils.ApplyOptions[option](opts...)
        if opt.compressType.IsValid() </span><span class="cov0" title="0">{
                if src, err = encode.From(src).Decode(encode.Compress(opt.compressType)).ToBytes(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">if !opt.serializeType.IsValid() </span><span class="cov0" title="0">{
                // try to convert directly
                srcVal := reflect.ValueOf(src)
                if srcVal.CanConvert(opt.dataType) </span><span class="cov0" title="0">{
                        return nil, srcVal.Convert(opt.dataType).Interface(), false, nil
                }</span>

                // try to map the structure
                <span class="cov0" title="0">out := reflect.New(opt.dataType).Interface()
                if err = mapstructure.Decode(src, out); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">dst = reflect.ValueOf(out).Elem()
                return</span>
        }
        <span class="cov0" title="0">unmarshalFunc := serialize.UnmarshalFuncByType(opt.serializeType, opt.dataType, serialize.JsonEscapeHTML(false))
        dst, err = unmarshalFunc(src)
        return</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package lock

import (
        "context"
        "time"

        "go.uber.org/multierr"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/routine"
)

func Within(ctx context.Context, locker Lockable, key string,
        expired, timeout time.Duration, cb func() error, opts ...utils.OptionExtender) (err error) <span class="cov6" title="300">{
        const (
                reLockWaitTime = time.Duration(200) * time.Millisecond
        )
        opt := utils.ApplyOptions[useOption](opts...)
        reentrantKey := utils.UUID20()
        optionals := []utils.OptionExtender{ReentrantKey(reentrantKey)}
        if expired &gt; 0 </span><span class="cov6" title="300">{
                optionals = append(optionals, Expire(expired))
        }</span>

        <span class="cov6" title="300">done := make(chan struct{}, 1)
        timeFault := make(chan struct{}, 1)
        routine.Goc(ctx, func() </span><span class="cov6" title="299">{
                defer func() </span><span class="cov6" title="300">{ done &lt;- struct{}{} }</span>()

                <span class="cov6" title="299">var e error
                rLocker, ok := locker.(ReentrantLockable)
                for </span><span class="cov9" title="5225">{
                        select </span>{
                        case &lt;-timeFault:<span class="cov0" title="0"> // timeout exit
                                return</span>
                        default:<span class="cov10" title="5235">
                                if ok </span><span class="cov8" title="1759">{
                                        if e = rLocker.ReentrantLock(ctx, key, reentrantKey, optionals...); e == nil </span><span class="cov5" title="100">{
                                                return
                                        }</span>
                                } else<span class="cov9" title="3476"> {
                                        if e = locker.Lock(ctx, key, optionals...); e == nil </span><span class="cov6" title="200">{
                                                return
                                        }</span>
                                }

                                // relock after 200 milliseconds
                                <span class="cov9" title="4941">time.Sleep(reLockWaitTime)</span>
                        }
                }
        }, routine.AppName(opt.appName))

        <span class="cov6" title="297">timer := time.NewTimer(timeout)
        select </span>{
        // success
        case &lt;-done:<span class="cov6" title="300"></span>

        // context done
        case &lt;-ctx.Done():<span class="cov0" title="0">
                timeFault &lt;- struct{}{}
                return ErrContextDone</span>

        // timeout
        case &lt;-timer.C:<span class="cov0" title="0">
                timeFault &lt;- struct{}{}
                return ErrTimeout</span>
        }

        <span class="cov6" title="300">defer func() </span><span class="cov6" title="300">{ err = multierr.Append(err, locker.Unlock(ctx, key, optionals...)) }</span>()

        <span class="cov6" title="300">_, err = utils.Catch(cb)
        return</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package lock

import (
        "context"
        "sync"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/db"
        "github.com/wfusion/gofusion/redis"
)

var (
        appInstances map[string]map[string]Lockable
        rwlock       sync.RWMutex
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov5" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov2" title="5">{
                opt.AppName = optU.appName
        }</span>
        <span class="cov5" title="34">for name, conf := range confs </span><span class="cov4" title="15">{
                addInstance(ctx, name, conf, opt)
        }</span>

        <span class="cov5" title="34">return func() </span><span class="cov5" title="34">{
                rwlock.Lock()
                defer rwlock.Unlock()
                if appInstances != nil </span><span class="cov3" title="13">{
                        delete(appInstances, opt.AppName)
                }</span>
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov4" title="15">{
        rwlock.Lock()
        defer rwlock.Unlock()
        if appInstances == nil </span><span class="cov2" title="3">{
                appInstances = make(map[string]map[string]Lockable)
        }</span>
        <span class="cov4" title="15">if appInstances[opt.AppName] == nil </span><span class="cov3" title="11">{
                appInstances[opt.AppName] = make(map[string]Lockable)
        }</span>

        <span class="cov4" title="15">if _, ok := appInstances[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedName)</span>
        }

        <span class="cov4" title="15">switch conf.Type </span>{
        case lockTypeRedisLua:<span class="cov3" title="11">
                redis.Use(ctx, conf.Instance, redis.AppName(opt.AppName)) // check if instance exists
                appInstances[opt.AppName][name] = newRedisLuaLocker(ctx, opt.AppName, conf.Instance)</span>
        case lockTypeRedisNX:<span class="cov1" title="2">
                redis.Use(ctx, conf.Instance, redis.AppName(opt.AppName)) // check if instance exists
                appInstances[opt.AppName][name] = newRedisNXLocker(ctx, opt.AppName, conf.Instance)</span>
        case lockTypeMySQL:<span class="cov1" title="2">
                db.Use(ctx, conf.Instance, db.AppName(opt.AppName)) // check if instance exists
                appInstances[opt.AppName][name] = newMysqlLocker(ctx, opt.AppName, conf.Instance)</span>
        case lockTypeMariaDB:<span class="cov0" title="0">
                db.Use(ctx, conf.Instance, db.AppName(opt.AppName)) // check if instance exists
                appInstances[opt.AppName][name] = newMysqlLocker(ctx, opt.AppName, conf.Instance)</span>
        default:<span class="cov0" title="0">
                panic(ErrUnsupportedLockType)</span>
        }

        // ioc
        <span class="cov4" title="15">if opt.DI != nil </span><span class="cov4" title="15">{
                opt.DI.MustProvide(func() Lockable </span><span class="cov0" title="0">{ return Use(name, AppName(opt.AppName)) }</span>, di.Name(name))
                <span class="cov4" title="15">if _, ok := appInstances[opt.AppName][name].(ReentrantLockable); ok </span><span class="cov3" title="11">{
                        opt.DI.MustProvide(
                                func() ReentrantLockable </span><span class="cov0" title="0">{ return UseReentrant(ctx, name, AppName(opt.AppName)) }</span>,
                                di.Name(name),
                        )
                }
        }
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov10" title="2243">{
        return func(o *useOption) </span><span class="cov9" title="2152">{
                o.appName = name
        }</span>
}

func Use(name string, opts ...utils.OptionExtender) Lockable <span class="cov9" title="1935">{
        opt := utils.ApplyOptions[useOption](opts...)

        rwlock.RLock()
        defer rwlock.RUnlock()
        instances, ok := appInstances[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("locker instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov9" title="2000">instance, ok := instances[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("locker instance not found for name: %s", name))</span>
        }
        <span class="cov9" title="2004">return instance</span>
}

func UseReentrant(ctx context.Context, name string, opts ...utils.OptionExtender) ReentrantLockable <span class="cov0" title="0">{
        opt := utils.ApplyOptions[useOption](opts...)

        rwlock.RLock()
        defer rwlock.RUnlock()
        instances, ok := appInstances[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("reentrant locker instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov0" title="0">instance, ok := instances[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("reentrant locker instance not found for name: %s", name))</span>
        }
        <span class="cov0" title="0">lockable, ok := instance.(ReentrantLockable)
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("locker instance is not reentrantable: %s", name))</span>
        }

        <span class="cov0" title="0">return lockable</span>
}

func init() <span class="cov4" title="14">{
        config.AddComponent(config.ComponentLock, Construct)
}</span>
</pre>
		
		<pre class="file" id="file146" style="display: none">package lock

import (
        "context"
        "fmt"
        "math/rand"
        "sync"
        "time"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/db"
        "github.com/wfusion/gofusion/routine"
)

const (
        mysqlLockSQL   = "SELECT GET_LOCK(?, ?)"
        mysqlUnlockSQL = "DO RELEASE_LOCK(?)"
)

type mysqlLocker struct {
        ctx     context.Context
        dbName  string
        appName string

        locker     sync.RWMutex
        lockTimers map[string]struct{}
}

func newMysqlLocker(ctx context.Context, appName, dbName string) Lockable <span class="cov1" title="2">{
        return &amp;mysqlLocker{ctx: ctx, appName: appName, dbName: dbName, lockTimers: map[string]struct{}{}}
}</span>

func (m *mysqlLocker) Lock(ctx context.Context, key string, opts ...utils.OptionExtender) (err error) <span class="cov9" title="1987">{
        opt := utils.ApplyOptions[lockOption](opts...)
        expired := tolerance
        if opt.expired &gt; 0 </span><span class="cov9" title="1977">{
                expired = opt.expired
        }</span>
        <span class="cov9" title="1975">lockKey := m.formatLockKey(key)
        if len(lockKey) &gt; 64 </span><span class="cov0" title="0">{
                return errors.Errorf("key %s length is too long, max key length is 64", lockKey)
        }</span>

        <span class="cov9" title="1984">m.locker.Lock()
        defer m.locker.Unlock()
        // disable reentrant
        if _, ok := m.lockTimers[lockKey]; ok </span><span class="cov9" title="1893">{
                return ErrTimeout
        }</span>

        <span class="cov6" title="100">ret := db.Use(ctx, m.dbName, db.AppName(m.appName)).Raw(mysqlLockSQL, lockKey, 0)
        if err = ret.Error; err != nil </span><span class="cov0" title="0">{
                return ret.Error
        }</span>
        <span class="cov6" title="100">var result int64
        if err = ret.Scan(&amp;result).Error; err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="100">if result != 1 </span><span class="cov0" title="0">{
                return ErrTimeout
        }</span>

        // expire loop
        <span class="cov6" title="100">m.lockTimers[lockKey] = struct{}{}
        timer := time.NewTimer(expired)
        routine.Loop(
                func(ctx context.Context, lockKey string, timer *time.Timer) </span><span class="cov6" title="100">{
                        defer timer.Stop()
                        if !m.isLocked(ctx, lockKey) </span><span class="cov4" title="24">{
                                return
                        }</span>

                        <span class="cov6" title="76">for </span><span class="cov6" title="155">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        _ = m.Unlock(ctx, lockKey) // context done
                                        return</span>
                                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                                        _ = m.Unlock(ctx, lockKey) // context done
                                        return</span>
                                case &lt;-timer.C:<span class="cov0" title="0">
                                        _ = m.Unlock(ctx, lockKey) // timeout
                                        return</span>
                                default:<span class="cov6" title="155">
                                        if !m.isLocked(ctx, lockKey) </span><span class="cov6" title="76">{
                                                return
                                        }</span>
                                        <span class="cov6" title="79">time.Sleep(200*time.Millisecond + time.Duration(rand.Int63())%(100*time.Millisecond))</span>
                                }
                        }
                },
                routine.Args(ctx, lockKey, timer), routine.AppName(m.appName))
        <span class="cov6" title="100">return</span>
}

func (m *mysqlLocker) Unlock(ctx context.Context, key string, _ ...utils.OptionExtender) (err error) <span class="cov6" title="100">{
        lockKey := m.formatLockKey(key)
        if err = db.Use(ctx, m.dbName, db.AppName(m.appName)).Raw(mysqlUnlockSQL, lockKey).Error; err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="100">m.locker.Lock()
        defer m.locker.Unlock()
        delete(m.lockTimers, lockKey)

        return</span>
}

func (m *mysqlLocker) isLocked(ctx context.Context, lockKey string) (locked bool) <span class="cov7" title="255">{
        m.locker.RLock()
        defer m.locker.RUnlock()
        _, locked = m.lockTimers[lockKey]
        return
}</span>

func (m *mysqlLocker) formatLockKey(key string) string <span class="cov10" title="2075">{
        return fmt.Sprintf("%s:%s", config.Use(m.appName).AppName(), key)
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package lock

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/redis"

        rdsDrv "github.com/redis/go-redis/v9"
)

const (
        redisLuaLockCommand = `
if redis.call("GET", KEYS[1]) == ARGV[1] then
    redis.call("SET", KEYS[1], ARGV[1], "PX", ARGV[2])
    return "OK"
else
    return redis.call("SET", KEYS[1], ARGV[1], "NX", "PX", ARGV[2])
end`

        redisLuaUnlockCommand = `
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end`
)

type redisLuaLocker struct {
        ctx       context.Context
        appName   string
        redisName string
}

func newRedisLuaLocker(ctx context.Context, appName, redisName string) ReentrantLockable <span class="cov3" title="11">{
        return &amp;redisLuaLocker{ctx: ctx, appName: appName, redisName: redisName}
}</span>

func (r *redisLuaLocker) Lock(ctx context.Context, key string, opts ...utils.OptionExtender) (err error) <span class="cov9" title="1818">{
        opt := utils.ApplyOptions[lockOption](opts...)
        if utils.IsStrBlank(opt.reentrantKey) </span><span class="cov0" title="0">{
                return ErrReentrantKeyNotFound
        }</span>
        <span class="cov9" title="1822">expired := tolerance
        if opt.expired &gt; 0 </span><span class="cov9" title="1822">{
                expired = opt.expired
        }</span>
        <span class="cov9" title="1822">lockKey := r.formatLockKey(key)
        err = redis.
                Use(ctx, r.redisName, redis.AppName(r.appName)).
                Eval(ctx, redisLuaLockCommand, []string{lockKey}, []string{
                        opt.reentrantKey, strconv.Itoa(int(expired / time.Millisecond)),
                }).
                Err()
        if errors.Is(err, rdsDrv.Nil) </span><span class="cov9" title="1692">{
                err = ErrTimeout
        }</span>
        <span class="cov9" title="1829">return</span>
}

func (r *redisLuaLocker) Unlock(ctx context.Context, key string, opts ...utils.OptionExtender) (err error) <span class="cov6" title="130">{
        opt := utils.ApplyOptions[lockOption](opts...)
        if utils.IsStrBlank(opt.reentrantKey) </span><span class="cov0" title="0">{
                return ErrReentrantKeyNotFound
        }</span>
        <span class="cov6" title="130">lockKey := r.formatLockKey(key)
        return redis.
                Use(ctx, r.redisName, redis.AppName(r.appName)).
                Eval(ctx, redisLuaUnlockCommand, []string{lockKey}, []string{
                        opt.reentrantKey, strconv.Itoa(int(opt.expired / time.Millisecond)),
                }).
                Err()</span>
}

func (r *redisLuaLocker) ReentrantLock(ctx context.Context, key, reentrantKey string,
        opts ...utils.OptionExtender) (err error) <span class="cov9" title="1753">{
        return r.Lock(ctx, key, append(opts, ReentrantKey(reentrantKey))...)
}</span>

func (r *redisLuaLocker) formatLockKey(key string) (format string) <span class="cov10" title="1949">{
        return fmt.Sprintf("%s:%s", config.Use(r.appName).AppName(), key)
}</span>

type redisNXLocker struct {
        ctx       context.Context
        appName   string
        redisName string
}

func newRedisNXLocker(ctx context.Context, appName, redisName string) Lockable <span class="cov1" title="2">{
        return &amp;redisNXLocker{ctx: ctx, appName: appName, redisName: redisName}
}</span>

func (r *redisNXLocker) Lock(ctx context.Context, key string, opts ...utils.OptionExtender) (err error) <span class="cov9" title="1481">{
        opt := utils.ApplyOptions[lockOption](opts...)
        expired := tolerance
        if opt.expired &gt; 0 </span><span class="cov9" title="1470">{
                expired = opt.expired
        }</span>
        <span class="cov9" title="1470">lockKey := r.formatLockKey(key)
        cmd := redis.Use(ctx, r.redisName, redis.AppName(r.appName)).SetNX(ctx, lockKey, utils.UUID(), expired)
        if err = cmd.Err(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="1484">if !cmd.Val() </span><span class="cov9" title="1384">{
                err = ErrTimeout
                return
        }</span>
        <span class="cov6" title="100">return</span>
}

func (r *redisNXLocker) Unlock(ctx context.Context, key string, _ ...utils.OptionExtender) (err error) <span class="cov6" title="100">{
        lockKey := r.formatLockKey(key)
        return redis.Use(ctx, r.redisName, redis.AppName(r.appName)).Del(ctx, lockKey).Err()
}</span>

func (r *redisNXLocker) formatLockKey(key string) (format string) <span class="cov9" title="1570">{
        return fmt.Sprintf("%s:%s", config.Use(r.appName).AppName(), key)
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">package lock

import (
        "context"
        "time"

        "github.com/wfusion/gofusion/common/utils"
)

const (
        ErrDuplicatedName       utils.Error = "duplicated lock name"
        ErrUnsupportedLockType  utils.Error = "unsupported lock type"
        ErrReentrantKeyNotFound utils.Error = "reentrant key for lock not found"
        ErrTimeout              utils.Error = "try to lock timeout"
        ErrContextDone          utils.Error = "try to lock when context done"

        // tolerance Default timeout to prevent deadlock
        tolerance = 2000 * time.Millisecond
)

type Lockable interface {
        Lock(ctx context.Context, key string, opts ...utils.OptionExtender) (err error)
        Unlock(ctx context.Context, key string, opts ...utils.OptionExtender) (err error)
}

type ReentrantLockable interface {
        Lockable
        ReentrantLock(ctx context.Context, key, reentrantKey string, opts ...utils.OptionExtender) (err error)
}

type lockType string

const (
        lockTypeRedisLua lockType = "redis_lua"
        lockTypeRedisNX  lockType = "redis_nx" // not support ReentrantKey
        lockTypeMySQL    lockType = "mysql"    // MariaDB versions &gt;= 10.0.2 MySQL versions &gt;= 5.7.5
        lockTypeMariaDB  lockType = "mariadb"  // MariaDB versions &gt;= 10.0.2 MySQL versions &gt;= 5.7.5
)

// Conf lock configure
type Conf struct {
        Type     lockType `yaml:"type" json:"type" toml:"type"`
        Instance string   `yaml:"instance" json:"instance" toml:"instance"`
}

type lockOption struct {
        expired      time.Duration // expired After locking, the timeout of the lock
        reentrantKey string        // reentrantKey Reentrant mark
}

func Expire(expired time.Duration) utils.OptionFunc[lockOption] <span class="cov6" title="369">{
        return func(l *lockOption) </span><span class="cov9" title="5360">{
                l.expired = expired
        }</span>
}

func ReentrantKey(key string) utils.OptionFunc[lockOption] <span class="cov8" title="2152">{
        return func(l *lockOption) </span><span class="cov10" title="7122">{
                l.reentrantKey = key
        }</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package log

import (
        "context"
        "time"

        "go.uber.org/zap"

        "github.com/wfusion/gofusion/common/utils"

        fmkCtx "github.com/wfusion/gofusion/context"
)

func Debug(ctx context.Context, format string, args ...any) <span class="cov0" title="0">{ globalLogger.Debug(ctx, format, args...) }</span>
func Info(ctx context.Context, format string, args ...any)  <span class="cov10" title="1524">{ globalLogger.Info(ctx, format, args...) }</span>
func Warn(ctx context.Context, format string, args ...any)  <span class="cov0" title="0">{ globalLogger.Warn(ctx, format, args...) }</span>
func Error(ctx context.Context, format string, args ...any) <span class="cov0" title="0">{ globalLogger.Error(ctx, format, args...) }</span>
func Panic(ctx context.Context, format string, args ...any) <span class="cov0" title="0">{ globalLogger.Panic(ctx, format, args...) }</span>
func Fatal(ctx context.Context, format string, args ...any) <span class="cov0" title="0">{ globalLogger.Fatal(ctx, format, args...) }</span>

func TimeElapsed(ctx context.Context, logger Logable, fn func(), format string, args ...any) <span class="cov0" title="0">{
        now := time.Now()
        defer func() </span><span class="cov0" title="0">{
                elapsed := time.Since(now).Milliseconds()
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        panic(r)</span>
                }
                <span class="cov0" title="0">if logger != nil </span><span class="cov0" title="0">{
                        logger.Info(ctx, format, append(args, zap.Any("latency", elapsed))...)
                }</span> else<span class="cov0" title="0"> {
                        Info(ctx, format, append(args, zap.Any("latency", elapsed))...)
                }</span>
        }()

        <span class="cov0" title="0">fn()</span>
}

func GetContextFields(ctx context.Context) Fields <span class="cov0" title="0">{
        return utils.GetCtxAny(ctx, fmkCtx.KeyLogFields, (Fields)(nil))
}</span>

func SetContextFields(ctx context.Context, fields Fields) context.Context <span class="cov6" title="80">{
        return utils.SetCtxAny(ctx, fmkCtx.KeyLogFields, fields)
}</span>
</pre>
		
		<pre class="file" id="file150" style="display: none">package log

import (
        "context"
        "crypto/md5"
        "os"
        "path"
        "path/filepath"
        "time"

        "github.com/dustin/go-humanize"
        "github.com/pkg/errors"
        "github.com/spf13/cast"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/env"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov10" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov5" title="5">{
                opt.AppName = optU.appName
        }</span>
        <span class="cov10" title="34">for name, conf := range confs </span><span class="cov9" title="32">{
                addInstance(ctx, name, conf, opt)
        }</span>

        <span class="cov10" title="34">if opt.AppName == "" &amp;&amp; appInstances[opt.AppName] != nil </span><span class="cov4" title="4">{
                if conf, ok := appInstances[opt.AppName][config.DefaultInstanceKey]; !ok || conf == nil </span><span class="cov0" title="0">{
                        panic(ErrDefaultLoggerNotFound)</span>
                }
        }

        <span class="cov10" title="34">return func() </span><span class="cov10" title="34">{
                rwlock.Lock()
                defer rwlock.Unlock()
                if appInstances != nil </span><span class="cov10" title="34">{
                        for _, instance := range appInstances[opt.AppName] </span><span class="cov9" title="32">{
                                instance.flush()
                        }</span>
                        <span class="cov10" title="34">delete(appInstances, opt.AppName)</span>
                }

                // there maybe some locally logging, avoid some NPE crash as possible as we can do
                <span class="cov10" title="34">colorful := false
                if opt.AppName == "" </span><span class="cov5" title="5">{
                        if confs != nil &amp;&amp; confs[config.DefaultInstanceKey] != nil </span><span class="cov4" title="4">{
                                colorful = confs[config.DefaultInstanceKey].ConsoleOutputOption.Colorful
                        }</span>
                        <span class="cov5" title="5">globalLogger = defaultLogger(colorful)</span>
                }
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov9" title="32">{
        logLevel := getLogLevel(conf.LogLevel)

        if !conf.EnableFileOutput &amp;&amp; !conf.EnableConsoleOutput </span><span class="cov0" title="0">{
                panic(ErrUnknownOutput)</span>
        }

        <span class="cov9" title="32">var cores []zapcore.Core
        if conf.EnableConsoleOutput </span><span class="cov9" title="32">{
                cfg := getEncoderConfig(conf)
                if conf.ConsoleOutputOption.Colorful </span><span class="cov0" title="0">{
                        cfg.EncodeLevel = zapcore.CapitalColorLevelEncoder
                }</span>
                <span class="cov9" title="32">encoder := getEncoder(conf.ConsoleOutputOption.Layout, cfg)
                writer := zapcore.Lock(os.Stdout)
                cores = append(cores, zapcore.NewCore(encoder, writer, logLevel))</span>
        }
        <span class="cov9" title="32">if conf.EnableFileOutput </span><span class="cov1" title="1">{
                var (
                        ext     = ".log"
                        logName string
                )

                cfg := getEncoderConfig(conf)
                encoder := getEncoder(conf.FileOutputOption.Layout, cfg)
                utils.IfAny(
                        func() bool </span><span class="cov1" title="1">{ logName = conf.FileOutputOption.Name; return utils.IsStrNotBlank(logName) }</span>,
                        func() bool <span class="cov1" title="1">{ logName = config.Use(opt.AppName).AppName() + ext; return utils.IsStrNotBlank(logName) }</span>,
                        func() bool <span class="cov0" title="0">{ logName = filepath.Base(env.WorkDir) + ext; return logName != "/.log" }</span>,
                        func() bool <span class="cov0" title="0">{
                                sum := md5.Sum([]byte(env.WorkDir))
                                logName = string(sum[:]) + ext
                                return true
                        }</span>,
                )

                <span class="cov1" title="1">rotationSize := cast.ToInt64(conf.FileOutputOption.RotationSize) * int64(humanize.MByte)
                if rotationSize == 0 </span><span class="cov1" title="1">{
                        u, err := humanize.ParseBytes(conf.FileOutputOption.RotationSize)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(errors.Errorf("log component parse ratation size %s failed for name %s: %s",
                                        conf.FileOutputOption.RotationSize, name, err))</span>
                        }
                        <span class="cov1" title="1">rotationSize = int64(u)</span>
                }

                <span class="cov1" title="1">maxAge := time.Duration(cast.ToInt(conf.FileOutputOption.RotationTime)) * time.Hour
                if maxAge == 0 </span><span class="cov1" title="1">{
                        d, err := time.ParseDuration(conf.FileOutputOption.RotationTime)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(errors.Errorf("log component parse ratation time %s failed for name %s: %s",
                                        conf.FileOutputOption.RotationTime, name, err))</span>
                        }
                        <span class="cov1" title="1">maxAge = d</span>
                }

                <span class="cov1" title="1">writer := zapcore.AddSync(&amp;lumberjack.Logger{
                        Filename:   path.Join(conf.FileOutputOption.Path, logName),
                        MaxSize:    int(rotationSize / int64(humanize.MByte)),
                        MaxBackups: conf.FileOutputOption.RotationCount,
                        MaxAge:     int(maxAge) / int(24*time.Hour),
                        Compress:   conf.FileOutputOption.Compress,
                })
                cores = append(cores, zapcore.NewCore(encoder, writer, logLevel))</span>
        }

        <span class="cov9" title="32">zapLogger := zap.
                New(
                        zapcore.NewTee(cores...),
                        zap.AddStacktrace(getLogLevel(conf.StacktraceLevel)),
                        zap.AddCaller(),
                        zap.Hooks(),
                ).
                Named(config.Use(opt.AppName).AppName())

        fmkLogger := &amp;logger{name: name, logger: zapLogger, sugaredLogger: zapLogger.Sugar()}

        rwlock.Lock()
        defer rwlock.Unlock()
        if appInstances == nil </span><span class="cov7" title="12">{
                appInstances = make(map[string]map[string]*logger)
        }</span>
        <span class="cov9" title="32">if appInstances[opt.AppName] == nil </span><span class="cov9" title="32">{
                appInstances[opt.AppName] = make(map[string]*logger)
        }</span>
        <span class="cov9" title="32">if _, ok := appInstances[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedName)</span>
        }
        <span class="cov9" title="32">appInstances[opt.AppName][name] = fmkLogger

        if name == config.DefaultInstanceKey </span><span class="cov9" title="32">{
                globalLogger = fmkLogger
        }</span>

        // ioc
        <span class="cov9" title="32">if opt.DI != nil </span><span class="cov9" title="32">{
                opt.DI.MustProvide(
                        func() Logable </span><span class="cov0" title="0">{ return Use(name, AppName(opt.AppName)) }</span>,
                        di.Name(name),
                )
        }
}

func init() <span class="cov7" title="14">{
        config.AddComponent(config.ComponentLog, Construct)
}</span>
</pre>
		
		<pre class="file" id="file151" style="display: none">package customlogger

import (
        "context"
        "reflect"
        "strings"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/infra/asynq"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

var (
        // AsyncLoggerType FIXME: should not be deleted to avoid compiler optimized
        AsyncLoggerType = reflect.TypeOf(asyncLogger{})
)

func DefaultAsyncLogger() interface{ Printf(string, ...any) } <span class="cov0" title="0">{
        return &amp;asyncLogger{}
}</span>

func DefaultAsynqAsyncLogger() asynq.Logger <span class="cov0" title="0">{
        return &amp;asyncLogger{}
}</span>

type asyncLogger struct {
        log      log.Logable
        appName  string
        confName string
        enabled  bool
}

func (a *asyncLogger) Init(log log.Logable, appName, confName string) <span class="cov7" title="11">{
        a.log = log
        a.appName = appName
        a.confName = confName
        a.reloadConfig()
}</span>

func (a *asyncLogger) Printf(format string, args ...any) <span class="cov0" title="0">{
        ctx := context.Background()
        a.log.Info(ctx, format, args...)
}</span>

// Debug logs a message at Debug level.
func (a *asyncLogger) Debug(args ...any) <span class="cov0" title="0">{
        if !a.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := a.parseArgs(args...)
        if a.log != nil </span><span class="cov0" title="0">{
                a.log.Debug(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Debug(ctx, format, args...)
        }</span>
}

// Info logs a message at Info level.
func (a *asyncLogger) Info(args ...any) <span class="cov8" title="12">{
        if !a.isLoggable() </span><span class="cov8" title="12">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := a.parseArgs(args...)
        if a.log != nil </span><span class="cov0" title="0">{
                a.log.Info(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Info(ctx, format, args...)
        }</span>
}

// Warn logs a message at Warning level.
func (a *asyncLogger) Warn(args ...any) <span class="cov0" title="0">{
        if !a.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := a.parseArgs(args...)
        if a.log != nil </span><span class="cov0" title="0">{
                a.log.Warn(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Warn(ctx, format, args...)
        }</span>
}

// Error logs a message at Error level.
func (a *asyncLogger) Error(args ...any) <span class="cov0" title="0">{
        if !a.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := a.parseArgs(args...)
        if a.log != nil </span><span class="cov0" title="0">{
                a.log.Error(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Error(ctx, format, args...)
        }</span>
}

// Fatal logs a message at Fatal level
// and process will exit with status set to 1.
func (a *asyncLogger) Fatal(args ...any) <span class="cov0" title="0">{
        if !a.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := a.parseArgs(args...)
        if a.log != nil </span><span class="cov0" title="0">{
                a.log.Fatal(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Fatal(ctx, format, args...)
        }</span>
}

// parseArgs support (ctx, format, args...) log format
func (a *asyncLogger) parseArgs(args ...any) (ctx context.Context, format string, params []any) <span class="cov0" title="0">{
        var ok bool

        if len(args) == 0 </span><span class="cov0" title="0">{
                return context.Background(), "", nil
        }</span>
        <span class="cov0" title="0">if len(args) == 1 </span><span class="cov0" title="0">{
                return context.Background(), "%+v", args
        }</span>

        <span class="cov0" title="0">format, ok = args[0].(string)
        if ok </span><span class="cov0" title="0">{
                params = args[1:]
        }</span> else<span class="cov0" title="0"> {
                ctx, _ = args[0].(context.Context)
                format, _ = args[1].(string)
                params = args[2:]
        }</span>
        <span class="cov0" title="0">if format == "" </span><span class="cov0" title="0">{
                placeholder := make([]string, len(args))
                for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        placeholder[i] = "%+v"
                }</span>
                <span class="cov0" title="0">format = strings.Join(placeholder, " ")
                params = args</span>
        }

        <span class="cov0" title="0">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">return</span>
}

func (a *asyncLogger) isLoggable() bool <span class="cov8" title="12">{ a.reloadConfig(); return a.enabled }</span>

func (a *asyncLogger) reloadConfig() <span class="cov10" title="23">{
        var cfgs map[string]map[string]any
        _ = config.Use(a.appName).LoadComponentConfig(config.ComponentAsync, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="23">cfg, ok := cfgs[a.confName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="23">enabled := cast.ToBool(cfg["enable_logger"])
        a.enabled = enabled</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">package customlogger

import (
        "context"
        "reflect"
        "strings"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/infra/asynq"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

var (
        // CronLoggerType FIXME: should not be deleted to avoid compiler optimized
        CronLoggerType = reflect.TypeOf(cronLogger{})
)

func DefaultCronLogger() interface{ Printf(string, ...any) } <span class="cov0" title="0">{
        return &amp;cronLogger{}
}</span>

func DefaultAsynqCronLogger() asynq.Logger <span class="cov0" title="0">{
        return &amp;cronLogger{}
}</span>

type cronLogger struct {
        log      log.Logable
        appName  string
        confName string
        enabled  bool
}

func (c *cronLogger) Init(log log.Logable, appName, name string) <span class="cov5" title="13">{
        c.log = log
        c.appName = appName
        c.confName = name
        c.reloadConfig()
}</span>

func (c *cronLogger) Printf(format string, args ...any) <span class="cov0" title="0">{
        c.log.Info(context.Background(), format, args...)
}</span>

// Debug logs a message at Debug level.
func (c *cronLogger) Debug(args ...any) <span class="cov7" title="42">{
        if !c.isLoggable() </span><span class="cov7" title="42">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := c.parseArgs(args...)
        if c.log != nil </span><span class="cov0" title="0">{
                c.log.Debug(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Debug(ctx, format, args...)
        }</span>
}

// Info logs a message at Info level.
func (c *cronLogger) Info(args ...any) <span class="cov8" title="78">{
        if !c.isLoggable() </span><span class="cov8" title="78">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := c.parseArgs(args...)
        if c.log != nil </span><span class="cov0" title="0">{
                c.log.Info(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Info(ctx, format, args...)
        }</span>
}

// Warn logs a message at Warning level.
func (c *cronLogger) Warn(args ...any) <span class="cov6" title="22">{
        if !c.isLoggable() </span><span class="cov6" title="22">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := c.parseArgs(args...)
        if c.log != nil </span><span class="cov0" title="0">{
                c.log.Warn(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Warn(ctx, format, args...)
        }</span>
}

// Error logs a message at Error level.
func (c *cronLogger) Error(args ...any) <span class="cov1" title="1">{
        if !c.isLoggable() </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := c.parseArgs(args...)
        if c.log != nil </span><span class="cov0" title="0">{
                c.log.Error(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Error(ctx, format, args...)
        }</span>
}

// Fatal logs a message at Fatal level
// and process will exit with status set to 1.
func (c *cronLogger) Fatal(args ...any) <span class="cov0" title="0">{
        if !c.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := c.parseArgs(args...)
        if c.log != nil </span><span class="cov0" title="0">{
                c.log.Fatal(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Fatal(ctx, format, args...)
        }</span>
}

// parseArgs support (ctx, format, args...) log format
func (c *cronLogger) parseArgs(args ...any) (ctx context.Context, format string, params []any) <span class="cov0" title="0">{
        var ok bool

        if len(args) == 0 </span><span class="cov0" title="0">{
                return context.Background(), "", nil
        }</span>
        <span class="cov0" title="0">if len(args) == 1 </span><span class="cov0" title="0">{
                return context.Background(), "%+v", args
        }</span>

        <span class="cov0" title="0">format, ok = args[0].(string)
        if ok </span><span class="cov0" title="0">{
                params = args[1:]
        }</span> else<span class="cov0" title="0"> {
                ctx, _ = args[0].(context.Context)
                format, _ = args[1].(string)
                params = args[2:]
        }</span>
        <span class="cov0" title="0">if format == "" </span><span class="cov0" title="0">{
                placeholder := make([]string, len(args))
                for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        placeholder[i] = "%+v"
                }</span>
                <span class="cov0" title="0">format = strings.Join(placeholder, " ")
                params = args</span>
        }

        <span class="cov0" title="0">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">return</span>
}

func (c *cronLogger) isLoggable() bool <span class="cov9" title="141">{ c.reloadConfig(); return c.enabled }</span>

func (c *cronLogger) reloadConfig() <span class="cov9" title="154">{
        var cfgs map[string]map[string]any
        _ = config.Use(c.appName).LoadComponentConfig(config.ComponentCron, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="156">cfg, ok := cfgs[c.confName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="155">enabled := cast.ToBool(cfg["enable_logger"])
        c.enabled = enabled</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package customlogger

import (
        "context"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/pkg/errors"
        "github.com/spf13/cast"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

var (
        // GormLoggerType FIXME: should not be deleted to avoid compiler optimized
        GormLoggerType = reflect.TypeOf(gormLogger{})
)

func DefaultMySQLLogger() logger.Interface <span class="cov0" title="0">{
        return &amp;gormLogger{
                enabled:                   true,
                slowThreshold:             200 * time.Millisecond,
                logLevel:                  logger.Silent,
                ignoreRecordNotFoundError: true,
        }
}</span>

type gormLogger struct {
        log                       log.Logable
        appName                   string
        confName                  string
        enabled                   bool
        logLevel                  logger.LogLevel
        slowThreshold             time.Duration
        ignoreRecordNotFoundError bool
}

// LogMode log mode
func (g *gormLogger) LogMode(level logger.LogLevel) logger.Interface <span class="cov0" title="0">{
        g.logLevel = level
        return g
}</span>

// Info print info
func (g *gormLogger) Info(ctx context.Context, msg string, data ...any) <span class="cov5" title="110">{
        g.reloadConfig()
        if !g.enabled </span><span class="cov3" title="14">{
                return
        }</span>
        <span class="cov5" title="96">if g.logLevel &gt;= logger.Info </span><span class="cov5" title="96">{
                if g.log != nil </span><span class="cov5" title="96">{
                        g.log.Info(ctx, msg, data...)
                }</span> else<span class="cov0" title="0"> {
                        log.Info(ctx, msg, data...)
                }</span>
        }
}

// Warn print warn messages
func (g *gormLogger) Warn(ctx context.Context, msg string, data ...any) <span class="cov0" title="0">{
        g.reloadConfig()
        if !g.enabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if g.logLevel &gt;= logger.Warn </span><span class="cov0" title="0">{
                if g.log != nil </span><span class="cov0" title="0">{
                        g.log.Warn(ctx, msg, data...)
                }</span> else<span class="cov0" title="0"> {
                        log.Warn(ctx, msg, data...)
                }</span>
        }
}

// Error print error messages
func (g *gormLogger) Error(ctx context.Context, msg string, data ...any) <span class="cov0" title="0">{
        g.reloadConfig()
        if !g.enabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if g.logLevel &gt;= logger.Error </span><span class="cov0" title="0">{
                if g.log != nil </span><span class="cov0" title="0">{
                        g.log.Error(ctx, msg, data...)
                }</span> else<span class="cov0" title="0"> {
                        log.Error(ctx, msg, data...)
                }</span>
        }
}

// Trace print sql message
func (g *gormLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) <span class="cov9" title="7573">{
        g.reloadConfig()
        if !g.enabled </span><span class="cov5" title="104">{
                return
        }</span>
        <span class="cov9" title="7466">if g.logLevel &lt;= logger.Silent </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="7466">elapsed := time.Since(begin)
        switch </span>{
        case err != nil &amp;&amp; g.logLevel &gt;= logger.Error &amp;&amp;
                (!errors.Is(err, gorm.ErrRecordNotFound) || !g.ignoreRecordNotFoundError):<span class="cov0" title="0">
                sql, rows := fc()
                sql = fmt.Sprintf("err[%%s] %s", g.format(sql))
                if rows == -1 </span><span class="cov0" title="0">{
                        if g.log != nil </span><span class="cov0" title="0">{
                                g.log.Info(ctx, sql, err.Error(), log.Fields{"latency": elapsed.Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Info(ctx, sql, err.Error(), log.Fields{"latency": elapsed.Milliseconds()})
                        }</span>
                } else<span class="cov0" title="0"> {
                        if g.log != nil </span><span class="cov0" title="0">{
                                g.log.Info(ctx, sql, err.Error(), log.Fields{"rows": rows, "latency": elapsed.Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Info(ctx, sql, err.Error(), log.Fields{"rows": rows, "latency": elapsed.Milliseconds()})
                        }</span>
                }
        case elapsed &gt; g.slowThreshold &amp;&amp; g.slowThreshold != 0 &amp;&amp; g.logLevel &gt;= logger.Warn:<span class="cov4" title="26">
                sql, rows := fc()
                slowLog := fmt.Sprintf("SLOW SQL &gt;= %v %s", g.slowThreshold, g.format(sql))
                if rows == -1 </span><span class="cov0" title="0">{
                        if g.log != nil </span><span class="cov0" title="0">{
                                g.log.Info(ctx, slowLog, log.Fields{"latency": elapsed.Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Info(ctx, slowLog, log.Fields{"latency": elapsed.Milliseconds()})
                        }</span>
                } else<span class="cov4" title="25"> {
                        if g.log != nil </span><span class="cov4" title="25">{
                                g.log.Info(ctx, slowLog, log.Fields{"rows": rows, "latency": elapsed.Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Info(ctx, slowLog, log.Fields{"rows": rows, "latency": elapsed.Milliseconds()})
                        }</span>
                }
        case g.logLevel == logger.Info:<span class="cov9" title="7441">
                sql, rows := fc()
                sql = g.format(sql)
                if rows == -1 </span><span class="cov7" title="1050">{
                        if g.log != nil </span><span class="cov7" title="1050">{
                                g.log.Info(ctx, sql, log.Fields{"latency": elapsed.Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Info(ctx, sql, log.Fields{"latency": elapsed.Milliseconds()})
                        }</span>
                } else<span class="cov9" title="6391"> {
                        if g.log != nil </span><span class="cov9" title="6390">{
                                g.log.Info(ctx, sql, log.Fields{"rows": rows, "latency": elapsed.Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Info(ctx, sql, log.Fields{"rows": rows, "latency": elapsed.Milliseconds()})
                        }</span>
                }
        }
}

func (g *gormLogger) Init(log log.Logable, appName, name string) <span class="cov5" title="55">{
        g.log = log
        g.appName = appName
        g.confName = name
        g.ignoreRecordNotFoundError = true
        g.reloadConfig()
}</span>

func (g *gormLogger) format(sql string) string <span class="cov9" title="7466">{
        return strings.ReplaceAll(sql, "%", "%%")
}</span>

func (g *gormLogger) getLogLevel(level string) logger.LogLevel <span class="cov9" title="7738">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov0" title="0">
                return logger.Info</span>
        case "info":<span class="cov9" title="7738">
                return logger.Info</span>
        case "warn":<span class="cov0" title="0">
                return logger.Warn</span>
        case "error":<span class="cov0" title="0">
                return logger.Error</span>
        default:<span class="cov0" title="0">
                return g.logLevel</span>
        }
}

func (g *gormLogger) reloadConfig() <span class="cov10" title="7739">{
        var cfgs map[string]map[string]any
        _ = config.Use(g.appName).LoadComponentConfig(config.ComponentDB, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="7739">cfg, ok := cfgs[g.confName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="7739">g.enabled = cast.ToBool(cfg["enable_logger"])
        logConfigObj, ok1 := cfg["logger_config"]
        logCfg, ok2 := logConfigObj.(map[string]any)
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="7737">g.logLevel = g.getLogLevel(cast.ToString(logCfg["log_level"]))
        g.slowThreshold, _ = time.ParseDuration(cast.ToString(logCfg["slow_threshold"]))</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">package customlogger

import (
        "context"
        "reflect"
        "strings"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/infra/metrics"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

var (
        // MetricsLoggerType FIXME: should not be deleted to avoid compiler optimized
        MetricsLoggerType = reflect.TypeOf(metricsLogger{})
)

func DefaultMetricsLogger() metrics.Logger <span class="cov0" title="0">{
        return &amp;metricsLogger{}
}</span>

type metricsLogger struct {
        log      log.Logable
        appName  string
        confName string
        enabled  bool
}

func (m *metricsLogger) Init(log log.Logable, appName, name string) <span class="cov7" title="23">{
        m.log = log
        m.appName = appName
        m.confName = name
        m.reloadConfig()
}</span>

func (m *metricsLogger) Printf(format string, args ...any) <span class="cov0" title="0">{
        m.log.Info(context.Background(), format, args...)
}</span>

// Debug logs a message at Debug level.
func (m *metricsLogger) Debug(args ...any) <span class="cov0" title="0">{
        if !m.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := m.parseArgs(args...)
        if m.log != nil </span><span class="cov0" title="0">{
                m.log.Debug(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Debug(ctx, format, args...)
        }</span>
}

// Info logs a message at Info level.
func (m *metricsLogger) Info(args ...any) <span class="cov6" title="12">{
        if !m.isLoggable() </span><span class="cov3" title="4">{
                return
        }</span>
        <span class="cov5" title="8">ctx, format, args := m.parseArgs(args...)
        if m.log != nil </span><span class="cov5" title="8">{
                m.log.Info(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Info(ctx, format, args...)
        }</span>
}

// Warn logs a message at Warning level.
func (m *metricsLogger) Warn(args ...any) <span class="cov8" title="31">{
        if !m.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="31">ctx, format, args := m.parseArgs(args...)
        if m.log != nil </span><span class="cov8" title="31">{
                m.log.Warn(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Warn(ctx, format, args...)
        }</span>
}

// Error logs a message at Error level.
func (m *metricsLogger) Error(args ...any) <span class="cov0" title="0">{
        if !m.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := m.parseArgs(args...)
        if m.log != nil </span><span class="cov0" title="0">{
                m.log.Error(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Error(ctx, format, args...)
        }</span>
}

// Fatal logs a message at Fatal level
// and process will exit with status set to 1.
func (m *metricsLogger) Fatal(args ...any) <span class="cov0" title="0">{
        if !m.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, format, args := m.parseArgs(args...)
        if m.log != nil </span><span class="cov0" title="0">{
                m.log.Fatal(ctx, format, args...)
        }</span> else<span class="cov0" title="0"> {
                log.Fatal(ctx, format, args...)
        }</span>
}

// parseArgs support (ctx, format, args...) log format
func (m *metricsLogger) parseArgs(args ...any) (ctx context.Context, format string, params []any) <span class="cov8" title="39">{
        var ok bool

        if len(args) == 0 </span><span class="cov0" title="0">{
                return context.Background(), "", nil
        }</span>
        <span class="cov8" title="39">if len(args) == 1 </span><span class="cov0" title="0">{
                return context.Background(), "%+v", args
        }</span>

        <span class="cov8" title="39">format, ok = args[0].(string)
        if ok </span><span class="cov0" title="0">{
                params = args[1:]
        }</span> else<span class="cov8" title="39"> {
                ctx, _ = args[0].(context.Context)
                format, _ = args[1].(string)
                params = args[2:]
        }</span>
        <span class="cov8" title="39">if format == "" </span><span class="cov0" title="0">{
                placeholder := make([]string, len(args))
                for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        placeholder[i] = "%+v"
                }</span>
                <span class="cov0" title="0">format = strings.Join(placeholder, " ")
                params = args</span>
        }

        <span class="cov8" title="39">if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov8" title="39">return</span>
}

func (m *metricsLogger) isLoggable() bool <span class="cov9" title="43">{ m.reloadConfig(); return m.enabled }</span>

func (m *metricsLogger) reloadConfig() <span class="cov10" title="66">{
        var cfgs map[string]map[string]any
        _ = config.Use(m.appName).LoadComponentConfig(config.ComponentMetrics, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov8" title="31">{
                return
        }</span>

        <span class="cov8" title="35">cfg, ok := cfgs[m.confName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="35">enabled := cast.ToBool(cfg["enable_logger"])
        m.enabled = enabled</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package customlogger

import (
        "context"
        "reflect"
        "sync"
        "time"

        "github.com/spf13/cast"
        "go.mongodb.org/mongo-driver/event"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

var (
        // MongoLoggerType FIXME: should not be deleted to avoid compiler optimized
        MongoLoggerType = reflect.TypeOf(mongoLogger{})
)

type mongoLogger struct {
        *event.CommandMonitor

        log               log.Logable
        enabled           bool
        appName           string
        confName          string
        logableCommandSet *utils.Set[string]

        mutex sync.RWMutex
        // requestMap The key is the monotonically atomic incrementing RequestID from the Mongo command event,
        // used to associate the command with the duration and only print one line of log.
        requestMap map[int64]struct {
                commandString string
        }
}

func DefaultMongoLogger() (logger *mongoLogger) <span class="cov0" title="0">{
        logger = &amp;mongoLogger{
                enabled:    true,
                requestMap: map[int64]struct{ commandString string }{},
                logableCommandSet: utils.NewSet[string](
                        "ping",
                        "insert",
                        "find",
                        "update",
                        "delete",
                        "aggregate",
                        "distinct",
                        "count",
                        "findAndModify",
                        "getMore",
                        "killCursors",
                        "create",
                        "drop",
                        "listDatabases",
                        "dropDatabase",
                        "createIndexes",
                        "listIndexes",
                        "dropIndexes",
                        "listCollections",
                ),
        }
        logger.CommandMonitor = &amp;event.CommandMonitor{
                Started:   logger.started,
                Succeeded: logger.succeeded,
                Failed:    logger.failed,
        }
        return
}</span>

func (m *mongoLogger) Init(log log.Logable, appName, name string) <span class="cov6" title="10">{
        m.log = log
        m.appName = appName
        m.confName = name
}</span>

func (m *mongoLogger) GetMonitor() *event.CommandMonitor <span class="cov6" title="10">{
        return &amp;event.CommandMonitor{
                Started:   m.started,
                Succeeded: m.succeeded,
                Failed:    m.failed,
        }
}</span>

func (m *mongoLogger) started(ctx context.Context, evt *event.CommandStartedEvent) <span class="cov8" title="23">{
        if !m.isLoggableCommandName(evt.CommandName) </span><span class="cov8" title="23">{
                return
        }</span>
        <span class="cov0" title="0">m.pushCommandString(evt.RequestID, evt.Command.String())</span>
}

func (m *mongoLogger) succeeded(ctx context.Context, evt *event.CommandSucceededEvent) <span class="cov8" title="23">{
        if !m.isLoggableCommandName(evt.CommandName) </span><span class="cov8" title="23">{
                return
        }</span>
        <span class="cov0" title="0">if m.log != nil </span><span class="cov0" title="0">{
                m.log.Info(ctx, "[mongodb] %s succeeded [request[%v] command[%s]]",
                        evt.CommandName, evt.RequestID, m.popCommandString(evt.RequestID),
                        log.Fields{"latency": int64(evt.Duration) / int64(time.Millisecond)})
        }</span> else<span class="cov0" title="0"> {
                log.Info(ctx, "[mongodb] %s succeeded [request[%v] command[%s]]",
                        evt.CommandName, evt.RequestID, m.popCommandString(evt.RequestID),
                        log.Fields{"latency": int64(evt.Duration) / int64(time.Millisecond)})
        }</span>
}

func (m *mongoLogger) failed(ctx context.Context, evt *event.CommandFailedEvent) <span class="cov0" title="0">{
        if !m.isLoggableCommandName(evt.CommandName) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if m.log != nil </span><span class="cov0" title="0">{
                m.log.Warn(ctx, "[mongodb] %s failed [request[%v] command[%s]]",
                        evt.CommandName, evt.RequestID, m.popCommandString(evt.RequestID),
                        log.Fields{"latency": int64(evt.Duration) / int64(time.Millisecond)})
        }</span> else<span class="cov0" title="0"> {
                log.Warn(ctx, "[mongodb] %s failed [request[%v] command[%s]]",
                        evt.CommandName, evt.RequestID, m.popCommandString(evt.RequestID),
                        log.Fields{"latency": int64(evt.Duration) / int64(time.Millisecond)})
        }</span>
}

func (m *mongoLogger) pushCommandString(requestID int64, commandString string) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.requestMap[requestID] = struct{ commandString string }{commandString: commandString}
}</span>

func (m *mongoLogger) popCommandString(requestID int64) string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        reqCtx, ok := m.requestMap[requestID]
        if ok </span><span class="cov0" title="0">{
                delete(m.requestMap, requestID)
                return reqCtx.commandString
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *mongoLogger) isLoggableCommandName(commandName string) bool <span class="cov10" title="46">{
        m.reloadConfig()
        if !m.enabled </span><span class="cov4" title="4">{
                return false
        }</span>
        <span class="cov9" title="42">return m.logableCommandSet.Contains(commandName)</span>
}

func (m *mongoLogger) reloadConfig() <span class="cov10" title="46">{
        var cfgs map[string]map[string]any
        _ = config.Use(m.appName).LoadComponentConfig(config.ComponentMongo, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="46">cfg, ok := cfgs[m.confName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="46">m.enabled = cast.ToBool(cfg["enable_logger"])
        logConfigObj, ok1 := cfg["logger_config"]
        logCfg, ok2 := logConfigObj.(map[string]any)
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="46">logableCommandList, ok := logCfg["logable_commands"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="46">m.logableCommandSet = utils.NewSet(logableCommandList...)</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package customlogger

import (
        "context"
        "reflect"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

var (
        // MQLogger FIXME: should not be deleted to avoid compiler optimized
        MQLogger = reflect.TypeOf(mqLogger{})
)

// mqLogger implements watermill.LoggerAdapter with *zap.Logger.
type mqLogger struct {
        log      log.Logable
        appName  string
        confName string
        enabled  bool
        fields   watermill.LogFields
}

// NewLogger returns new watermill.LoggerAdapter using passed *zap.Logger as backend.
func NewLogger() watermill.LoggerAdapter <span class="cov0" title="0">{
        return new(mqLogger)
}</span>

func (m *mqLogger) Init(log log.Logable, appName, name string) <span class="cov5" title="54">{
        m.log = log
        m.appName = appName
        m.confName = name
        m.reloadConfig()
}</span>

// Error writes error log with message, error and some fields.
func (m *mqLogger) Error(msg string, err error, fields watermill.LogFields) <span class="cov0" title="0">{
        if !m.isLoggable() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, fs := m.parseLogFields(fields)
        if err != nil </span><span class="cov0" title="0">{
                if m.log != nil </span><span class="cov0" title="0">{
                        m.log.Error(ctx, msg+": %s", err, fs)
                }</span> else<span class="cov0" title="0"> {
                        log.Error(ctx, msg+": %s", err, fs)
                }</span>
        } else<span class="cov0" title="0"> {
                if m.log != nil </span><span class="cov0" title="0">{
                        m.log.Error(ctx, msg, err, fs)
                }</span> else<span class="cov0" title="0"> {
                        log.Error(ctx, msg, err, fs)
                }</span>
        }
}

// Info writes info log with message and some fields.
func (m *mqLogger) Info(msg string, fields watermill.LogFields) <span class="cov8" title="688">{
        if !m.isLoggable() </span><span class="cov5" title="48">{
                return
        }</span>
        <span class="cov8" title="640">ctx, fs := m.parseLogFields(fields)
        if m.log != nil </span><span class="cov8" title="640">{
                m.log.Info(ctx, msg, fs)
        }</span> else<span class="cov0" title="0"> {
                log.Info(ctx, msg, fs)
        }</span>
}

// Debug writes debug log with message and some fields.
func (m *mqLogger) Debug(msg string, fields watermill.LogFields) <span class="cov8" title="1066">{
        if !m.isLoggable() </span><span class="cov6" title="126">{
                return
        }</span>
        <span class="cov8" title="940">ctx, fs := m.parseLogFields(fields)
        if m.log != nil </span><span class="cov8" title="940">{
                m.log.Debug(ctx, msg, fs)
        }</span> else<span class="cov0" title="0"> {
                log.Debug(ctx, msg, fs)
        }</span>
}

// Trace writes debug log instead of trace log because zap does not support trace level logging.
func (m *mqLogger) Trace(msg string, fields watermill.LogFields) <span class="cov8" title="1433">{
        if !m.isLoggable() </span><span class="cov8" title="813">{
                return
        }</span>
        <span class="cov7" title="622">ctx, fs := m.parseLogFields(fields)
        if m.log != nil </span><span class="cov7" title="621">{
                m.log.Debug(ctx, msg, fs)
        }</span> else<span class="cov0" title="0"> {
                log.Debug(ctx, msg, fs)
        }</span>
}

// With returns new LoggerAdapter with passed fields.
func (m *mqLogger) With(fields watermill.LogFields) watermill.LoggerAdapter <span class="cov5" title="84">{
        return &amp;mqLogger{fields: m.fields.Add(fields)}
}</span>

func (m *mqLogger) parseLogFields(fields watermill.LogFields) (ctx context.Context, fs log.Fields) <span class="cov9" title="2202">{
        ctx = context.Background()
        fields = m.fields.Add(fields)

        fs = make(log.Fields, len(fields)+1)
        for k, v := range fields </span><span class="cov10" title="4004">{
                if k == watermill.ContextLogFieldKey </span><span class="cov0" title="0">{
                        ctx = v.(context.Context)
                        continue</span>
                }
                <span class="cov10" title="4004">fs[k] = v</span>
        }
        <span class="cov9" title="2201">return</span>
}

func (m *mqLogger) isLoggable() bool <span class="cov9" title="3187">{ m.reloadConfig(); return m.enabled }</span>

func (m *mqLogger) reloadConfig() <span class="cov9" title="3241">{
        var cfgs map[string]map[string]any
        _ = config.Use(m.appName).LoadComponentConfig(config.ComponentMessageQueue, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov8" title="983">{
                return
        }</span>

        <span class="cov9" title="2260">cfg, ok := cfgs[m.confName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="2259">enabled := cast.ToBool(cfg["enable_logger"])
        m.enabled = enabled</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">package customlogger

import (
        "context"
        "net"
        "reflect"
        "strings"
        "time"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"

        rdsDrv "github.com/redis/go-redis/v9"
)

var (
        // RedisLoggerType FIXME: should not be deleted to avoid compiler optimized
        RedisLoggerType = reflect.TypeOf(redisLogger{})
)

type redisLogger struct {
        log                 log.Logable
        appName             string
        confName            string
        enabled             bool
        unlogableCommandSet *utils.Set[string]
}

func (r *redisLogger) Init(log log.Logable, appName, name string) <span class="cov3" title="18">{
        r.log = log
        r.appName = appName
        r.confName = name
        r.reloadConfig()
}</span>

func (r *redisLogger) DialHook(next rdsDrv.DialHook) rdsDrv.DialHook <span class="cov3" title="18">{
        return func(ctx context.Context, network, addr string) (c net.Conn, e error) </span><span class="cov5" title="106">{ return next(ctx, network, addr) }</span>
}

func (r *redisLogger) ProcessHook(next rdsDrv.ProcessHook) rdsDrv.ProcessHook <span class="cov3" title="18">{
        return func(ctx context.Context, cmd rdsDrv.Cmder) (err error) </span><span class="cov9" title="6883">{
                if !r.isLoggableCommandSet(cmd.Name()) </span><span class="cov9" title="6889">{
                        return next(ctx, cmd)
                }</span>

                <span class="cov0" title="0">begin := time.Now()
                if err = next(ctx, cmd); err != nil </span><span class="cov0" title="0">{
                        if r.log != nil </span><span class="cov0" title="0">{
                                r.log.Warn(ctx, "[redis] %s failed [command[%s]]", cmd.FullName(), cmd.String(),
                                        log.Fields{"latency": time.Since(begin).Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Warn(ctx, "[redis] %s failed [command[%s]]", cmd.FullName(), cmd.String(),
                                        log.Fields{"latency": time.Since(begin).Milliseconds()})
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">if r.log != nil </span><span class="cov0" title="0">{
                        r.log.Info(ctx, "[redis] %s succeeded [command[%s]]", cmd.FullName(), cmd.String(),
                                log.Fields{"latency": time.Since(begin).Milliseconds()})
                }</span> else<span class="cov0" title="0"> {
                        log.Info(ctx, "[redis] %s succeeded [command[%s]]", cmd.FullName(), cmd.String(),
                                log.Fields{"latency": time.Since(begin).Milliseconds()})
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

func (r *redisLogger) ProcessPipelineHook(next rdsDrv.ProcessPipelineHook) rdsDrv.ProcessPipelineHook <span class="cov4" title="36">{
        return func(ctx context.Context, cmds []rdsDrv.Cmder) (err error) </span><span class="cov8" title="1509">{
                if !r.isLoggable() </span><span class="cov8" title="1509">{
                        return next(ctx, cmds)
                }</span>
                <span class="cov0" title="0">begin := time.Now()
                fullNameSb := new(strings.Builder)
                for _, cmd := range cmds </span><span class="cov0" title="0">{
                        _, _ = fullNameSb.WriteString(cmd.FullName() + " -&gt; ")
                }</span>

                <span class="cov0" title="0">if err = next(ctx, cmds); err != nil </span><span class="cov0" title="0">{
                        if r.log != nil </span><span class="cov0" title="0">{
                                r.log.Warn(ctx, "[redis] %s failed", fullNameSb.String(),
                                        log.Fields{"latency": time.Since(begin).Milliseconds()})
                        }</span> else<span class="cov0" title="0"> {
                                log.Warn(ctx, "[redis] %s failed", fullNameSb.String(),
                                        log.Fields{"latency": time.Since(begin).Milliseconds()})
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">if r.log != nil </span><span class="cov0" title="0">{
                        r.log.Info(ctx, "[redis] %s succeeded", fullNameSb.String(),
                                log.Fields{"latency": time.Since(begin).Milliseconds()})
                }</span> else<span class="cov0" title="0"> {
                        log.Info(ctx, "[redis] %s succeeded", fullNameSb.String(),
                                log.Fields{"latency": time.Since(begin).Milliseconds()})
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

func (r *redisLogger) isLoggableCommandSet(command string) bool <span class="cov9" title="6877">{
        r.reloadConfig()
        if !r.enabled </span><span class="cov9" title="6884">{
                return false
        }</span>
        <span class="cov0" title="0">if r.unlogableCommandSet == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return !r.unlogableCommandSet.Contains(command)</span>
}

func (r *redisLogger) isLoggable() bool <span class="cov8" title="1509">{ r.reloadConfig(); return r.enabled }</span>

func (r *redisLogger) reloadConfig() <span class="cov9" title="8401">{
        var cfgs map[string]map[string]any
        _ = config.Use(r.appName).LoadComponentConfig(config.ComponentRedis, &amp;cfgs)
        if len(cfgs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="8447">cfg, ok := cfgs[r.confName]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="8445">enabled := cast.ToBool(cfg["enable_logger"])
        r.enabled = enabled

        unlogableCommandsObj, ok1 := cfg["unlogable_commands"]
        unlogableCommands, ok2 := unlogableCommandsObj.([]string)
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="8394">sets := utils.NewSet(unlogableCommands...)
        r.unlogableCommandSet = sets</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package customlogger

import (
        "context"
        "reflect"

        "github.com/panjf2000/ants/v2"
        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

var (
        // RoutineLoggerType FIXME: should not be deleted to avoid compiler optimized
        RoutineLoggerType = reflect.TypeOf(routineLogger{})
)

func DefaultRoutineLogger() ants.Logger <span class="cov0" title="0">{
        return &amp;routineLogger{
                enabled: true,
        }
}</span>

type routineLogger struct {
        log     log.Logable
        appName string
        enabled bool
}

func (r *routineLogger) Init(log log.Logable, appName string) <span class="cov10" title="25">{
        r.log = log
        r.appName = appName
        r.reloadConfig()
}</span>

func (r *routineLogger) Printf(format string, args ...any) <span class="cov0" title="0">{
        if r.reloadConfig(); r.enabled </span><span class="cov0" title="0">{
                ctx := context.Background()
                if r.log != nil </span><span class="cov0" title="0">{
                        r.log.Info(ctx, format, args...)
                }</span> else<span class="cov0" title="0"> {
                        log.Info(ctx, format, args...)
                }</span>
        }
}

func (r *routineLogger) reloadConfig() <span class="cov10" title="25">{
        cfg := make(map[string]any)
        _ = config.Use(r.appName).LoadComponentConfig(config.ComponentGoroutinePool, &amp;cfg)

        r.enabled = cast.ToBool(cfg["enabled_logger"])
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">package encoder

import (
        "go.uber.org/zap/zapcore"

        "github.com/wfusion/gofusion/common/utils"
)

var (
        SkipCallers = []string{
                "*github.com/wfusion/gofusion*/log/candy.go",
                "*github.com/wfusion/gofusion*/log/logger.go",
                "*github.com/wfusion/gofusion*/log/customlogger/*.go",
                "*github.com/wfusion/gofusion*/db/tx.go",
                "*github.com/wfusion/gofusion*/db/dal.go",
                "*github.com/wfusion/gofusion*/db/candy.go",
                "*github.com/wfusion/gofusion*/db/plugins/*.go",
                "*github.com/wfusion/gofusion*/db/callbacks/*.go",
                "*github.com/wfusion/gofusion*/db/softdelete/*.go",
                "*github.com/wfusion/gofusion*/cron/log.go",
                "*github.com/wfusion/gofusion*/async/log.go",
                "*github.com/wfusion/gofusion*/mq/log.go",
                "*github.com/wfusion/gofusion*/mq/mq.go",
                "*github.com/wfusion/gofusion*/routine/*.go",
                "*github.com/wfusion/gofusion*/common/infra/asynq/*.go",
                "*github.com/wfusion/gofusion*/common/infra/watermill/log.go",
        }

        // Positions in the call stack when tracing to report the calling method
        minimumCallerDepthOpt         utils.OptionExtender
        defaultSuffixedRegOpt         utils.OptionExtender
        defaultSuffixesRegPatternList = []string{
                `go.uber.org/zap(|@v.*)/.*go$`,
                `gorm.io/gorm(|@v.*)/.*go$`,
                `mysql@v.*/.*go$`,
                `postgres@v.*/.*go`,
                `sqlserver@v.*/.*go`,
                `mongo-driver(|@v.*)/.*go$`,
                `github.com/redis/go-redis/v9(|@v.*)/.*go$`,
                `asm_(amd64|arm64)\.s$`,
        }
)

const (
        maximumCallerDepth int = 25
        knownLogrusFrames  int = 7 // should be github.com/wfusion/gofusion/log/candy.go:14
)

func init() <span class="cov3" title="14">{
        defaultSuffixedRegOpt = utils.SkipRegexps(defaultSuffixesRegPatternList...)
        minimumCallerDepthOpt = utils.SkipKnownDepth(knownLogrusFrames)
}</span>

// SkipCallerEncoder skip custom stack when encoding stack
func SkipCallerEncoder(skipSuffixed []string, shorter bool) func(
        caller zapcore.EntryCaller, enc zapcore.PrimitiveArrayEncoder) <span class="cov4" title="52">{
        skipGlobOpt := utils.SkipGlobs(skipSuffixed...)
        return func(entryCaller zapcore.EntryCaller, enc zapcore.PrimitiveArrayEncoder) </span><span class="cov10" title="12641">{
                caller := utils.GetCaller(
                        maximumCallerDepth,
                        skipGlobOpt,
                        defaultSuffixedRegOpt,
                        minimumCallerDepthOpt,
                )

                entryCaller.PC = caller.PC
                entryCaller.File = caller.File
                entryCaller.Line = caller.Line
                entryCaller.Function = caller.Function
                if shorter </span><span class="cov9" title="12529">{
                        enc.AppendString(entryCaller.TrimmedPath())
                }</span> else<span class="cov5" title="120"> {
                        enc.AppendString(entryCaller.FullPath())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package log

import (
        "context"

        "go.uber.org/zap"

        fmkCtx "github.com/wfusion/gofusion/context"
)

type Fields map[string]any

func getContextZapFields(ctx context.Context) (zapFields []zap.Field) <span class="cov9" title="12647">{
        v := ctx.Value(fmkCtx.KeyLogFields)
        if v == nil </span><span class="cov9" title="12567">{
                return
        }</span>
        <span class="cov5" title="80">field, ok := v.(Fields)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="80">return convertFieldsToZapFields(field)</span>
}

func convertFieldsToZapFields(fields Fields) (zapFields []zap.Field) <span class="cov9" title="9752">{
        zapFields = make([]zap.Field, 0, len(fields))
        for k, v := range fields </span><span class="cov10" title="18060">{
                zapFields = append(zapFields, zap.Any(k, v))
        }</span>
        <span class="cov9" title="9747">return</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package log

import (
        "context"
        "fmt"
        "log"
        "sync"
        "syscall"

        "github.com/pkg/errors"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log/encoder"

        fmkCtx "github.com/wfusion/gofusion/context"
)

var (
        globalLogger = defaultLogger(false)

        rwlock       = new(sync.RWMutex)
        appInstances map[string]map[string]*logger
)

type logger struct {
        name          string
        logger        *zap.Logger
        sugaredLogger *zap.SugaredLogger
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov9" title="6903">{
        return func(o *useOption) </span><span class="cov9" title="6820">{
                o.appName = name
        }</span>
}

func Use(name string, opts ...utils.OptionExtender) Logable <span class="cov9" title="6894">{
        opt := utils.ApplyOptions[useOption](opts...)

        rwlock.RLock()
        defer rwlock.RUnlock()
        instances, ok := appInstances[opt.appName]
        if !ok </span><span class="cov2" title="4">{
                globalLogger.Debug(context.Background(), "%v [Gofusion] %s instance not found for app: %s",
                        syscall.Getpid(), config.ComponentLog, opt.appName)
                return globalLogger
        }</span>
        <span class="cov9" title="6965">instance, ok := instances[name]
        if !ok </span><span class="cov0" title="0">{
                globalLogger.Debug(context.Background(), "%v [Gofusion] %s instance not found for name: %s",
                        syscall.Getpid(), config.ComponentLog, name)
                return globalLogger
        }</span>

        <span class="cov9" title="6968">return instance</span>
}

func defaultLogger(colorful bool) Logable <span class="cov3" title="19">{
        devCfg := zap.NewDevelopmentConfig()
        devCfg.Level = zap.NewAtomicLevelAt(zap.InfoLevel)
        if colorful </span><span class="cov0" title="0">{
                devCfg.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        }</span>
        <span class="cov3" title="19">devCfg.EncoderConfig.EncodeCaller = encoder.SkipCallerEncoder(encoder.SkipCallers, true)
        zapLogger, _ := devCfg.Build(
                zap.AddStacktrace(zap.PanicLevel),
                zap.AddCaller(),
                zap.Hooks(),
        )
        return &amp;logger{
                logger:        zapLogger,
                sugaredLogger: zapLogger.Sugar(),
        }</span>
}
func (l *logger) Debug(ctx context.Context, format string, args ...any) <span class="cov8" title="2878">{
        msg, fields := l.sweeten(ctx, format, args...)
        l.logger.Debug(msg, fields...)
}</span>
func (l *logger) Info(ctx context.Context, format string, args ...any) <span class="cov9" title="9739">{
        msg, fields := l.sweeten(ctx, format, args...)
        l.logger.Info(msg, fields...)
}</span>
func (l *logger) Warn(ctx context.Context, format string, args ...any) <span class="cov4" title="32">{
        msg, fields := l.sweeten(ctx, format, args...)
        l.logger.Warn(msg, fields...)
}</span>
func (l *logger) Error(ctx context.Context, format string, args ...any) <span class="cov0" title="0">{
        msg, fields := l.sweeten(ctx, format, args...)
        l.logger.Error(msg, fields...)
}</span>
func (l *logger) Panic(ctx context.Context, format string, args ...any) <span class="cov0" title="0">{
        msg, fields := l.sweeten(ctx, format, args...)
        l.logger.Panic(msg, fields...)
}</span>
func (l *logger) Fatal(ctx context.Context, format string, args ...any) <span class="cov0" title="0">{
        msg, fields := l.sweeten(ctx, format, args...)
        l.logger.Fatal(msg, fields...)
}</span>
func (l *logger) flush() <span class="cov4" title="32">{
        ignore := func(err error) bool </span><span class="cov4" title="64">{
                // ENOTTY:
                //     ignore sync /dev/stdout: inappropriate ioctl for device errors,
                //     which happens when redirect stderr to stdout
                // EINVAL:
                //     ignore sync /dev/stdout: invalid argument
                for _, target := range []error{syscall.EINVAL, syscall.ENOTTY} </span><span class="cov5" title="128">{
                        if errors.Is(err, target) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov4" title="64">return false</span>
        }

        <span class="cov4" title="32">pid := syscall.Getpid()
        if _, err := utils.Catch(l.logger.Sync); err != nil &amp;&amp; !ignore(err) </span><span class="cov4" title="32">{
                log.Printf("%v [Gofusion] %s flush %s logger error: %s", pid, config.ComponentLog, l.name, err)
        }</span>
        <span class="cov4" title="32">if _, err := utils.Catch(l.sugaredLogger.Sync); err != nil &amp;&amp; !ignore(err) </span><span class="cov4" title="32">{
                log.Printf("%v [Gofusion] %s flush %s sugared logger error: %s",
                        pid, config.ComponentLog, l.name, err)
        }</span>
}

func (l *logger) sweeten(ctx context.Context, format string, raw ...any) (msg string, fields []zap.Field) <span class="cov9" title="12648">{
        args := make([]any, 0, len(raw))
        fields = getContextZapFields(ctx)
        for _, arg := range raw </span><span class="cov10" title="16196">{
                if f, ok := arg.(Fields); ok </span><span class="cov9" title="9673">{
                        fields = append(fields, convertFieldsToZapFields(f)...)
                        continue</span>
                }
                <span class="cov9" title="6525">args = append(args, arg)</span>
        }

        <span class="cov9" title="12648">msg = fmt.Sprintf(format, args...)
        if userID := fmkCtx.GetUserID(ctx); utils.IsStrNotBlank(userID) </span><span class="cov0" title="0">{
                fields = append(fields, zap.String("user_id", userID))
        }</span>
        <span class="cov9" title="12648">if traceID := fmkCtx.GetTraceID(ctx); utils.IsStrNotBlank(traceID) </span><span class="cov5" title="197">{
                fields = append(fields, zap.String("trace_id", traceID))
        }</span>
        <span class="cov9" title="12644">if taskID := fmkCtx.GetCronTaskID(ctx); utils.IsStrNotBlank(taskID) </span><span class="cov0" title="0">{
                fields = append(fields, zap.String("cron_task_id", taskID))
        }</span>
        <span class="cov9" title="12647">if taskName := fmkCtx.GetCronTaskName(ctx); utils.IsStrNotBlank(taskName) </span><span class="cov4" title="32">{
                fields = append(fields, zap.String("cron_task_name", taskName))
        }</span>
        <span class="cov9" title="12641">if id := utils.GetCtxAny[string](ctx, watermill.ContextKeyMessageUUID); utils.IsStrNotBlank(id) </span><span class="cov5" title="145">{
                fields = append(fields, zap.String("message_uuid", id))
        }</span>
        <span class="cov9" title="12643">if id := utils.GetCtxAny[string](ctx, watermill.ContextKeyRawMessageID); utils.IsStrNotBlank(id) </span><span class="cov5" title="145">{
                fields = append(fields, zap.String("message_raw_id", id))
        }</span>

        <span class="cov9" title="12643">return</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">package log

import (
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "github.com/wfusion/gofusion/log/encoder"
)

func getLogLevel(level string) zapcore.Level <span class="cov10" title="64">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="30">
                return zap.DebugLevel</span>
        case "info":<span class="cov2" title="2">
                return zap.InfoLevel</span>
        case "warn":<span class="cov0" title="0">
                return zap.WarnLevel</span>
        case "error":<span class="cov8" title="31">
                return zap.ErrorLevel</span>
        case "panic":<span class="cov1" title="1">
                return zap.PanicLevel</span>
        case "fatal":<span class="cov0" title="0">
                return zap.FatalLevel</span>
        default:<span class="cov0" title="0">
                return zap.InfoLevel</span>
        }
}

func getEncoderConfig(conf *Conf) zapcore.EncoderConfig <span class="cov8" title="33">{
        skips := make([]string, 0, len(encoder.SkipCallers)+len(conf.SkipCallers))
        skips = append(skips, encoder.SkipCallers...)
        skips = append(skips, conf.SkipCallers...)
        return zapcore.EncoderConfig{
                LevelKey:       "L",
                TimeKey:        "T",
                MessageKey:     "M",
                NameKey:        "N",
                CallerKey:      "C",
                StacktraceKey:  "S",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.CapitalLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   encoder.SkipCallerEncoder(skips, conf.ShorterFilepath),
        }
}</span>

func getEncoder(layout string, cfg zapcore.EncoderConfig) zapcore.Encoder <span class="cov8" title="33">{
        switch strings.ToLower(layout) </span>{
        case "json":<span class="cov1" title="1">
                return zapcore.NewJSONEncoder(cfg)</span>
        case "console":<span class="cov8" title="32">
                return zapcore.NewConsoleEncoder(cfg)</span>
        default:<span class="cov0" title="0">
                return zapcore.NewJSONEncoder(cfg)</span>
        }
}
</pre>
		
		<pre class="file" id="file163" style="display: none">package metrics

import (
        "context"
        "log"
        "reflect"
        "syscall"
        "time"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/metrics"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/config"

        fmkLog "github.com/wfusion/gofusion/log"
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov5" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov2" title="5">{
                opt.AppName = optU.appName
        }</span>
        <span class="cov5" title="34">for name, conf := range confs </span><span class="cov4" title="23">{
                addConfig(ctx, name, conf, opt)
        }</span>

        <span class="cov5" title="34">return func() </span><span class="cov5" title="34">{
                rwlock.Lock()
                defer rwlock.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                if appInstances != nil </span><span class="cov4" title="21">{
                        for _, sinks := range appInstances[opt.AppName] </span><span class="cov3" title="10">{
                                for name, sink := range sinks </span><span class="cov3" title="12">{
                                        log.Printf("%v [Gofusion] %s %s %s router exiting...",
                                                pid, app, config.ComponentMetrics, name)
                                        sink.shutdown()
                                        log.Printf("%v [Gofusion] %s %s %s router exited",
                                                pid, app, config.ComponentMetrics, name)
                                }</span>
                        }
                        <span class="cov4" title="21">delete(appInstances, opt.AppName)</span>
                }

                <span class="cov5" title="34">if cfgsMap != nil </span><span class="cov4" title="24">{
                        delete(cfgsMap, opt.AppName)
                }</span>
        }
}

func addConfig(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov4" title="23">{
        var (
                err      error
                interval time.Duration
        )
        if utils.IsStrNotBlank(conf.Interval) </span><span class="cov4" title="22">{
                interval, err = time.ParseDuration(conf.Interval)
                if err != nil </span><span class="cov0" title="0">{
                        panic(errors.Errorf("metrics component parse %s interval failed: %s", name, err))</span>
                }
        }

        <span class="cov4" title="23">rwlock.Lock()
        defer rwlock.Unlock()
        if cfgsMap == nil </span><span class="cov3" title="6">{
                cfgsMap = make(map[string]map[string]*cfg)
        }</span>
        <span class="cov4" title="23">if cfgsMap[opt.AppName] == nil </span><span class="cov4" title="22">{
                cfgsMap[opt.AppName] = make(map[string]*cfg)
        }</span>
        <span class="cov4" title="23">if _, ok := cfgsMap[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedName)</span>
        }

        <span class="cov4" title="23">var logger metrics.Logger
        if utils.IsStrNotBlank(conf.Logger) </span><span class="cov4" title="23">{
                loggerType := inspect.TypeOf(conf.Logger)
                loggerValue := reflect.New(loggerType)
                if loggerValue.Type().Implements(customLoggerType) </span><span class="cov4" title="23">{
                        logger := fmkLog.Use(conf.LogInstance, fmkLog.AppName(opt.AppName))
                        loggerValue.Interface().(customLogger).Init(logger, opt.AppName, name)
                }</span>
                <span class="cov4" title="23">logger = loggerValue.Convert(metricsLoggerType).Interface().(metrics.Logger)</span>
        }

        <span class="cov4" title="23">cfgsMap[opt.AppName][name] = &amp;cfg{
                c:          conf,
                ctx:        ctx,
                name:       name,
                appName:    opt.AppName,
                interval:   interval,
                initOption: opt,
                logger:     logger,
        }</span>
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov10" title="2235">{
        return func(o *useOption) </span><span class="cov9" title="2167">{
                o.appName = name
        }</span>
}

func NewDI(name, job string, opts ...utils.OptionExtender) func() Sink <span class="cov0" title="0">{
        return func() Sink </span><span class="cov0" title="0">{
                return Use(name, job, opts...)
        }</span>
}

func Use(name, job string, opts ...utils.OptionExtender) Sink <span class="cov9" title="1847">{
        opt := utils.ApplyOptions[useOption](opts...)
        rwlock.Lock()
        defer rwlock.Unlock()
        cfgs, ok := cfgsMap[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("app metrics config not found: %s", opt.appName))</span>
        }
        <span class="cov9" title="2003">cfg, ok := cfgs[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("metrics config not found: %s", name))</span>
        }

        <span class="cov9" title="2003">return use(job, cfg)</span>
}

func use(job string, conf *cfg) (sink Sink) <span class="cov9" title="2129">{
        if appInstances == nil </span><span class="cov2" title="4">{
                appInstances = make(map[string]map[string]map[string]Sink)
        }</span>
        <span class="cov9" title="2129">instances, ok := appInstances[conf.appName]
        if !ok </span><span class="cov3" title="9">{
                instances = make(map[string]map[string]Sink)
                appInstances[conf.appName] = instances
        }</span>

        <span class="cov9" title="2129">jobs, ok := instances[conf.name]
        if !ok </span><span class="cov3" title="10">{
                jobs = make(map[string]Sink)
                instances[conf.name] = jobs
        }</span>
        <span class="cov9" title="2129">sink, ok = jobs[job]
        if ok </span><span class="cov9" title="2117">{
                return
        }</span>

        <span class="cov3" title="12">switch conf.c.Type </span>{
        case metricsTypePrometheus:<span class="cov3" title="11">
                switch conf.c.Mode </span>{
                case modePull:<span class="cov0" title="0">
                        sink = newPrometheusPull(conf.ctx, conf.appName, conf.name, job, conf)</span>
                case modePush:<span class="cov3" title="11">
                        sink = newPrometheusPush(conf.ctx, conf.appName, conf.name, job, conf.interval, conf)</span>
                }
        case metricsTypeMock:<span class="cov1" title="1">
                sink = newMock(conf.ctx, conf.appName, conf.name, job, conf)</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("unknown metrics type: %s", conf.c.Type))</span>
        }

        <span class="cov3" title="12">if sink == nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("unknown metrics mode: %s", conf.c.Mode))</span>
        }

        <span class="cov3" title="12">jobs[job] = sink
        return</span>
}

func Internal(opts ...utils.OptionExtender) (sinks []Sink) <span class="cov7" title="376">{
        opt := utils.ApplyOptions[useOption](opts...)
        appName := config.Use(opt.appName).AppName()
        rwlock.Lock()
        defer rwlock.Unlock()
        cfgs, ok := cfgsMap[opt.appName]
        if !ok </span><span class="cov7" title="251">{
                return
        }</span>
        <span class="cov6" title="125">for _, cfg := range cfgs </span><span class="cov6" title="126">{
                if cfg.c.EnableInternalMetrics </span><span class="cov6" title="126">{
                        sinks = append(sinks, use(appName, cfg))
                }</span>
        }
        <span class="cov6" title="125">return</span>
}

func init() <span class="cov4" title="14">{
        config.AddComponent(config.ComponentMetrics, Construct)
}</span>
</pre>
		
		<pre class="file" id="file164" style="display: none">package metrics

import (
        "net/http"

        "github.com/pkg/errors"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        "github.com/wfusion/gofusion/common/infra/metrics/prometheus"
        "github.com/wfusion/gofusion/common/utils"

        proDrv "github.com/prometheus/client_golang/prometheus"
)

func HttpHandler(path, name string, opts ...utils.OptionExtender) http.Handler <span class="cov0" title="0">{
        opt := utils.ApplyOptions[useOption](opts...)
        rwlock.RLock()
        defer rwlock.RUnlock()

        if appInstances == nil || appInstances[opt.appName] == nil || appInstances[opt.appName][name] == nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("metrics instance not found: %s %s", opt.appName, name))</span>
        }

        // cfg := cfgsMap[opt.appName][name]
        <span class="cov0" title="0">m := utils.MapValues(appInstances[opt.appName][name])[0]
        switch sink := m.getProxy().(type) </span>{
        case *prometheus.PrometheusSink:<span class="cov0" title="0">
                gatherer, ok := sink.Registry.(proDrv.Gatherer)
                if !ok </span><span class="cov0" title="0">{
                        gatherer = proDrv.DefaultGatherer
                }</span>
                <span class="cov0" title="0">return promhttp.InstrumentMetricHandler(
                        sink.Registry, promhttp.HandlerFor(gatherer, promhttp.HandlerOpts{}),
                )</span>
        default:<span class="cov0" title="0">
                panic(errors.Errorf("metrics instance not support http exporter: %s %s", opt.appName, name))</span>
        }
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package metrics

import (
        "context"
        "fmt"
        "runtime"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/Rican7/retry"
        "github.com/Rican7/retry/strategy"
        "github.com/panjf2000/ants/v2"
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/infra/metrics"
        "github.com/wfusion/gofusion/common/infra/metrics/prometheus"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/config"
)

const (
        defaultQueueLimit = 16 * 1024
)

var (
        rwlock       = new(sync.RWMutex)
        appInstances map[string]map[string]map[string]Sink
        cfgsMap      map[string]map[string]*cfg
)

type abstract struct {
        *metrics.Metrics

        ctx         context.Context
        job         string
        name        string
        appName     string
        log         metrics.Logger
        constLabels []metrics.Label

        stop      chan struct{}
        queue     chan *task
        queuePool *ants.Pool

        dispatcher map[string]func(...any)
}

type task struct {
        ctx    context.Context
        key    []string
        val    any
        opts   []utils.OptionExtender
        labels []metrics.Label
        method string
}

func (t *task) String() string <span class="cov0" title="0">{
        label := make(map[string]string, len(t.labels))
        for _, l := range t.labels </span><span class="cov0" title="0">{
                label[l.Name] = l.Value
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s:%s:%+v(%+v)", t.method, strings.Join(t.key, constant.Dot), t.val, label)</span>
}

func newMetrics(ctx context.Context, appName, name, job string, sink metrics.MetricSink, conf *cfg) *abstract <span class="cov2" title="12">{
        metricsConfig := metrics.DefaultConfig(config.Use(appName).AppName())
        if conf.c.EnableServiceLabel </span><span class="cov2" title="11">{
                metricsConfig.EnableHostname = true
                metricsConfig.EnableHostnameLabel = true
                metricsConfig.EnableServiceLabel = true
                metricsConfig.EnableClientIPLabel = true
        }</span> else<span class="cov1" title="1"> {
                metricsConfig.EnableHostname = false
                metricsConfig.EnableHostnameLabel = false
                metricsConfig.EnableServiceLabel = false
                metricsConfig.EnableClientIPLabel = false
        }</span>

        <span class="cov2" title="12">m, err := metrics.New(metricsConfig, sink)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("initialize metrics failed: %s", err))</span>
        }

        <span class="cov2" title="12">limit := defaultQueueLimit
        if conf.c.QueueLimit &gt; 0 </span><span class="cov2" title="12">{
                limit = conf.c.QueueLimit
        }</span>
        <span class="cov2" title="12">if conf.c.QueueConcurrency == 0 </span><span class="cov2" title="10">{
                conf.c.QueueConcurrency = runtime.NumCPU()
        }</span>

        <span class="cov2" title="12">constLabels := make([]metrics.Label, 0, len(conf.c.Labels))
        for k, v := range conf.c.Labels </span><span class="cov2" title="6">{
                constLabels = append(constLabels, metrics.Label{Name: k, Value: v})
        }</span>

        <span class="cov2" title="12">a := &amp;abstract{
                Metrics: m,

                ctx:         ctx,
                constLabels: constLabels,
                job:         job,
                name:        name,
                appName:     appName,
                log:         conf.logger,
                stop:        make(chan struct{}),
                queue:       make(chan *task, limit),
                queuePool:   utils.Must(ants.NewPool(conf.c.QueueConcurrency)),
        }

        a.dispatcher = map[string]func(...any){
                "Gauge":        utils.WrapFunc(a.setGaugeWithLabels),
                "Counter":      utils.WrapFunc(a.incrCounterWithLabels),
                "Sample":       utils.WrapFunc(a.addSampleWithLabels),
                "MeasureSince": utils.WrapFunc(a.measureSinceWithLabels),
        }

        a.start()

        return a</span>
}

func (a *abstract) SetGauge(ctx context.Context, key []string, val float64, opts ...utils.OptionExtender) <span class="cov8" title="40268">{
        a.send(ctx, "Gauge", key, val, opts...)
}</span>
func (a *abstract) IncrCounter(ctx context.Context, key []string, val float64, opts ...utils.OptionExtender) <span class="cov7" title="20027">{
        a.send(ctx, "Counter", key, val, opts...)
}</span>
func (a *abstract) AddSample(ctx context.Context, key []string, val float64, opts ...utils.OptionExtender) <span class="cov8" title="40035">{
        a.send(ctx, "Sample", key, val, opts...)
}</span>
func (a *abstract) MeasureSince(ctx context.Context, key []string, start time.Time, opts ...utils.OptionExtender) <span class="cov8" title="39979">{
        a.send(ctx, "MeasureSince", key, start, opts...)
}</span>
func (a *abstract) IsEnableServiceLabel() bool <span class="cov4" title="126">{ return a.EnableServiceLabel }</span>

func (a *abstract) getProxy() any <span class="cov0" title="0">{
        return inspect.GetField[metrics.MetricSink](a.Metrics, "sink")
}</span>
func (a *abstract) shutdown() <span class="cov2" title="12">{
        if _, ok := utils.IsChannelClosed(a.stop); ok </span><span class="cov2" title="12">{
                return
        }</span>

        <span class="cov0" title="0">close(a.stop)
        a.Metrics.Shutdown()</span>
}

func (a *abstract) send(ctx context.Context, method string, key []string, val any, opts ...utils.OptionExtender) <span class="cov9" title="140126">{
        opt := utils.ApplyOptions[option](opts...)

        t := &amp;task{
                ctx:    ctx,
                key:    key,
                val:    val,
                opts:   append(opts, a.convertOpts(opts...)...),
                labels: a.convertLabels(opt.labels),
                method: method,
        }

        switch </span>{
        case opt.timeout &gt; 0:<span class="cov1" title="1">
                timeoutCtx, cancel := context.WithTimeout(a.ctx, opt.timeout)
                defer cancel()

                select </span>{
                case a.queue &lt;- t:<span class="cov1" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to context done",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Warn(ctx, "%v [Gofusion] %s %s %s async send task canceled due to timeout %s",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name, opt.timeout)
                        }</span>
                case &lt;-a.stop:<span class="cov0" title="0">
                        close(a.queue)
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to metrics stopped",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to app exited",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                }
        case opt.timeout &lt; 0:<span class="cov9" title="139774">
                select </span>{
                case a.queue &lt;- t:<span class="cov9" title="140001"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to context done",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                case &lt;-a.stop:<span class="cov0" title="0">
                        close(a.queue)
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to metrics stopped",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to app exited",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                }
        default:<span class="cov5" title="372">
                select </span>{
                case a.queue &lt;- t:<span class="cov5" title="372"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to context done",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to app exited",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                case &lt;-a.stop:<span class="cov0" title="0">
                        close(a.queue)
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "%v [Gofusion] %s %s %s async send task canceled due to metrics stopped",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                default:<span class="cov0" title="0">
                        if a.log != nil </span><span class="cov0" title="0">{
                                a.log.Warn(ctx, "%v [Gofusion] %s %s %s async send task canceled due to exceed the queue limit",
                                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                        }</span>
                }
        }
}
func (a *abstract) start() <span class="cov2" title="12">{
        go func() </span><span class="cov2" title="12">{
                appName := config.Use(a.appName).AppName()
                _ = retry.Retry(func(attempt uint) (err error) </span><span class="cov2" title="12">{
                        _, err = utils.Catch(func() </span><span class="cov2" title="12">{
                                for </span><span class="cov9" title="140386">{
                                        select </span>{
                                        case &lt;-a.ctx.Done():<span class="cov2" title="12">
                                                if a.log != nil </span><span class="cov2" title="12">{
                                                        a.log.Info(a.ctx, "%v [Gofusion] %s %s %s process exited due to context done",
                                                                syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                                                        return
                                                }</span>
                                        case task, ok := &lt;-a.queue:<span class="cov9" title="140374">
                                                if !ok </span><span class="cov0" title="0">{
                                                        a.log.Info(a.ctx, "%v [Gofusion] %s %s %s process exited due to queue closed",
                                                                syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name)
                                                        return
                                                }</span>

                                                <span class="cov9" title="140374">if err := a.queuePool.Submit(func() </span><span class="cov9" title="140115">{ _ = a.process(task) }</span>); err != nil &amp;&amp; a.log != nil <span class="cov0" title="0">{
                                                        a.log.Error(task.ctx, "%v [Gofusion] %s %s %s submit process %s error: %s",
                                                                syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics,
                                                                a.name, task, err)
                                                }</span>
                                        }
                                }
                        })
                        <span class="cov2" title="12">if err != nil </span><span class="cov0" title="0">{
                                a.log.Warn(a.ctx, "%v [Gofusion] %s %s %s dispatcher exited with error: %s",
                                        syscall.Getpid(), appName, config.ComponentMetrics, a.name, err)
                        }</span>
                        <span class="cov2" title="12">return</span>
                }, strategy.Limit(10000))
        }()
}
func (a *abstract) process(task *task) (err error) <span class="cov9" title="140112">{
        _, err = utils.Catch(func() (err error) </span><span class="cov9" title="139965">{
                handler, ok := a.dispatcher[task.method]
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("method %s not found", task.method)
                }</span>
                <span class="cov9" title="140134">params := []any{task.key, task.val, append(task.labels, a.constLabels...)}
                params = append(params, utils.SliceMapping(task.opts, func(o utils.OptionExtender) any </span><span class="cov10" title="358754">{ return o }</span>)...)
                <span class="cov9" title="140167">handler(params...)
                return</span>
        })
        <span class="cov9" title="139555">if err != nil &amp;&amp; a.log != nil </span><span class="cov0" title="0">{
                a.log.Error(task.ctx, "%v [Gofusion] %s %s %s process %s catch error: %s",
                        syscall.Getpid(), config.Use(a.appName).AppName(), config.ComponentMetrics, a.name, task, err)
        }</span>
        <span class="cov9" title="139556">return</span>
}

func (a *abstract) setGaugeWithLabels(key []string, v any, labels []metrics.Label, opts ...utils.OptionExtender) <span class="cov8" title="40268">{
        val, ok := v.(float64)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="40251">opt := utils.ApplyOptions[option](opts...)
        if opt.precision </span><span class="cov7" title="10001">{
                a.Metrics.SetPrecisionGaugeWithLabels(key, val, labels, opts...)
        }</span> else<span class="cov8" title="30255"> {
                a.Metrics.SetGaugeWithLabels(key, float32(val), labels, opts...)
        }</span>
}
func (a *abstract) incrCounterWithLabels(key []string, v any, labels []metrics.Label, opts ...utils.OptionExtender) <span class="cov7" title="20032">{
        val, ok := v.(float64)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov7" title="20027">a.Metrics.IncrCounterWithLabels(key, float32(val), labels, opts...)</span>
}
func (a *abstract) addSampleWithLabels(key []string, v any, labels []metrics.Label, opts ...utils.OptionExtender) <span class="cov8" title="40033">{
        val, ok := v.(float64)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="40023">opt := utils.ApplyOptions[option](opts...)
        if opt.precision </span><span class="cov7" title="9999">{
                a.Metrics.AddPrecisionSampleWithLabels(key, val, labels, opts...)
        }</span> else<span class="cov8" title="30025"> {
                a.Metrics.AddSampleWithLabels(key, float32(val), labels, opts...)
        }</span>
}
func (a *abstract) measureSinceWithLabels(key []string, v any, labels []metrics.Label, opts ...utils.OptionExtender) <span class="cov8" title="39992">{
        start, ok := v.(time.Time)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="39974">a.Metrics.MeasureSinceWithLabels(key, start, labels, opts...)</span>
}

func (a *abstract) convertLabels(src []Label) (dst []metrics.Label) <span class="cov9" title="140141">{
        return utils.SliceMapping(src, func(l Label) metrics.Label </span><span class="cov9" title="200307">{
                return metrics.Label{
                        Name:  l.Key,
                        Value: l.Value,
                }
        }</span>)
}
func (a *abstract) convertOpts(src ...utils.OptionExtender) (dst []utils.OptionExtender) <span class="cov9" title="140041">{
        if src == nil </span><span class="cov1" title="4">{
                return
        }</span>

        <span class="cov9" title="140031">dst = make([]utils.OptionExtender, 0, len(src))
        opt := utils.ApplyOptions[option](src...)
        if opt.precision </span><span class="cov8" title="29989">{
                dst = append(dst, metrics.Precision())
        }</span>
        <span class="cov9" title="140015">if len(opt.prometheusBuckets) &gt; 0 </span><span class="cov8" title="30029">{
                dst = append(dst, prometheus.Bucket(opt.prometheusBuckets))
        }</span>

        <span class="cov9" title="140065">return</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">package metrics

import (
        "context"

        "github.com/wfusion/gofusion/common/infra/metrics"
)

type mock struct {
        *abstract
}

func newMock(ctx context.Context, appName, name, job string, conf *cfg) Sink <span class="cov8" title="1">{
        sink := new(metrics.BlackholeSink)
        return &amp;mock{abstract: newMetrics(ctx, appName, name, job, sink, conf)}
}</span>
</pre>
		
		<pre class="file" id="file167" style="display: none">package metrics

import (
        "context"
        "sync"
        "time"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/metrics/prometheus"

        proDrv "github.com/prometheus/client_golang/prometheus"
)

var (
        prometheusRWLocker  = new(sync.RWMutex)
        prometheusRegisters = map[string]proDrv.Registerer{}
)

type _Prometheus struct {
        *abstract
}

func newPrometheusPush(ctx context.Context, appName, name, job string, interval time.Duration, conf *cfg) Sink <span class="cov10" title="11">{
        sink, err := prometheus.NewPrometheusPushSink(ctx, conf.c.Endpoint.Addresses[0], interval, job, conf.logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("initialize metrics component push mode prometheus failed: %s", err))</span>
        }
        <span class="cov10" title="11">return &amp;_Prometheus{abstract: newMetrics(ctx, appName, name, job, sink, conf)}</span>
}

func newPrometheusPull(ctx context.Context, appName, name, job string, conf *cfg) Sink <span class="cov0" title="0">{
        prometheusRWLocker.Lock()
        if _, ok := prometheusRegisters[appName]; !ok </span><span class="cov0" title="0">{
                prometheusRegisters[appName] = proDrv.NewRegistry()
        }</span>
        <span class="cov0" title="0">prometheusRWLocker.Unlock()

        sink, err := prometheus.NewPrometheusSinkFrom(prometheus.PrometheusOpts{
                Expiration:           prometheus.DefaultPrometheusOpts.Expiration,
                Registerer:           prometheusRegisters[appName],
                GaugeDefinitions:     nil,
                SummaryDefinitions:   nil,
                CounterDefinitions:   nil,
                HistogramDefinitions: nil,
                Name:                 job,
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("initialize metrics component pull mode prometheus failed: %s", err))</span>
        }

        <span class="cov0" title="0">return &amp;_Prometheus{abstract: newMetrics(ctx, appName, name, job, sink, conf)}</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package metrics

import (
        "context"
        "reflect"
        "time"

        "github.com/wfusion/gofusion/common/infra/metrics"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/log"
)

const (
        ErrDuplicatedName utils.Error = "duplicated metrics name"
)

var (
        customLoggerType  = reflect.TypeOf((*customLogger)(nil)).Elem()
        metricsLoggerType = reflect.TypeOf((*metrics.Logger)(nil)).Elem()
)

// The Sink interface is used to transmit metrics information
// to an external system
type Sink interface {
        // SetGauge A Gauge should retain the last value it is set to
        SetGauge(ctx context.Context, key []string, val float64, opts ...utils.OptionExtender)

        // IncrCounter Counters should accumulate values
        IncrCounter(ctx context.Context, key []string, val float64, opts ...utils.OptionExtender)

        // AddSample Samples are for timing information, where quantiles are used
        AddSample(ctx context.Context, key []string, val float64, opts ...utils.OptionExtender)

        // MeasureSince A better way to add timer samples
        MeasureSince(ctx context.Context, key []string, start time.Time, opts ...utils.OptionExtender)

        // IsEnableServiceLabel check if enable service label
        IsEnableServiceLabel() bool

        getProxy() any
        shutdown()
}

type Label struct {
        Key, Value string
}

// Conf metrics conf
//nolint: revive // struct tag too long issue
type Conf struct {
        Type                  metricsType       `yaml:"type" json:"type" toml:"type"`
        Mode                  mode              `yaml:"mode" json:"mode" toml:"mode"`
        Interval              string            `yaml:"interval" json:"interval" toml:"interval"`
        Endpoint              *endpointConf     `yaml:"endpoint" json:"endpoint" toml:"endpoint"`
        Labels                map[string]string `yaml:"labels" json:"labels" toml:"labels"`
        EnableServiceLabel    bool              `yaml:"enable_service_label" json:"enable_service_label" toml:"enable_service_label"`
        EnableInternalMetrics bool              `yaml:"enable_internal_metrics" json:"enable_internal_metrics" toml:"enable_internal_metrics"`
        QueueLimit            int               `yaml:"queue_limit" json:"queue_limit" toml:"queue_limit" default:"16384"`
        QueueConcurrency      int               `yaml:"queue_concurrency" json:"queue_concurrency" toml:"queue_concurrency"`
        Logger                string            `yaml:"logger" json:"logger" toml:"logger" default:"github.com/wfusion/gofusion/log/customlogger.metricsLogger"`
        LogInstance           string            `yaml:"log_instance" json:"log_instance" toml:"log_instance" default:"default"`
        EnableLogger          bool              `yaml:"enable_logger" json:"enable_logger" toml:"enable_logger" default:"false"`
}

type endpointConf struct {
        Addresses []string `yaml:"addresses" json:"addresses" toml:"addresses"`
}

type metricsType string

const (
        metricsTypeMock       metricsType = "mock"
        metricsTypePrometheus metricsType = "prometheus"
)

type mode string

const (
        modePull mode = "pull"
        modePush mode = "push"
)

type cfg struct {
        c          *Conf
        ctx        context.Context
        name       string
        appName    string
        interval   time.Duration
        initOption *config.InitOption
        logger     metrics.Logger
}

type option struct {
        prometheusBuckets []float64
        precision         bool
        timeout           time.Duration
        labels            []Label
}

func PrometheusBuckets(buckets []float64) utils.OptionFunc[option] <span class="cov8" title="30044">{
        return func(o *option) </span><span class="cov8" title="80032">{
                o.prometheusBuckets = buckets
        }</span>
}

func Precision() utils.OptionFunc[option] <span class="cov8" title="29991">{
        return func(o *option) </span><span class="cov8" title="79894">{
                o.precision = true
        }</span>
}

func Timeout(timeout time.Duration) utils.OptionFunc[option] <span class="cov1" title="1">{
        return func(o *option) </span><span class="cov1" title="3">{
                o.timeout = timeout
        }</span>
}

func WithoutTimeout() utils.OptionFunc[option] <span class="cov9" title="139743">{
        return func(o *option) </span><span class="cov10" title="357861">{
                o.timeout = -1
        }</span>
}

func Labels(labels []Label) utils.OptionFunc[option] <span class="cov9" title="100280">{
        return func(o *option) </span><span class="cov9" title="259790">{
                o.labels = labels
        }</span>
}

type customLogger interface {
        Init(log log.Logable, appName, name string)
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package mongo

import (
        "context"
        "log"
        "reflect"
        "syscall"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/infra/drivers/mongo"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/config"

        mgoEvt "go.mongodb.org/mongo-driver/event"
        mgoDrv "go.mongodb.org/mongo-driver/mongo"

        fmkLog "github.com/wfusion/gofusion/log"

        _ "github.com/wfusion/gofusion/log/customlogger"
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov10" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov5" title="5">{
                opt.AppName = optU.appName
        }</span>
        <span class="cov10" title="34">for name, conf := range confs </span><span class="cov6" title="10">{
                addInstance(ctx, name, conf, opt)
        }</span>

        <span class="cov10" title="34">return func() </span><span class="cov10" title="34">{
                rwlock.Lock()
                defer rwlock.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                if appInstances != nil </span><span class="cov7" title="12">{
                        for name, instance := range appInstances[opt.AppName] </span><span class="cov6" title="10">{
                                if err := instance.GetProxy().Disconnect(nil); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("%v [Gofusion] %s %s %s disconnect error: %s",
                                                pid, app, config.ComponentMongo, name, err)
                                }</span>
                        }
                        <span class="cov7" title="12">delete(appInstances, opt.AppName)</span>
                }
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov6" title="10">{
        var monitor *mgoEvt.CommandMonitor
        if utils.IsStrNotBlank(conf.LoggerConfig.Logger) </span><span class="cov6" title="10">{
                loggerType := inspect.TypeOf(conf.LoggerConfig.Logger)
                loggerValue := reflect.New(loggerType)
                if loggerValue.Type().Implements(customLoggerType) </span><span class="cov6" title="10">{
                        l := fmkLog.Use(conf.LoggerConfig.LogInstance, fmkLog.AppName(opt.AppName))
                        loggerValue.Interface().(customLogger).Init(l, opt.AppName, name)
                }</span>
                <span class="cov6" title="10">monitor = loggerValue.Interface().(logger).GetMonitor()</span>
        }

        // conf.Option.Password = config.CryptoDecryptFunc()(conf.Option.Password)
        <span class="cov6" title="10">mgoCli, err := mongo.Default.New(ctx, conf.Option,
                mongo.WithMonitor(monitor),
                mongo.WithPoolMonitor(&amp;mgoEvt.PoolMonitor{Event: metricsPoolMonitor(opt.AppName, name)}))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov6" title="10">rwlock.Lock()
        defer rwlock.Unlock()
        if appInstances == nil </span><span class="cov2" title="2">{
                appInstances = make(map[string]map[string]*instance)
        }</span>
        <span class="cov6" title="10">if appInstances[opt.AppName] == nil </span><span class="cov6" title="10">{
                appInstances[opt.AppName] = make(map[string]*instance)
        }</span>
        <span class="cov6" title="10">if _, ok := appInstances[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedName)</span>
        }
        <span class="cov6" title="10">appInstances[opt.AppName][name] = &amp;instance{mongo: mgoCli, name: name, database: conf.DB}

        // ioc
        if opt.DI != nil </span><span class="cov6" title="10">{
                opt.DI.MustProvide(
                        func() *mgoDrv.Database </span><span class="cov0" title="0">{
                                return Use(name, AppName(opt.AppName)).Database
                        }</span>,
                        di.Name(name),
                )
        }

        <span class="cov6" title="10">go startDaemonRoutines(ctx, opt.AppName, name, conf)</span>
}

func init() <span class="cov7" title="14">{
        config.AddComponent(config.ComponentMongo, Construct)
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">package mongo

import (
        "context"
        "log"
        "sync"
        "syscall"
        "time"

        "go.mongodb.org/mongo-driver/event"
        "go.uber.org/atomic"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/metrics"
)

var (
        metricsPoolIdleKey      = []string{"mongo", "idle"}
        metricsPoolInUseKey     = []string{"mongo", "inuse"}
        metricsPoolTotalKey     = []string{"mongo", "total"}
        metricsPoolLocker       = new(sync.RWMutex)
        metricsPoolInUseCounter = map[string]map[string]*atomic.Int64{}
        metricsPoolTotalCounter = map[string]map[string]*atomic.Int64{}
        metricsLatencyKey       = []string{"mongo", "latency"}
        metricsLatencyBuckets   = []float64{
                .1, .25, .5, .75, .90, .95, .99,
                1, 2.5, 5, 7.5, 9, 9.5, 9.9,
                10, 25, 50, 75, 90, 95, 99,
                100, 250, 500, 750, 900, 950, 990,
        }
)

func startDaemonRoutines(ctx context.Context, appName, name string, conf *Conf) <span class="cov5" title="10">{
        ticker := time.Tick(time.Second * 5)
        app := config.Use(appName).AppName()
        labels := []metrics.Label{
                {Key: "config", Value: name},
                {Key: "database", Value: conf.DB},
        }
        for </span><span class="cov5" title="10">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov5" title="10">
                        log.Printf("%v [Gofusion] %s %s %s metrics exited",
                                syscall.Getpid(), app, config.ComponentMongo, name)
                        return</span>
                case &lt;-ticker:<span class="cov0" title="0">
                        go metricMongoStats(ctx, appName, name, labels)
                        go metricMongoLatency(ctx, appName, name, labels)</span>
                }
        }
}

func metricMongoStats(ctx context.Context, appName, name string, labels []metrics.Label) <span class="cov0" title="0">{
        _, _ = utils.Catch(func() </span><span class="cov0" title="0">{
                var total, inuse int64
                _, err := utils.Catch(func() </span><span class="cov0" title="0">{
                        metricsPoolLocker.RLock()
                        defer metricsPoolLocker.RUnlock()
                        inuse = metricsPoolInUseCounter[appName][name].Load()
                        total = metricsPoolTotalCounter[appName][name].Load()
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">app := config.Use(appName).AppName()
                idleKey := append([]string{app}, metricsPoolIdleKey...)
                inuseKey := append([]string{app}, metricsPoolInUseKey...)
                totalKey := append([]string{app}, metricsPoolTotalKey...)
                ide := total - inuse
                for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                if m.IsEnableServiceLabel() </span><span class="cov0" title="0">{
                                        m.SetGauge(ctx, idleKey, float64(ide), metrics.Labels(labels))
                                        m.SetGauge(ctx, inuseKey, float64(inuse), metrics.Labels(labels))
                                        m.SetGauge(ctx, totalKey, float64(total), metrics.Labels(labels))
                                }</span> else<span class="cov0" title="0"> {
                                        m.SetGauge(ctx, metricsPoolIdleKey, float64(ide), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolInUseKey, float64(inuse), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolTotalKey, float64(total), metrics.Labels(labels))
                                }</span>
                        }
                }
        })
}

func metricMongoLatency(ctx context.Context, appName, name string, labels []metrics.Label) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov0" title="0"></span>

        }

        <span class="cov0" title="0">_, _ = utils.Catch(func() </span><span class="cov0" title="0">{
                rwlock.RLock()
                defer rwlock.RUnlock()
                instances, ok := appInstances[appName]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">instance, ok := instances[name]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">mgoCli := instance.GetProxy()
                begin := time.Now()
                if err := mgoCli.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">latency := float64(time.Since(begin)) / float64(time.Millisecond)
                latencyKey := append([]string{config.Use(appName).AppName()}, metricsLatencyKey...)
                for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                if m.IsEnableServiceLabel() </span><span class="cov0" title="0">{
                                        m.AddSample(ctx, latencyKey, latency,
                                                metrics.Labels(labels),
                                                metrics.PrometheusBuckets(metricsLatencyBuckets),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        m.AddSample(ctx, metricsLatencyKey, latency,
                                                metrics.Labels(labels),
                                                metrics.PrometheusBuckets(metricsLatencyBuckets),
                                        )
                                }</span>
                        }
                }
        })
}

func metricsPoolMonitor(appName, name string) func(evt *event.PoolEvent) <span class="cov5" title="10">{
        metricsPoolLocker.Lock()
        defer metricsPoolLocker.Unlock()
        if metricsPoolTotalCounter[appName] == nil </span><span class="cov3" title="3">{
                metricsPoolTotalCounter[appName] = make(map[string]*atomic.Int64)
        }</span>
        <span class="cov5" title="10">if metricsPoolTotalCounter[appName][name] == nil </span><span class="cov3" title="3">{
                metricsPoolTotalCounter[appName][name] = atomic.NewInt64(0)
        }</span>
        <span class="cov5" title="10">if metricsPoolInUseCounter[appName] == nil </span><span class="cov3" title="3">{
                metricsPoolInUseCounter[appName] = make(map[string]*atomic.Int64)
        }</span>
        <span class="cov5" title="10">if metricsPoolInUseCounter[appName][name] == nil </span><span class="cov3" title="3">{
                metricsPoolInUseCounter[appName][name] = atomic.NewInt64(0)
        }</span>

        <span class="cov5" title="10">inuse := metricsPoolInUseCounter[appName][name]
        total := metricsPoolTotalCounter[appName][name]
        return func(evt *event.PoolEvent) </span><span class="cov10" title="129">{
                switch evt.Type </span>{
                case event.PoolCreated:<span class="cov5" title="10"></span>
                case event.PoolReady:<span class="cov5" title="10"></span>
                case event.PoolCleared:<span class="cov0" title="0"></span>
                case event.PoolClosedEvent:<span class="cov5" title="10"></span>
                case event.ConnectionCreated:<span class="cov5" title="10">
                        total.Add(1)</span>
                case event.ConnectionReady:<span class="cov5" title="10"></span>
                case event.ConnectionClosed:<span class="cov5" title="10">
                        total.Add(-1)</span>
                case event.GetStarted:<span class="cov6" title="23"></span>
                case event.GetFailed:<span class="cov0" title="0"></span>
                case event.GetSucceeded:<span class="cov6" title="23">
                        inuse.Add(1)</span>
                case event.ConnectionReturned:<span class="cov6" title="23">
                        inuse.Add(-1)</span>
                }
        }

}
</pre>
		
		<pre class="file" id="file171" style="display: none">package mongo

import (
        "fmt"
        "sync"

        "go.mongodb.org/mongo-driver/bson/bsoncodec"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.mongodb.org/mongo-driver/mongo/readconcern"
        "go.mongodb.org/mongo-driver/mongo/readpref"
        "go.mongodb.org/mongo-driver/mongo/writeconcern"

        "github.com/wfusion/gofusion/common/infra/drivers/mongo"
        "github.com/wfusion/gofusion/common/utils"

        mgoDrv "go.mongodb.org/mongo-driver/mongo"
)

var (
        rwlock       = new(sync.RWMutex)
        appInstances map[string]map[string]*instance
)

type instance struct {
        name     string
        database string
        mongo    *mongo.Mongo
}

func (d *instance) GetProxy() *mgoDrv.Client <span class="cov3" title="10">{
        return d.mongo.GetProxy()
}</span>

func (d *instance) Database(opts ...*options.DatabaseOptions) *mgoDrv.Database <span class="cov9" title="1988">{
        return d.mongo.Database(d.database, opts...)
}</span>

type Mongo struct {
        *mgoDrv.Database
        Name string
}

type useOption struct {
        appName string

        // readConcern is the read concern to use for operations executed on the Database.
        // The default value is nil, which means that
        // the read concern of the Client used to configure the Database will be used.
        readConcern *readconcern.ReadConcern

        // writeConcern is the write concern to use for operations executed on the Database.
        // The default value is nil, which means that the
        // write concern of the Client used to configure the Database will be used.
        writeConcern *writeconcern.WriteConcern

        // readPreference is the read preference to use for operations executed on the Database.
        // The default value is nil, which means that
        // the read preference of the Client used to configure the Database will be used.
        readPreference *readpref.ReadPref

        // bsonOptions configures optional BSON marshaling and unmarshaling
        // behavior.
        bsonOptions *options.BSONOptions

        // registry is the BSON registry to marshal and unmarshal documents for operations executed on the Database.
        // The default value is nil,
        // which means that the registry of the Client used to configure the Database will be used.
        registry *bsoncodec.Registry
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov9" title="1961">{
        return func(o *useOption) </span><span class="cov9" title="1898">{
                o.appName = name
        }</span>
}

func ReadConcern(readConcern *readconcern.ReadConcern) utils.OptionFunc[useOption] <span class="cov0" title="0">{
        return func(o *useOption) </span><span class="cov0" title="0">{
                o.readConcern = readConcern
        }</span>
}
func WriteConcern(writeConcern *writeconcern.WriteConcern) utils.OptionFunc[useOption] <span class="cov0" title="0">{
        return func(o *useOption) </span><span class="cov0" title="0">{
                o.writeConcern = writeConcern
        }</span>
}
func ReadPreference(readPreference *readpref.ReadPref) utils.OptionFunc[useOption] <span class="cov0" title="0">{
        return func(o *useOption) </span><span class="cov0" title="0">{
                o.readPreference = readPreference
        }</span>
}
func BsonOptions(bsonOptions *options.BSONOptions) utils.OptionFunc[useOption] <span class="cov0" title="0">{
        return func(o *useOption) </span><span class="cov0" title="0">{
                o.bsonOptions = bsonOptions
        }</span>
}
func Registry(registry *bsoncodec.Registry) utils.OptionFunc[useOption] <span class="cov0" title="0">{
        return func(o *useOption) </span><span class="cov0" title="0">{
                o.registry = registry
        }</span>
}

func Use(name string, opts ...utils.OptionExtender) *Mongo <span class="cov9" title="1961">{
        opt := utils.ApplyOptions[useOption](opts...)
        dbOpt := options.
                Database().
                SetReadConcern(opt.readConcern).
                SetWriteConcern(opt.writeConcern).
                SetReadPreference(opt.readPreference).
                SetBSONOptions(opt.bsonOptions).
                SetRegistry(opt.registry)

        rwlock.RLock()
        defer rwlock.RUnlock()
        instances, ok := appInstances[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("mongo database instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov10" title="1999">instance, ok := instances[name]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Errorf("mongo database instance not found for name: %s", name))</span>
        }
        <span class="cov9" title="1984">return &amp;Mongo{Database: instance.Database(dbOpt), Name: name}</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package mq

import (
        "context"
        "fmt"
        "strings"

        "github.com/pkg/errors"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/infra/watermill/pubsub/amqp"
)

func newAMQP(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) (
        pub Publisher, sub Subscriber) <span class="cov7" title="6">{
        if conf.Producer </span><span class="cov7" title="6">{
                pub = newAMQPPublisher(ctx, appName, name, conf, logger)
        }</span>

        <span class="cov7" title="6">if conf.Consumer </span><span class="cov7" title="6">{
                sub = newAMQPSubscriber(ctx, appName, name, conf, logger)
        }</span>

        <span class="cov7" title="6">return</span>
}

type _AMQPPublisher struct {
        *abstractMQ
        publisher *amqp.Publisher
}

func newAMQPPublisher(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) Publisher <span class="cov7" title="6">{
        ep := parseAMQPEndpoint(conf)

        var genFunc amqp.QueueNameGenerator
        if utils.IsStrNotBlank(conf.ConsumerGroup) </span><span class="cov7" title="6">{
                genFunc = amqp.GenerateQueueNameTopicNameWithSuffix(conf.ConsumerGroup)
        }</span> else<span class="cov0" title="0"> {
                genFunc = amqp.GenerateQueueNameTopicName
        }</span>

        <span class="cov7" title="6">var cfg amqp.Config
        if conf.Persistent </span><span class="cov7" title="6">{
                cfg = amqp.NewDurablePubSubConfig(ep, genFunc)
        }</span> else<span class="cov0" title="0"> {
                cfg = amqp.NewNonDurablePubSubConfig(ep, genFunc)
        }</span>

        <span class="cov7" title="6">cfg.Marshaler = amqp.DefaultMarshaler{
                NotPersistentDeliveryMode: !conf.Persistent,
                AppID:                     config.Use(appName).AppName(),
        }

        pub, err := amqp.NewPublisher(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component amqp publisher failed: %s", err))</span>
        }

        <span class="cov7" title="6">return &amp;_AMQPPublisher{
                abstractMQ: newPub(ctx, pub, appName, name, conf, logger),
                publisher:  pub,
        }</span>
}

func (a *_AMQPPublisher) close() (err error) <span class="cov7" title="6">{
        return a.publisher.Close()
}</span>

type _AMQPSubscriber struct {
        *abstractMQ
        subscriber *amqp.Subscriber
}

func newAMQPSubscriber(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) Subscriber <span class="cov7" title="6">{
        ep := parseAMQPEndpoint(conf)

        var genFunc amqp.QueueNameGenerator
        if utils.IsStrNotBlank(conf.ConsumerGroup) </span><span class="cov7" title="6">{
                genFunc = amqp.GenerateQueueNameTopicNameWithSuffix(conf.ConsumerGroup)
        }</span> else<span class="cov0" title="0"> {
                genFunc = amqp.GenerateQueueNameTopicName
        }</span>

        <span class="cov7" title="6">var cfg amqp.Config
        if conf.Persistent </span><span class="cov7" title="6">{
                cfg = amqp.NewDurablePubSubConfig(ep, genFunc)
        }</span> else<span class="cov0" title="0"> {
                cfg = amqp.NewNonDurablePubSubConfig(ep, genFunc)
        }</span>

        <span class="cov7" title="6">sub, err := amqp.NewSubscriber(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component amqp subscriber failed: %s", err))</span>
        }

        <span class="cov7" title="6">utils.MustSuccess(sub.SubscribeInitialize(conf.Topic))

        return &amp;_AMQPSubscriber{
                abstractMQ: newSub(ctx, sub, appName, name, conf, logger),
                subscriber: sub,
        }</span>
}

func (a *_AMQPSubscriber) close() (err error) <span class="cov7" title="6">{
        return a.subscriber.Close()
}</span>

func parseAMQPEndpoint(conf *Conf) (result string) <span class="cov10" title="12">{
        hasUser := utils.IsStrNotBlank(conf.Endpoint.User)
        hasPassword := utils.IsStrNotBlank(conf.Endpoint.Password)
        if hasUser &amp;&amp; hasPassword </span><span class="cov10" title="12">{
                addr := strings.TrimPrefix(conf.Endpoint.Addresses[0], "amqp://")
                result = fmt.Sprintf("amqp://%s:%s@%s", conf.Endpoint.User, conf.Endpoint.Password, addr)
        }</span> else<span class="cov0" title="0"> if hasUser </span><span class="cov0" title="0">{
                addr := strings.TrimPrefix(conf.Endpoint.Addresses[0], "amqp://")
                result = fmt.Sprintf("amqp://%s@%s", conf.Endpoint.User, addr)
        }</span> else<span class="cov0" title="0"> {
                addr := strings.TrimPrefix(conf.Endpoint.Addresses[0], "amqp://")
                result = fmt.Sprintf("amqp://%s", addr)
        }</span>

        <span class="cov10" title="12">return</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package mq

import (
        "context"
        "log"
        "reflect"
        "sync"
        "syscall"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/config"

        fmkLog "github.com/wfusion/gofusion/log"

        _ "github.com/wfusion/gofusion/log/customlogger"
)

var (
        locker      sync.RWMutex
        subscribers = map[string]map[string]Subscriber{}
        publishers  = map[string]map[string]Publisher{}
        routers     = map[string]map[string]IRouter{}
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov5" title="36">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov2" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov5" title="36">for name, conf := range confs </span><span class="cov5" title="56">{
                addInstance(ctx, name, conf, opt)
        }</span>

        <span class="cov5" title="36">return func() </span><span class="cov5" title="34">{
                locker.Lock()
                defer locker.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                if routers != nil </span><span class="cov5" title="34">{
                        for name, router := range routers[opt.AppName] </span><span class="cov5" title="56">{
                                log.Printf("%v [Gofusion] %s %s %s router exiting...",
                                        pid, app, config.ComponentMessageQueue, name)
                                if err := router.close(); err == nil </span><span class="cov5" title="56">{
                                        log.Printf("%v [Gofusion] %s %s %s router exited",
                                                pid, app, config.ComponentMessageQueue, name)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("%v [Gofusion] %s %s %s router exit failed: %s",
                                                pid, app, config.ComponentMessageQueue, name, err)
                                }</span>
                        }
                        <span class="cov5" title="34">delete(routers, opt.AppName)</span>
                }

                <span class="cov5" title="34">if publishers != nil </span><span class="cov5" title="34">{
                        for name, publisher := range publishers[opt.AppName] </span><span class="cov5" title="56">{
                                log.Printf("%v [Gofusion] %s %s %s publisher exiting...",
                                        pid, app, config.ComponentMessageQueue, name)
                                if err := publisher.close(); err == nil </span><span class="cov5" title="56">{
                                        log.Printf("%v [Gofusion] %s %s %s publisher exited",
                                                pid, app, config.ComponentMessageQueue, name)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("%v [Gofusion] %s %s %s publisher exit failed: %s",
                                                pid, app, config.ComponentMessageQueue, name, err)
                                }</span>
                        }
                        <span class="cov5" title="34">delete(publishers, opt.AppName)</span>
                }

                <span class="cov5" title="34">if subscribers != nil </span><span class="cov5" title="34">{
                        for name, subscriber := range subscribers[opt.AppName] </span><span class="cov5" title="56">{
                                log.Printf("%v [Gofusion] %s %s %s subscriber exiting...",
                                        pid, app, config.ComponentMessageQueue, name)
                                if err := subscriber.close(); err == nil </span><span class="cov5" title="56">{
                                        log.Printf("%v [Gofusion] %s %s %s subscriber exited",
                                                pid, app, config.ComponentMessageQueue, name)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("%v [Gofusion] %s %s %s subscriber exit failed: %s",
                                                pid, app, config.ComponentMessageQueue, name, err)
                                }</span>
                        }
                        <span class="cov5" title="34">delete(subscribers, opt.AppName)</span>
                }
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov5" title="56">{
        var logger watermill.LoggerAdapter
        if utils.IsStrNotBlank(conf.Logger) </span><span class="cov5" title="54">{
                loggerType := inspect.TypeOf(conf.Logger)
                loggerValue := reflect.New(loggerType)
                if loggerValue.Type().Implements(customLoggerType) </span><span class="cov5" title="54">{
                        l := fmkLog.Use(conf.LogInstance, fmkLog.AppName(opt.AppName))
                        loggerValue.Interface().(customLogger).Init(l, opt.AppName, name)
                }</span>
                <span class="cov5" title="54">logger = loggerValue.Convert(watermillLoggerType).Interface().(watermill.LoggerAdapter)</span>
        }

        <span class="cov5" title="56">if conf.ConsumerConcurrency &lt; 1 </span><span class="cov1" title="1">{
                conf.ConsumerConcurrency = 1
        }</span>

        <span class="cov5" title="56">var (
                puber Publisher
                suber Subscriber
        )
        newFunc, ok := newFn[conf.Type]
        if ok </span><span class="cov5" title="56">{
                puber, suber = newFunc(ctx, opt.AppName, name, conf, logger)
        }</span> else<span class="cov0" title="0"> {
                panic(errors.Errorf("unknown message queue type: %+v", conf.Type))</span>
        }

        <span class="cov5" title="56">locker.Lock()
        defer locker.Unlock()
        if suber != nil </span><span class="cov5" title="56">{
                if subscribers == nil </span><span class="cov0" title="0">{
                        subscribers = make(map[string]map[string]Subscriber)
                }</span>
                <span class="cov5" title="56">if subscribers[opt.AppName] == nil </span><span class="cov3" title="12">{
                        subscribers[opt.AppName] = make(map[string]Subscriber)
                }</span>
                <span class="cov5" title="56">if _, ok := subscribers[name]; ok </span><span class="cov0" title="0">{
                        panic(ErrDuplicatedSubscriberName)</span>
                }
                <span class="cov5" title="56">subscribers[opt.AppName][name] = suber

                if routers == nil </span><span class="cov0" title="0">{
                        routers = make(map[string]map[string]IRouter)
                }</span>
                <span class="cov5" title="56">if routers[opt.AppName] == nil </span><span class="cov3" title="12">{
                        routers[opt.AppName] = make(map[string]IRouter)
                }</span>
                <span class="cov5" title="56">if _, ok := routers[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                        panic(ErrDuplicatedRouterName)</span>
                }
                <span class="cov5" title="56">routers[opt.AppName][name] = newRouter(ctx, opt.AppName, name, conf, puber, suber, logger)

                // ioc
                if opt.DI != nil </span><span class="cov5" title="54">{
                        opt.DI.
                                MustProvide(func() Subscriber </span><span class="cov0" title="0">{ return sub(name, AppName(opt.AppName)) }</span>, di.Name(name)).
                                MustProvide(func() IRouter <span class="cov0" title="0">{ return Use(name, AppName(opt.AppName)) }</span>, di.Name(name))
                }

        }

        <span class="cov5" title="56">if puber != nil </span><span class="cov5" title="56">{
                if publishers == nil </span><span class="cov0" title="0">{
                        publishers = make(map[string]map[string]Publisher)
                }</span>
                <span class="cov5" title="56">if publishers[opt.AppName] == nil </span><span class="cov3" title="12">{
                        publishers[opt.AppName] = make(map[string]Publisher)
                }</span>
                <span class="cov5" title="56">if _, ok := publishers[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                        panic(ErrDuplicatedPublisherName)</span>
                }
                <span class="cov5" title="56">publishers[opt.AppName][name] = puber

                // ioc
                if opt.DI != nil </span><span class="cov5" title="54">{
                        opt.DI.MustProvide(func() Publisher </span><span class="cov0" title="0">{ return Pub(name, AppName(opt.AppName)) }</span>, di.Name(name))
                }
        }
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov9" title="2002">{
        return func(o *useOption) </span><span class="cov9" title="1945">{
                o.appName = name
        }</span>
}

func sub(name string, opts ...utils.OptionExtender) Subscriber <span class="cov0" title="0">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        subscribers, ok := subscribers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq subscriber instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov0" title="0">subscriber, ok := subscribers[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq subscriber instance not found for name: %s", name))</span>
        }
        <span class="cov0" title="0">return subscriber</span>
}

func Pub(name string, opts ...utils.OptionExtender) Publisher <span class="cov5" title="32">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        publishers, ok := publishers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq publisher instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov5" title="32">publisher, ok := publishers[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq publisher instance not found for name: %s", name))</span>
        }
        <span class="cov5" title="32">return publisher</span>
}

func Sub(name string, opts ...utils.OptionExtender) Subscriber <span class="cov4" title="16">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        subscribers, ok := subscribers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq subscriber instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov4" title="16">subscriber, ok := subscribers[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq subscriber instance not found for name: %s", name))</span>
        }
        <span class="cov4" title="16">return subscriber</span>
}

func Use(name string, opts ...utils.OptionExtender) IRouter <span class="cov9" title="1905">{
        opt := utils.ApplyOptions[useOption](opts...)

        locker.RLock()
        defer locker.RUnlock()
        routers, ok := routers[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq router instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov9" title="2025">r, ok := routers[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("mq router instance not found for name: %s", name))</span>
        }
        <span class="cov10" title="2029">return r</span>
}

func init() <span class="cov4" title="14">{
        config.AddComponent(config.ComponentMessageQueue, Construct)
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">package mq

import (
        "context"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"

        mw "github.com/wfusion/gofusion/common/infra/watermill/message"
)

const (
        keyEntityID                  = "entity_id"
        keyEventType                 = "event_type"
        eventHandlerSignature        = "github.com/wfusion/gofusion/mq.eventHandler["
        eventHandlerWithMsgSignature = "github.com/wfusion/gofusion/mq.eventHandlerWithMsg["
        mqPackageSignFormat          = "github.com/wfusion/gofusion/mq.%s"
)

func isEventHandler(f any) bool <span class="cov7" title="44">{
        sig := formatEventHandlerSignature(f)
        return strings.HasPrefix(sig, eventHandlerSignature) || strings.HasPrefix(sig, eventHandlerWithMsgSignature)
}</span>
func formatEventHandlerSignature(f any) string <span class="cov7" title="44">{
        ft, ok := f.(reflect.Type)
        if !ok </span><span class="cov7" title="44">{
                fv, ok := f.(reflect.Value)
                if ok </span><span class="cov7" title="44">{
                        ft = fv.Type()
                }</span> else<span class="cov0" title="0"> {
                        ft = reflect.TypeOf(f)
                }</span>
        }

        <span class="cov7" title="44">return ft.PkgPath() + "." + ft.Name()</span>
}

type eventHandler[T eventual] func(ctx context.Context, event Event[T]) error
type eventHandlerWithMsg[T eventual] func(ctx context.Context, event Event[T]) ([]Message, error)

func EventHandler[T eventual](hdr eventHandler[T]) eventHandler[T] <span class="cov4" title="8">{
        return func(ctx context.Context, event Event[T]) error </span><span class="cov6" title="40">{
                // TODO: dedup &amp; discard expired event
                return hdr(ctx, event)
        }</span>
}

func EventHandlerWithMsg[T eventual](hdr eventHandlerWithMsg[T]) eventHandlerWithMsg[T] <span class="cov0" title="0">{
        return func(ctx context.Context, event Event[T]) ([]Message, error) </span><span class="cov0" title="0">{
                // TODO: dedup &amp; discard expired event
                return hdr(ctx, event)
        }</span>
}

func NewEventPublisherDI[T eventual](name string, opts ...utils.OptionExtender) func() EventPublisher[T] <span class="cov0" title="0">{
        return func() EventPublisher[T] </span><span class="cov0" title="0">{
                return NewEventPublisher[T](name, opts...)
        }</span>
}

func NewEventPublisher[T eventual](name string, opts ...utils.OptionExtender) EventPublisher[T] <span class="cov5" title="16">{
        opt := utils.ApplyOptions[useOption](opts...)
        publisher := Pub(name, AppName(opt.appName))
        abstractMq := inspect.GetField[*abstractMQ](publisher, "abstractMQ")
        return &amp;eventPublisher[T]{abstractMQ: abstractMq}
}</span>

type eventPublisher[T eventual] struct {
        *abstractMQ
}

func (e *eventPublisher[T]) PublishEvent(ctx context.Context, opts ...utils.OptionExtender) (err error) <span class="cov7" title="80">{
        opt := utils.ApplyOptions[pubOption](opts...)
        optT := utils.ApplyOptions[eventPubOption[T]](opts...)
        msgs := make([]*mw.Message, 0, len(optT.events))
        for _, evt := range optT.events </span><span class="cov7" title="80">{
                msg, err := e.abstractMQ.newObjectMessage(ctx, evt.(*event[T]).pd, opt)
                if msg != nil </span><span class="cov7" title="78">{
                        msg.Metadata[keyEntityID] = evt.ID()
                        msg.Metadata[keyEventType] = evt.Type()
                }</span>
                <span class="cov7" title="80">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="80">msgs = append(msgs, msg)</span>
        }
        <span class="cov7" title="79">return e.abstractMQ.Publish(ctx, messages(msgs...))</span>
}

type eventSubscriber[T eventual] struct {
        *abstractMQ
        evtType string
}

func NewEventSubscriberDI[T eventual](name string, opts ...utils.OptionExtender) func() EventSubscriber[T] <span class="cov0" title="0">{
        return func() EventSubscriber[T] </span><span class="cov0" title="0">{
                return NewEventSubscriber[T](name, opts...)
        }</span>
}

func NewEventSubscriber[T eventual](name string, opts ...utils.OptionExtender) EventSubscriber[T] <span class="cov4" title="8">{
        opt := utils.ApplyOptions[useOption](opts...)
        subscriber := Sub(name, AppName(opt.appName))
        abstractMq := inspect.GetField[*abstractMQ](subscriber, "abstractMQ")

        var m reflect.Value
        for tv := reflect.ValueOf(new(T)); tv.Kind() == reflect.Ptr; tv = tv.Elem() </span><span class="cov5" title="16">{
                if m = tv.MethodByName("EventType"); m.IsValid() </span><span class="cov4" title="8">{
                        break</span>
                }
        }
        <span class="cov4" title="8">eventType := m.Call(nil)[0].String()
        return &amp;eventSubscriber[T]{abstractMQ: abstractMq, evtType: eventType}</span>
}

func (e *eventSubscriber[T]) SubscribeEvent(ctx context.Context, opts ...utils.OptionExtender) (
        dst &lt;-chan Event[T], err error) <span class="cov4" title="8">{
        opt := utils.ApplyOptions[subOption](opts...)
        out := make(chan Event[T], opt.channelLength)
        r := Use(e.name, AppName(e.appName)).(*router)
        r.Handle(
                e.evtType,
                eventHandlerWithMsg[T](func(ctx context.Context, event Event[T]) (msgs []Message, err error) </span><span class="cov6" title="40">{
                        select </span>{
                        case out &lt;- event:<span class="cov6" title="40"></span>
                        case &lt;-r.Router.ClosingInProgressCh:<span class="cov0" title="0">
                                event.Nack()
                                e.logger.Info(fmt.Sprintf("event subscriber %s exited", e.name), nil)
                                return</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                event.Nack()
                                e.logger.Info(fmt.Sprintf(
                                        "event subscriber %s exited with a message nacked when business ctx done", e.name),
                                        watermill.LogFields{watermill.ContextLogFieldKey: ctx})
                                return</span>
                        case &lt;-e.ctx.Done():<span class="cov0" title="0">
                                event.Nack()
                                e.logger.Info(fmt.Sprintf(
                                        "event subscriber %s exited with a message nacked when app ctx done", e.name),
                                        watermill.LogFields{watermill.ContextLogFieldKey: ctx})
                                return</span>
                        }

                        <span class="cov6" title="40">msgs = append(msgs,
                                &amp;message{Message: &amp;mw.Message{Metadata: mw.Metadata{watermill.MessageRouterAck: ""}}})
                        return</span>
                }),
                handleEventSubscriber(),
        )
        <span class="cov4" title="8">return out, err</span>
}

type eventual interface{ EventType() string }
type Event[T eventual] interface {
        ID() string
        Type() string
        CreatedAt() time.Time
        UpdatedAt() time.Time
        DeletedAt() time.Time
        Payload() T
        Context() context.Context
        Ack() bool
        Nack() bool
}

func NewEvent[T eventual](id string, createdAt, updatedAt, deletedAt time.Time, payload T) Event[T] <span class="cov0" title="0">{
        return newEvent[T](id, createdAt, updatedAt, deletedAt, payload)
}</span>
func UntimedEvent[T eventual](id string, payload T) Event[T] <span class="cov7" title="80">{
        return newEvent[T](id, time.Time{}, time.Time{}, time.Time{}, payload)
}</span>
func EventCreated[T eventual](id string, createdAt time.Time, payload T) Event[T] <span class="cov0" title="0">{
        return newEvent[T](id, createdAt, time.Time{}, time.Time{}, payload)
}</span>
func EventUpdated[T eventual](id string, updatedAt time.Time, payload T) Event[T] <span class="cov0" title="0">{
        return newEvent[T](id, time.Time{}, updatedAt, time.Time{}, payload)
}</span>
func EventDeleted[T eventual](id string, deletedAt time.Time, payload T) Event[T] <span class="cov0" title="0">{
        return newEvent[T](id, time.Time{}, time.Time{}, deletedAt, payload)
}</span>

type eventPayload[T eventual] struct {
        I  string `json:"i,omitempty"`
        T  string `json:"t,omitempty"`
        P  T      `json:"p,omitempty"`
        C  string `json:"c,omitempty"`
        CL string `json:"cl,omitempty"`
        U  string `json:"u,omitempty"`
        UL string `json:"ul,omitempty"`
        D  string `json:"d,omitempty"`
        DL string `json:"dl,omitempty"`
        N  int64  `json:"n,omitempty"`
}
type event[T eventual] struct {
        ctx    context.Context
        ackfn  func() bool
        nackfn func() bool
        pd     *eventPayload[T]
}

func newEvent[T eventual](id string, createdAt, updatedAt, deletedAt time.Time, payload T) Event[T] <span class="cov7" title="80">{
        return &amp;event[T]{
                pd: &amp;eventPayload[T]{
                        I:  id,
                        T:  payload.EventType(),
                        P:  payload,
                        C:  createdAt.Format(time.RFC3339Nano),
                        CL: createdAt.Location().String(),
                        U:  updatedAt.Format(time.RFC3339Nano),
                        UL: updatedAt.Location().String(),
                        D:  deletedAt.Format(time.RFC3339Nano),
                        DL: deletedAt.Location().String(),
                        N:  time.Now().UnixNano(),
                },
        }
}</span>
func (e *event[T]) ID() string               <span class="cov10" title="280">{ return e.pd.I }</span>
func (e *event[T]) Type() string             <span class="cov9" title="160">{ return e.pd.T }</span>
func (e *event[T]) Payload() T               <span class="cov7" title="80">{ return e.pd.P }</span>
func (e *event[T]) CreatedAt() time.Time     <span class="cov0" title="0">{ return e.toTime(e.pd.C, e.pd.CL) }</span>
func (e *event[T]) UpdatedAt() time.Time     <span class="cov0" title="0">{ return e.toTime(e.pd.U, e.pd.UL) }</span>
func (e *event[T]) DeletedAt() time.Time     <span class="cov0" title="0">{ return e.toTime(e.pd.D, e.pd.DL) }</span>
func (e *event[T]) Context() context.Context <span class="cov6" title="40">{ return e.ctx }</span>
func (e *event[T]) Ack() bool <span class="cov6" title="40">{
        if e.ackfn != nil </span><span class="cov6" title="40">{
                return e.ackfn()
        }</span>
        <span class="cov0" title="0">return true</span>
}
func (e *event[T]) Nack() bool <span class="cov0" title="0">{
        if e.nackfn != nil </span><span class="cov0" title="0">{
                return e.nackfn()
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (e *event[T]) toTime(timestr, locationstr string) (t time.Time) <span class="cov0" title="0">{
        loc, err := time.LoadLocation(locationstr)
        if err != nil </span><span class="cov0" title="0">{
                loc = constant.DefaultLocation()
        }</span>
        <span class="cov0" title="0">t, _ = time.ParseInLocation(time.RFC3339Nano, timestr, loc)
        return</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package mq

import (
        "context"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/infra/watermill/pubsub/gochannel"
        "github.com/wfusion/gofusion/config"
)

func newGoChannel(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) (
        pub Publisher, sub Subscriber) <span class="cov7" title="8">{
        cfg := gochannel.Config{
                OutputChannelBuffer:            int64(conf.ConsumerConcurrency),
                Persistent:                     conf.Persistent,
                ConsumerGroup:                  conf.ConsumerGroup,
                BlockPublishUntilSubscriberAck: false,
                AppID:                          config.Use(appName).AppName(),
        }

        native := gochannel.NewGoChannel(cfg, logger)
        if conf.Producer </span><span class="cov7" title="8">{
                pub = &amp;goChannel{
                        abstractMQ: newPub(ctx, native, appName, name, conf, logger),
                        ch:         native,
                }
        }</span>

        <span class="cov7" title="8">if conf.Consumer </span><span class="cov7" title="8">{
                sub = &amp;goChannel{
                        abstractMQ: newSub(ctx, native, appName, name, conf, logger),
                        ch:         native,
                }
        }</span>
        <span class="cov7" title="8">return</span>
}

type goChannel struct {
        *abstractMQ
        ch *gochannel.GoChannel
}

func (g *goChannel) close() (err error) <span class="cov10" title="16">{ return g.ch.Close() }</span>
</pre>
		
		<pre class="file" id="file176" style="display: none">package mq

import (
        "context"
        "strings"
        "time"

        "github.com/IBM/sarama"
        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/infra/watermill/pubsub/kafka"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
)

func newKafka(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) (
        pub Publisher, sub Subscriber) <span class="cov7" title="6">{
        if conf.Producer </span><span class="cov7" title="6">{
                pub = newKafkaPublisher(ctx, appName, name, conf, logger)
        }</span>

        <span class="cov7" title="6">if conf.Consumer </span><span class="cov7" title="6">{
                sub = newKafkaSubscriber(ctx, appName, name, conf, logger)
        }</span>

        <span class="cov7" title="6">return</span>
}

type kafkaPublisher struct {
        *abstractMQ
        publisher *kafka.Publisher
}

func newKafkaPublisher(ctx context.Context, appName, name string,
        conf *Conf, logger watermill.LoggerAdapter) Publisher <span class="cov7" title="6">{
        cfg := kafka.PublisherConfig{
                Brokers:               conf.Endpoint.Addresses,
                Marshaler:             kafka.DefaultMarshaler{AppID: config.Use(appName).AppName()},
                OverwriteSaramaConfig: parseKafkaConf(appName, conf),
        }

        pub, err := kafka.NewPublisher(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component kafka publisher failed: %s", err))</span>
        }

        <span class="cov7" title="6">return &amp;kafkaPublisher{
                abstractMQ: newPub(ctx, pub, appName, name, conf, logger),
                publisher:  pub,
        }</span>
}

func (k *kafkaPublisher) close() (err error) <span class="cov7" title="6">{
        return k.publisher.Close()
}</span>

type kafkaSubscriber struct {
        *abstractMQ
        subscriber *kafka.Subscriber
}

func newKafkaSubscriber(ctx context.Context, appName, name string,
        conf *Conf, logger watermill.LoggerAdapter) Subscriber <span class="cov7" title="6">{
        cfg := kafka.SubscriberConfig{
                Brokers:               conf.Endpoint.Addresses,
                Unmarshaler:           kafka.DefaultMarshaler{AppID: config.Use(appName).AppName()},
                OverwriteSaramaConfig: parseKafkaConf(appName, conf),
                ConsumerGroup:         conf.ConsumerGroup,
                NackResendSleep:       100 * time.Millisecond,
                ReconnectRetrySleep:   time.Second,
                InitializeTopicDetails: &amp;sarama.TopicDetail{
                        NumPartitions:     -1,
                        ReplicationFactor: -1,
                        ReplicaAssignment: nil,
                        ConfigEntries:     nil,
                },
        }

        sub, err := kafka.NewSubscriber(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component kafka subscriber failed: %s", err))</span>
        }

        <span class="cov7" title="6">if err = sub.SubscribeInitialize(conf.Topic); err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component kafka subscriber intialize: %s", err))</span>
        }

        <span class="cov7" title="6">return &amp;kafkaSubscriber{
                abstractMQ: newSub(ctx, sub, appName, name, conf, logger),
                subscriber: sub,
        }</span>
}

func (k *kafkaSubscriber) close() (err error) <span class="cov7" title="6">{
        return k.subscriber.Close()
}</span>

func parseKafkaConf(appName string, conf *Conf) (saramaCfg *sarama.Config) <span class="cov10" title="12">{
        saramaCfg = sarama.NewConfig()
        saramaCfg.Producer.Return.Errors = true
        saramaCfg.Producer.Return.Successes = true
        saramaCfg.Producer.RequiredAcks = sarama.WaitForLocal
        saramaCfg.Producer.Retry.Max = 10
        saramaCfg.Consumer.Fetch.Default = 16 * 1024 * 1024 // 16mb, default is 1mb
        saramaCfg.Consumer.Offsets.Initial = sarama.OffsetNewest
        saramaCfg.Consumer.Offsets.AutoCommit.Enable = true
        saramaCfg.Consumer.Offsets.AutoCommit.Interval = time.Second // only work when auto commit disabled
        saramaCfg.Consumer.Return.Errors = true
        saramaCfg.Metadata.Retry.Backoff = time.Second * 2
        saramaCfg.ClientID = config.Use(appName).AppName()
        if utils.IsStrNotBlank(conf.Endpoint.Version) </span><span class="cov10" title="12">{
                saramaCfg.Version = utils.Must(sarama.ParseKafkaVersion(conf.Endpoint.Version))
        }</span>
        <span class="cov10" title="12">if utils.IsStrNotBlank(conf.Endpoint.User) </span><span class="cov0" title="0">{
                saramaCfg.Net.SASL.Enable = true
                saramaCfg.Net.SASL.User = conf.Endpoint.User
                saramaCfg.Net.SASL.Password = conf.Endpoint.Password
                saramaCfg.Net.SASL.Mechanism = sarama.SASLTypePlaintext
                switch </span>{
                case strings.EqualFold(conf.Endpoint.AuthType, sarama.SASLTypeSCRAMSHA256):<span class="cov0" title="0">
                        saramaCfg.Net.SASL.Mechanism = sarama.SASLTypeSCRAMSHA256</span>
                case strings.EqualFold(conf.Endpoint.AuthType, sarama.SASLTypeSCRAMSHA512):<span class="cov0" title="0">
                        saramaCfg.Net.SASL.Mechanism = sarama.SASLTypeSCRAMSHA512</span>
                case strings.EqualFold(conf.Endpoint.AuthType, sarama.SASLTypeOAuth):<span class="cov0" title="0">
                        saramaCfg.Net.SASL.Mechanism = sarama.SASLTypeOAuth
                        saramaCfg.Net.SASL.TokenProvider = &amp;kafkaOAuthProvider{token: saramaCfg.Net.SASL.Password}</span>
                }
        }
        <span class="cov10" title="12">return</span>
}

type kafkaOAuthProvider struct {
        token string
}

func (k *kafkaOAuthProvider) Token() (*sarama.AccessToken, error) <span class="cov0" title="0">{
        return &amp;sarama.AccessToken{Token: k.token}, nil
}</span>
</pre>
		
		<pre class="file" id="file177" style="display: none">package mq

import (
        "context"
        "fmt"
        "syscall"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"

        fmkCtx "github.com/wfusion/gofusion/context"
)

func logError(ctx context.Context, l watermill.LoggerAdapter, app, n, m string, args ...any) <span class="cov0" title="0">{
        l.Error(formatLogMsg(app, n, m, args...), nil, formatFields(ctx))
}</span>
func logInfo(ctx context.Context, l watermill.LoggerAdapter, app, n, m string, args ...any) <span class="cov0" title="0">{
        l.Info(formatLogMsg(app, n, m, args...), formatFields(ctx))
}</span>
func logDebug(ctx context.Context, l watermill.LoggerAdapter, app, n, m string, args ...any) <span class="cov0" title="0">{
        l.Debug(formatLogMsg(app, n, m, args...), formatFields(ctx))
}</span>
func logTrace(ctx context.Context, l watermill.LoggerAdapter, app, n, m string, args ...any) <span class="cov0" title="0">{
        l.Trace(formatLogMsg(app, n, m, args...), formatFields(ctx))
}</span>

func formatFields(ctx context.Context) (fs watermill.LogFields) <span class="cov0" title="0">{
        fs = make(watermill.LogFields, 4)
        if userID := fmkCtx.GetUserID(ctx); utils.IsStrNotBlank(userID) </span><span class="cov0" title="0">{
                fs["user_id"] = userID
        }</span>
        <span class="cov0" title="0">if traceID := fmkCtx.GetTraceID(ctx); utils.IsStrNotBlank(traceID) </span><span class="cov0" title="0">{
                fs["trace_id"] = traceID
        }</span>
        <span class="cov0" title="0">if taskID := fmkCtx.GetCronTaskID(ctx); utils.IsStrNotBlank(taskID) </span><span class="cov0" title="0">{
                fs["cron_task_id"] = taskID
        }</span>
        <span class="cov0" title="0">if taskName := fmkCtx.GetCronTaskName(ctx); utils.IsStrNotBlank(taskName) </span><span class="cov0" title="0">{
                fs["cron_task_name"] = taskName
        }</span>
        <span class="cov0" title="0">return</span>
}

func formatLogMsg(app, n, src string, args ...any) (dst string) <span class="cov0" title="0">{
        appName := config.Use(app).AppName()
        return fmt.Sprintf("%v [Gofusion] %s %s %s %s",
                syscall.Getpid(), appName, config.ComponentMessageQueue, n, fmt.Sprintf(src, args...))
}</span>
</pre>
		
		<pre class="file" id="file178" style="display: none">package mq

import (
        "context"
        "fmt"
        "reflect"

        "github.com/Rican7/retry"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/clone"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/serialize"
        "github.com/wfusion/gofusion/routine"

        mw "github.com/wfusion/gofusion/common/infra/watermill/message"
        fmkCtx "github.com/wfusion/gofusion/context"
        pd "github.com/wfusion/gofusion/internal/util/payload"
)

type abstractMQ struct {
        pub mw.Publisher
        sub mw.Subscriber

        appName string
        ctx     context.Context
        name    string
        conf    *Conf
        logger  watermill.LoggerAdapter

        compressType  compress.Algorithm
        serializeType serialize.Algorithm
}

func newPub(ctx context.Context, pub mw.Publisher, appName, name string,
        conf *Conf, logger watermill.LoggerAdapter) *abstractMQ <span class="cov8" title="56">{
        mq := &amp;abstractMQ{ctx: ctx, pub: pub, appName: appName, name: name, conf: clone.Slowly(conf), logger: logger}
        mq.serializeType = serialize.ParseAlgorithm(conf.SerializeType)
        mq.compressType = compress.ParseAlgorithm(conf.CompressType)
        return mq
}</span>

func newSub(ctx context.Context, sub mw.Subscriber, appName, name string,
        conf *Conf, logger watermill.LoggerAdapter) *abstractMQ <span class="cov8" title="56">{
        mq := &amp;abstractMQ{ctx: ctx, sub: sub, appName: appName, name: name, conf: clone.Slowly(conf), logger: logger}
        mq.serializeType = serialize.ParseAlgorithm(conf.SerializeType)
        mq.compressType = compress.ParseAlgorithm(conf.CompressType)
        return mq
}</span>

func (a *abstractMQ) Publish(ctx context.Context, opts ...utils.OptionExtender) (err error) <span class="cov8" title="78">{
        opt := utils.ApplyOptions[pubOption](opts...)
        msgs := opt.watermillMessages
        for _, msg := range opt.messages </span><span class="cov0" title="0">{
                msg, err := a.newMessage(ctx, msg, opt)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">msgs = append(msgs, msg)</span>
        }
        <span class="cov8" title="78">for _, object := range opt.objects </span><span class="cov0" title="0">{
                msg, err := a.newObjectMessage(ctx, object, opt)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">msgs = append(msgs, msg)</span>
        }
        <span class="cov8" title="79">if len(msgs) == 0 </span><span class="cov0" title="0">{
                logInfo(ctx, a.logger, a.appName, a.name, "none messages to publish")
                return
        }</span>

        <span class="cov8" title="79">if !opt.async </span><span class="cov8" title="79">{
                return a.pub.Publish(ctx, a.conf.Topic, msgs...)
        }</span>

        <span class="cov0" title="0">routine.Goc(ctx, func() </span><span class="cov0" title="0">{
                idList := utils.SliceMapping(msgs, func(s *mw.Message) (id string) </span><span class="cov0" title="0">{ return s.UUID }</span>)
                <span class="cov0" title="0">idList = utils.NewSet(idList...).Items()
                retryFunc := func(attempt uint) error </span><span class="cov0" title="0">{
                        if attempt &gt; 1 </span><span class="cov0" title="0">{
                                logInfo(ctx, a.logger, a.appName, a.name,
                                        "retry to publish topic message [topic[%s] message%v[%v] attempt[%v]]",
                                        a.conf.Topic, idList, len(msgs), attempt-1)
                        }</span>
                        <span class="cov0" title="0">return a.pub.Publish(ctx, a.conf.Topic, msgs...)</span>
                }

                <span class="cov0" title="0">if err = retry.Retry(retryFunc, opt.asyncStrategies...); err != nil </span><span class="cov0" title="0">{
                        logError(ctx, a.logger, a.appName, a.name,
                                "retry to publish topic message failed [err[%s] topic[%s] message%v[%v]]",
                                err, a.conf.Topic, idList, len(msgs))
                }</span>
        }, routine.AppName(a.appName))
        <span class="cov0" title="0">return</span>
}

func (a *abstractMQ) PublishRaw(ctx context.Context, opts ...utils.OptionExtender) (err error) <span class="cov8" title="80">{
        opt := utils.ApplyOptions[pubOption](opts...)
        msgs := opt.watermillMessages
        for _, msg := range opt.messages </span><span class="cov8" title="80">{
                wmsg := mw.NewMessage(msg.ID(), msg.Payload())
                wmsg.Metadata = fmkCtx.WatermillMetadata(ctx)
                wmsg.SetContext(ctx)
                msgs = append(msgs, wmsg)
        }</span>
        <span class="cov8" title="80">if len(msgs) == 0 </span><span class="cov0" title="0">{
                logInfo(ctx, a.logger, a.appName, a.name, "none messages to publish")
                return
        }</span>

        <span class="cov8" title="80">if !opt.async </span><span class="cov8" title="80">{
                return a.pub.Publish(ctx, a.conf.Topic, msgs...)
        }</span>

        <span class="cov0" title="0">routine.Goc(ctx, func() </span><span class="cov0" title="0">{
                idList := utils.SliceMapping(msgs, func(s *mw.Message) (id string) </span><span class="cov0" title="0">{ return s.UUID }</span>)
                <span class="cov0" title="0">idList = utils.NewSet(idList...).Items()
                retryFunc := func(attempt uint) error </span><span class="cov0" title="0">{
                        if attempt &gt; 1 </span><span class="cov0" title="0">{
                                logInfo(ctx, a.logger, a.appName, a.name,
                                        "retry to publish topic message [topic[%s] message%v[%v] attempt[%v]]",
                                        a.conf.Topic, idList, len(msgs), attempt-1)
                        }</span>
                        <span class="cov0" title="0">return a.pub.Publish(ctx, a.conf.Topic, msgs...)</span>
                }

                <span class="cov0" title="0">if err = retry.Retry(retryFunc, opt.asyncStrategies...); err != nil </span><span class="cov0" title="0">{
                        logError(ctx, a.logger, a.appName, a.name,
                                "retry to publish topic message failed [err[%s] topic[%s] message%v[%v]]",
                                err, a.conf.Topic, idList, len(msgs))
                }</span>
        }, routine.AppName(a.appName))
        <span class="cov0" title="0">return</span>
}

func (a *abstractMQ) SubscribeRaw(ctx context.Context, opts ...utils.OptionExtender) (dst &lt;-chan Message, err error) <span class="cov4" title="8">{
        opt := utils.ApplyOptions[subOption](opts...)
        ch, err := a.sub.Subscribe(ctx, a.conf.Topic)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="8">msgCh := make(chan Message, opt.channelLength)
        routine.Go(func() </span><span class="cov4" title="8">{
                defer close(msgCh)
                for </span><span class="cov7" title="48">{
                        select </span>{
                        case wmsg, ok := &lt;-ch:<span class="cov7" title="40">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov7" title="40">msg := rawMessageConvertFrom(wmsg)
                                select </span>{
                                case msgCh &lt;- msg:<span class="cov7" title="40"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        msg.Nack()
                                        a.logger.Info(fmt.Sprintf(
                                                "raw subscriber %s exited with a message nacked when business ctx done", a.name),
                                                watermill.LogFields{watermill.ContextLogFieldKey: ctx})
                                        return</span>
                                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                                        msg.Nack()
                                        a.logger.Info(fmt.Sprintf(
                                                "raw subscriber %s exited with a message nacked when app ctx done", a.name),
                                                watermill.LogFields{watermill.ContextLogFieldKey: ctx})
                                        return</span>
                                }
                        case &lt;-ctx.Done():<span class="cov4" title="8">
                                return</span>
                        case &lt;-a.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }, routine.AppName(a.appName))
        <span class="cov4" title="8">return msgCh, err</span>
}

func (a *abstractMQ) Subscribe(ctx context.Context, opts ...utils.OptionExtender) (dst &lt;-chan Message, err error) <span class="cov0" title="0">{
        opt := utils.ApplyOptions[subOption](opts...)
        ch, err := a.sub.Subscribe(ctx, a.conf.Topic)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">msgCh := make(chan Message, opt.channelLength)
        routine.Go(func() </span><span class="cov0" title="0">{
                defer close(msgCh)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case wmsg, ok := &lt;-ch:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">_, data, isRaw, err := pd.UnsealRaw(wmsg.Payload, pd.Compress(a.compressType))
                                if err != nil </span><span class="cov0" title="0">{
                                        a.logger.Error("unseal message failed", err, watermill.LogFields{
                                                watermill.ContextLogFieldKey: ctx,
                                        })
                                        continue</span>
                                }
                                <span class="cov0" title="0">wmsg.SetContext(fmkCtx.New(fmkCtx.Watermill(wmsg.Metadata)))
                                msg := &amp;message{Message: wmsg, payload: data}
                                if !isRaw </span><span class="cov0" title="0">{
                                        _, msg.obj, _, err = pd.Unseal(wmsg.Payload,
                                                pd.Serialize(a.serializeType), pd.Compress(a.compressType))
                                        if err != nil </span><span class="cov0" title="0">{
                                                a.logger.Error("unseal message object failed", err, watermill.LogFields{
                                                        watermill.ContextLogFieldKey: ctx,
                                                })
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">select </span>{
                                case msgCh &lt;- msg:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        msg.Nack()
                                        a.logger.Info(fmt.Sprintf(
                                                "subscriber %s exited with a message nacked when business ctx done", a.name),
                                                watermill.LogFields{watermill.ContextLogFieldKey: ctx})
                                        return</span>
                                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                                        msg.Nack()
                                        a.logger.Info(fmt.Sprintf(
                                                "subscriber %s exited with a message nacked when app ctx done", a.name),
                                                watermill.LogFields{watermill.ContextLogFieldKey: ctx})
                                        return</span>
                                }

                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-a.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }, routine.AppName(a.appName))
        <span class="cov0" title="0">return msgCh, err</span>
}

func (a *abstractMQ) close() error                             <span class="cov0" title="0">{ panic(ErrNotImplement)</span> }
func (a *abstractMQ) topic() string                            <span class="cov10" title="160">{ return a.conf.Topic }</span>
func (a *abstractMQ) watermillPublisher() mw.Publisher         <span class="cov8" title="83">{ return a.pub }</span>
func (a *abstractMQ) watermillSubscriber() mw.Subscriber       <span class="cov8" title="80">{ return a.sub }</span>
func (a *abstractMQ) watermillLogger() watermill.LoggerAdapter <span class="cov0" title="0">{ return a.logger }</span>

func (a *abstractMQ) newMessage(ctx context.Context, src Message, _ *pubOption) (
        msg *mw.Message, err error) <span class="cov0" title="0">{
        payload, err := pd.Seal(src.Payload(), pd.Compress(a.compressType))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">msg = mw.NewMessage(src.ID(), payload)
        msg.Metadata = fmkCtx.WatermillMetadata(ctx)
        msg.SetContext(ctx)
        return</span>
}
func (a *abstractMQ) newObjectMessage(ctx context.Context, object any, opt *pubOption) (
        msg *mw.Message, err error) <span class="cov8" title="80">{
        payload, err := pd.Seal(object, pd.Compress(a.compressType), pd.Serialize(a.serializeType))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="79">uuid := utils.ULID()
        if opt.objectUUIDGenFunc.IsValid() &amp;&amp; opt.objectUUIDGenFunc.Kind() == reflect.Func </span><span class="cov0" title="0">{
                inType := opt.objectUUIDGenFunc.Type().In(0)
                inParam := reflect.ValueOf(object).Convert(inType)
                uuid = opt.objectUUIDGenFunc.Call([]reflect.Value{inParam})[0].Interface().(string)
        }</span>
        <span class="cov8" title="78">msg = mw.NewMessage(uuid, payload)
        msg.Metadata = fmkCtx.WatermillMetadata(ctx)
        msg.SetContext(ctx)
        return</span>
}

func rawMessageConvertFrom(src *mw.Message) (dst Message) <span class="cov7" title="40">{
        return &amp;message{Message: src, payload: src.Payload}
}</span>

func messageConvertTo(src Message) (dst *mw.Message) <span class="cov7" title="40">{
        dst = src.(*message).Message
        return
}</span>

func messageConvertFrom(src *mw.Message,
        serializeType serialize.Algorithm, compressType compress.Algorithm) (dst Message, err error) <span class="cov7" title="40">{
        _, data, isRaw, err := pd.UnsealRaw(src.Payload, pd.Compress(compressType))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov7" title="40">src.SetContext(fmkCtx.New(fmkCtx.Watermill(src.Metadata)))
        msg := &amp;message{Message: src, payload: data}
        if !isRaw </span><span class="cov0" title="0">{
                _, msg.obj, _, err = pd.Unseal(src.Payload,
                        pd.Serialize(serializeType), pd.Compress(compressType))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov7" title="40">dst = msg
        return</span>
}
</pre>
		
		<pre class="file" id="file179" style="display: none">package mq

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/db"

        millSql "github.com/wfusion/gofusion/common/infra/watermill/pubsub/sql"
)

func newMysql(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) (
        pub Publisher, sub Subscriber) <span class="cov6" title="18">{
        instance := db.Use(ctx, conf.Endpoint.Instance, db.AppName(appName))
        cli := utils.Must(instance.GetProxy().DB())
        if conf.Producer </span><span class="cov6" title="18">{
                pub = newMysqlPublisher(ctx, appName, name, conf, logger, cli)
        }</span>

        <span class="cov6" title="18">if conf.Consumer </span><span class="cov6" title="18">{
                sub = newMysqlSubscriber(ctx, appName, name, conf, logger, cli)
        }</span>

        <span class="cov6" title="18">return</span>
}

type mysqlPublisher struct {
        *abstractMQ
        publisher *millSql.Publisher
}

func newMysqlPublisher(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter,
        cli *sql.DB) Publisher <span class="cov6" title="18">{
        cfg := millSql.PublisherConfig{
                SchemaAdapter: millSql.DefaultMySQLSchema{
                        GenerateMessagesTableName: func(topic string) string </span><span class="cov6" title="29">{
                                return fmt.Sprintf("%s_%s", conf.MessageScheme, topic)
                        }</span>,
                        SubscribeBatchSize: 1,
                },
                AutoInitializeSchema: true,
                AppID:                config.Use(appName).AppName(),
        }

        <span class="cov6" title="18">pub, err := millSql.NewPublisher(cli, cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component mysql publisher failed: %s", err))</span>
        }

        <span class="cov6" title="18">return &amp;mysqlPublisher{
                abstractMQ: newPub(ctx, pub, appName, name, conf, logger),
                publisher:  pub,
        }</span>
}

func (m *mysqlPublisher) close() (err error) <span class="cov6" title="18">{
        return m.publisher.Close()
}</span>

type mysqlSubscriber struct {
        *abstractMQ
        subscriber *millSql.Subscriber
}

func newMysqlSubscriber(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter,
        cli *sql.DB) Subscriber <span class="cov6" title="18">{
        cfg := millSql.SubscriberConfig{
                ConsumerGroup:  conf.ConsumerGroup,
                PollInterval:   0,
                ResendInterval: 0,
                RetryInterval:  0,
                BackoffManager: nil,
                SchemaAdapter: millSql.DefaultMySQLSchema{
                        GenerateMessagesTableName: func(topic string) string </span><span class="cov9" title="163">{
                                return fmt.Sprintf("%s_%s", conf.MessageScheme, topic)
                        }</span>,
                        SubscribeBatchSize: conf.ConsumerConcurrency, // fetch how many rows per query
                },
                OffsetsAdapter: millSql.DefaultMySQLOffsetsAdapter{
                        GenerateMessagesOffsetsTableName: func(topic string) string <span class="cov10" title="167">{
                                return fmt.Sprintf("%s_offsets_%s", conf.MessageScheme, topic)
                        }</span>,
                },
                InitializeSchema:  true,
                DisablePersistent: !conf.Persistent,
        }

        <span class="cov6" title="18">sub, err := millSql.NewSubscriber(cli, cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component mysql subscriber failed: %s", err))</span>
        }

        <span class="cov6" title="18">return &amp;mysqlSubscriber{
                abstractMQ: newSub(ctx, sub, appName, name, conf, logger),
                subscriber: sub,
        }</span>
}

func (m *mysqlSubscriber) close() (err error) <span class="cov6" title="18">{
        return m.subscriber.Close()
}</span>
</pre>
		
		<pre class="file" id="file180" style="display: none">package mq

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/db"

        millSql "github.com/wfusion/gofusion/common/infra/watermill/pubsub/sql"
)

func newPostgres(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) (
        pub Publisher, sub Subscriber) <span class="cov3" title="6">{
        instance := db.Use(ctx, conf.Endpoint.Instance, db.AppName(appName))
        cli := utils.Must(instance.GetProxy().DB())
        if conf.Producer </span><span class="cov3" title="6">{
                pub = newPostgresPublisher(ctx, appName, name, conf, logger, cli)
        }</span>

        <span class="cov3" title="6">if conf.Consumer </span><span class="cov3" title="6">{
                sub = newPostgresSubscriber(ctx, appName, name, conf, logger, cli)
        }</span>

        <span class="cov3" title="6">return</span>
}

type postgresPublisher struct {
        *abstractMQ
        publisher *millSql.Publisher
}

func newPostgresPublisher(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter,
        cli *sql.DB) Publisher <span class="cov3" title="6">{
        cfg := millSql.PublisherConfig{
                SchemaAdapter: millSql.DefaultPostgreSQLSchema{
                        GenerateMessagesTableName: func(topic string) string </span><span class="cov6" title="29">{
                                return fmt.Sprintf("%s_%s", conf.MessageScheme, topic)
                        }</span>,
                        SubscribeBatchSize: conf.ConsumerConcurrency,
                },
                AutoInitializeSchema: true,
                AppID:                config.Use(appName).AppName(),
        }

        <span class="cov3" title="6">pub, err := millSql.NewPublisher(cli, cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component postgres publisher failed: %s", err))</span>
        }

        <span class="cov3" title="6">return &amp;postgresPublisher{
                abstractMQ: newPub(ctx, pub, appName, name, conf, logger),
                publisher:  pub,
        }</span>
}

func (p *postgresPublisher) close() (err error) <span class="cov3" title="6">{
        return p.publisher.Close()
}</span>

type postgresSubscriber struct {
        *abstractMQ
        subscriber *millSql.Subscriber
}

func newPostgresSubscriber(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter,
        cli *sql.DB) Subscriber <span class="cov3" title="6">{
        cfg := millSql.SubscriberConfig{
                ConsumerGroup:  conf.ConsumerGroup,
                PollInterval:   0,
                ResendInterval: 0,
                RetryInterval:  0,
                BackoffManager: nil,
                SchemaAdapter: millSql.DefaultPostgreSQLSchema{
                        GenerateMessagesTableName: func(topic string) string </span><span class="cov9" title="142">{
                                return fmt.Sprintf("%s_%s", conf.MessageScheme, topic)
                        }</span>,
                        SubscribeBatchSize: conf.ConsumerConcurrency, // fetch how many rows per query
                },
                OffsetsAdapter: millSql.DefaultPostgreSQLOffsetsAdapter{
                        GenerateMessagesOffsetsTableName: func(topic string) string <span class="cov10" title="245">{
                                return fmt.Sprintf("%s_offsets_%s", conf.MessageScheme, topic)
                        }</span>,
                },
                InitializeSchema:  true,
                DisablePersistent: !conf.Persistent,
        }

        <span class="cov3" title="6">sub, err := millSql.NewSubscriber(cli, cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component mysql subscriber failed: %s", err))</span>
        }

        <span class="cov3" title="6">return &amp;postgresSubscriber{
                abstractMQ: newSub(ctx, sub, appName, name, conf, logger),
                subscriber: sub,
        }</span>
}

func (p *postgresSubscriber) close() (err error) <span class="cov3" title="6">{
        return p.subscriber.Close()
}</span>
</pre>
		
		<pre class="file" id="file181" style="display: none">package mq

import (
        "context"
        "fmt"
        "strings"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/infra/watermill/pubsub/pulsar"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"

        plsDrv "github.com/apache/pulsar-client-go/pulsar"
)

func newPulsar(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) (
        pub Publisher, sub Subscriber) <span class="cov10" title="6">{
        if conf.Producer </span><span class="cov10" title="6">{
                pub = newPulsarPublisher(ctx, appName, name, conf, logger)
        }</span>

        <span class="cov10" title="6">if conf.Consumer </span><span class="cov10" title="6">{
                sub = newPulsarSubscriber(ctx, appName, name, conf, logger)
        }</span>

        <span class="cov10" title="6">return</span>
}

type pulsarPublisher struct {
        *abstractMQ
        publisher *pulsar.Publisher
}

func newPulsarPublisher(ctx context.Context, appName, name string,
        conf *Conf, logger watermill.LoggerAdapter) Publisher <span class="cov10" title="6">{
        cfg := pulsar.PublisherConfig{
                URL:   fmt.Sprintf("pulsar://%s", strings.TrimPrefix(conf.Endpoint.Addresses[0], "pulsar://")),
                AppID: config.Use(appName).AppName(),
        }
        hasUser := utils.IsStrNotBlank(conf.Endpoint.User)
        hasPassword := utils.IsStrNotBlank(conf.Endpoint.Password)
        hasAuthType := utils.IsStrNotBlank(conf.Endpoint.AuthType)
        if hasUser &amp;&amp; hasPassword </span><span class="cov0" title="0">{
                cfg.Authentication = utils.Must(plsDrv.NewAuthenticationBasic(conf.Endpoint.User, conf.Endpoint.Password))
        }</span>
        <span class="cov10" title="6">if hasAuthType </span><span class="cov0" title="0">{
                cfg.Authentication = utils.Must(plsDrv.NewAuthentication(conf.Endpoint.AuthType, conf.Endpoint.Password))
        }</span>

        <span class="cov10" title="6">pub, err := pulsar.NewPublisher(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component pulsar publisher failed: %s", err))</span>
        }

        <span class="cov10" title="6">return &amp;pulsarPublisher{
                abstractMQ: newPub(ctx, pub, appName, name, conf, logger),
                publisher:  pub,
        }</span>
}

func (p *pulsarPublisher) close() (err error) <span class="cov10" title="6">{
        return p.publisher.Close()
}</span>

type pulsarSubscriber struct {
        *abstractMQ
        subscriber *pulsar.Subscriber
}

func newPulsarSubscriber(ctx context.Context, appName, name string,
        conf *Conf, logger watermill.LoggerAdapter) Subscriber <span class="cov10" title="6">{
        cfg := &amp;pulsar.SubscriberConfig{
                URL:        fmt.Sprintf("pulsar://%s", strings.TrimPrefix(conf.Endpoint.Addresses[0], "pulsar://")),
                QueueGroup: conf.ConsumerGroup,
                Persistent: conf.Persistent,
        }
        hasUser := utils.IsStrNotBlank(conf.Endpoint.User)
        hasPassword := utils.IsStrNotBlank(conf.Endpoint.Password)
        hasAuthType := utils.IsStrNotBlank(conf.Endpoint.AuthType)
        if hasUser &amp;&amp; hasPassword </span><span class="cov0" title="0">{
                cfg.Authentication = utils.Must(plsDrv.NewAuthenticationBasic(conf.Endpoint.User, conf.Endpoint.Password))
        }</span>
        <span class="cov10" title="6">if hasAuthType </span><span class="cov0" title="0">{
                params := conf.Endpoint.Password
                switch conf.Endpoint.AuthType </span>{
                case "basic", "org.apache.pulsar.client.impl.auth.AuthenticationBasic":<span class="cov0" title="0">
                        params = utils.MustJsonMarshalString(map[string]string{
                                "username": conf.Endpoint.User,
                                "password": conf.Endpoint.Password,
                        })</span>
                }
                <span class="cov0" title="0">cfg.Authentication = utils.Must(plsDrv.NewAuthentication(conf.Endpoint.AuthType, params))</span>
        }

        <span class="cov10" title="6">sub, err := pulsar.NewSubscriber(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component pulsar subscriber failed: %s", err))</span>
        }

        <span class="cov10" title="6">return &amp;pulsarSubscriber{
                abstractMQ: newSub(ctx, sub, appName, name, conf, logger),
                subscriber: sub,
        }</span>
}
func (p *pulsarSubscriber) close() (err error) <span class="cov10" title="6">{
        return p.subscriber.Close()
}</span>
</pre>
		
		<pre class="file" id="file182" style="display: none">package mq

import (
        "context"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/redis"

        rdsDrv "github.com/redis/go-redis/v9"

        millRds "github.com/wfusion/gofusion/common/infra/watermill/pubsub/redis"
)

func newRedis(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter) (
        pub Publisher, sub Subscriber) <span class="cov10" title="6">{

        cli := redis.Use(ctx, conf.Endpoint.Instance, redis.AppName(appName))

        if conf.Producer </span><span class="cov10" title="6">{
                pub = newRedisPublisher(ctx, appName, name, conf, logger, cli)
        }</span>

        <span class="cov10" title="6">if conf.Consumer </span><span class="cov10" title="6">{
                sub = newRedisSubscriber(ctx, appName, name, conf, logger, cli)
        }</span>

        <span class="cov10" title="6">return</span>
}

type redisPublisher struct {
        *abstractMQ
        publisher *millRds.Publisher
}

func newRedisPublisher(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter,
        cli rdsDrv.UniversalClient) Publisher <span class="cov10" title="6">{
        cfg := millRds.PublisherConfig{
                Client:                cli,
                Marshaller:            millRds.DefaultMarshallerUnmarshaller{AppID: config.Use(appName).AppName()},
                Maxlens:               nil,
                DisableRedisConnClose: true,
        }

        pub, err := millRds.NewPublisher(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component redis publisher failed: %s", err))</span>
        }

        <span class="cov10" title="6">return &amp;redisPublisher{
                abstractMQ: newPub(ctx, pub, appName, name, conf, logger),
                publisher:  pub,
        }</span>
}

func (r *redisPublisher) close() (err error) <span class="cov10" title="6">{
        return r.publisher.Close()
}</span>

type redisSubscriber struct {
        *abstractMQ
        subscriber *millRds.Subscriber
}

func newRedisSubscriber(ctx context.Context, appName, name string, conf *Conf, logger watermill.LoggerAdapter,
        cli rdsDrv.UniversalClient) Subscriber <span class="cov10" title="6">{
        cfg := millRds.SubscriberConfig{
                Client:                    cli,
                Unmarshaller:              millRds.DefaultMarshallerUnmarshaller{AppID: config.Use(appName).AppName()},
                Consumer:                  "",
                ConsumerGroup:             conf.ConsumerGroup,
                NackResendSleep:           0,
                BlockTime:                 0,
                ClaimInterval:             0,
                ClaimBatchSize:            0,
                MaxIdleTime:               0,
                CheckConsumersInterval:    0,
                ConsumerTimeout:           0,
                OldestId:                  "",
                ShouldClaimPendingMessage: nil,
                DisableRedisConnClose:     true,
        }

        sub, err := millRds.NewSubscriber(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.Wrapf(err, "initialize mq component redis subscriber failed: %s", err))</span>
        }

        <span class="cov10" title="6">return &amp;redisSubscriber{
                abstractMQ: newSub(ctx, sub, appName, name, conf, logger),
                subscriber: sub,
        }</span>
}

func (r *redisSubscriber) close() (err error) <span class="cov10" title="6">{
        return r.subscriber.Close()
}</span>
</pre>
		
		<pre class="file" id="file183" style="display: none">package mq

import (
        "context"
        "fmt"
        "reflect"
        "strings"
        "sync"
        "time"

        "github.com/PaesslerAG/gval"
        "github.com/pkg/errors"
        "github.com/sony/gobreaker"
        "go.uber.org/multierr"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/infra/watermill/message/router/middleware"
        "github.com/wfusion/gofusion/common/infra/watermill/message/router/plugin"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/compress"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/common/utils/serialize"
        "github.com/wfusion/gofusion/log"
        "github.com/wfusion/gofusion/routine"

        mw "github.com/wfusion/gofusion/common/infra/watermill/message"
        fmkCtx "github.com/wfusion/gofusion/context"
        pd "github.com/wfusion/gofusion/internal/util/payload"
)

const (
        defaultRouterEventHandlerName = "__router_event_handler"
)

type router struct {
        *mw.Router

        appName string

        c   *Conf
        pub Publisher
        sub Subscriber

        compressType  compress.Algorithm
        serializeType serialize.Algorithm

        ctx context.Context

        locker                  sync.RWMutex
        eventHandlers           map[string]*handler
        eventSubscriberHandlers map[string]*handler
}
type handler struct {
        fn             reflect.Value
        evtType        reflect.Type
        evtPayloadType reflect.Type
}

func newRouter(ctx context.Context, appName, name string, conf *Conf,
        pub Publisher, sub Subscriber, logger watermill.LoggerAdapter) *router <span class="cov8" title="56">{
        r := utils.Must(mw.NewRouter(mw.RouterConfig{CloseTimeout: 15 * time.Second}, logger))
        r.AddPlugin(plugin.SignalsHandler)
        r.AddMiddleware(
                middleware.Recoverer,
                middleware.CorrelationID,
        )
        for _, mwsConf := range conf.ConsumeMiddlewares </span><span class="cov6" title="23">{
                switch mwsConf.Type </span>{
                case middlewareTypeRetry:<span class="cov2" title="3">
                        r.AddMiddleware(middleware.Retry{
                                MaxRetries:          mwsConf.RetryMaxRetries,
                                InitialInterval:     utils.Must(time.ParseDuration(mwsConf.RetryInitialInterval)),
                                MaxInterval:         utils.Must(time.ParseDuration(mwsConf.RetryMaxInterval)),
                                Multiplier:          mwsConf.RetryMultiplier,
                                MaxElapsedTime:      utils.Must(time.ParseDuration(mwsConf.RetryMaxElapsedTime)),
                                RandomizationFactor: mwsConf.RetryRandomizationFactor,
                                OnRetryHook: func(attempt int, delay time.Duration) </span><span class="cov0" title="0">{
                                        logTrace(ctx, logger, appName, name,
                                                "retry to consume message [attempt[%v] delay[%s]]", attempt, delay)
                                }</span>,
                                Logger: logger,
                        }.Middleware)
                case middlewareTypeThrottle:<span class="cov5" title="11">
                        r.AddMiddleware(
                                middleware.NewThrottle(
                                        int64(mwsConf.ThrottleCount),
                                        utils.Must(time.ParseDuration(mwsConf.ThrottleDuration)),
                                ).Middleware,
                        )</span>
                case middlewareTypeInstanceAck:<span class="cov0" title="0">
                        r.AddMiddleware(middleware.InstantAck)</span>
                case middlewareTypePoison:<span class="cov2" title="3">
                        shouldGoToPoisonQueue := func(err error) bool </span><span class="cov0" title="0">{ return err != nil }</span>
                        <span class="cov2" title="3">r.AddMiddleware(
                                utils.Must(middleware.PoisonQueueWithFilter(
                                        pub.watermillPublisher(),
                                        mwsConf.PoisonTopic,
                                        shouldGoToPoisonQueue,
                                )),
                        )</span>
                case middlewareTypeTimeout:<span class="cov2" title="3">
                        r.AddMiddleware(middleware.Timeout(utils.Must(time.ParseDuration(mwsConf.Timeout))))</span>
                case middlewareTypeCircuitBreaker:<span class="cov2" title="3">
                        var expr gval.Evaluable
                        if utils.IsStrNotBlank(mwsConf.CircuitBreakerTripExpr) </span><span class="cov2" title="3">{
                                expr = utils.Must(gval.Full().NewEvaluable(mwsConf.CircuitBreakerTripExpr))
                        }</span>
                        <span class="cov2" title="3">r.AddMiddleware(middleware.NewCircuitBreaker(gobreaker.Settings{
                                Name:        name,
                                MaxRequests: uint32(mwsConf.CircuitBreakerMaxRequests),
                                Interval:    utils.Must(time.ParseDuration(mwsConf.CircuitBreakerInterval)),
                                Timeout:     utils.Must(time.ParseDuration(mwsConf.CircuitBreakerTimeout)),
                                ReadyToTrip: func(counts gobreaker.Counts) bool </span><span class="cov0" title="0">{
                                        // fallback to default ready to trip expression
                                        if expr == nil </span><span class="cov0" title="0">{
                                                return counts.ConsecutiveFailures &gt; 5
                                        }</span>
                                        <span class="cov0" title="0">if ok, err := expr.EvalBool(ctx, map[string]uint32{
                                                "requests":              counts.Requests,
                                                "total_successes":       counts.TotalSuccesses,
                                                "total_failures":        counts.TotalFailures,
                                                "consecutive_successes": counts.ConsecutiveSuccesses,
                                                "consecutive_failures":  counts.ConsecutiveFailures,
                                        }); err == nil </span><span class="cov0" title="0">{
                                                return ok
                                        }</span>
                                        // fallback to default ready to trip expression
                                        <span class="cov0" title="0">return counts.ConsecutiveFailures &gt; 5</span>
                                },
                                OnStateChange: func(name string, from gobreaker.State, to gobreaker.State) <span class="cov0" title="0">{
                                        logInfo(ctx, logger, appName, name, "circuit breaker state changed: %s -&gt; %s", from, to)
                                }</span>,
                                IsSuccessful: func(err error) bool <span class="cov0" title="0">{ return err == nil }</span>,
                        }).Middleware)
                default:<span class="cov0" title="0">
                        typ := inspect.TypeOf(string(mwsConf.Type))
                        if typ == nil || typ.ConvertibleTo(watermillHandlerMiddlewareType) </span><span class="cov0" title="0">{
                                panic(errors.Errorf("unknown mq middleware: %s", mwsConf.Type))</span>
                        }
                        <span class="cov0" title="0">mws := reflect.New(typ).Elem().Convert(watermillHandlerMiddlewareType).Interface()
                        r.AddMiddleware(mws.(mw.HandlerMiddleware))</span>
                }
        }

        <span class="cov8" title="56">rr := &amp;router{
                ctx:                     ctx,
                appName:                 appName,
                c:                       conf,
                pub:                     pub,
                sub:                     sub,
                Router:                  r,
                eventHandlers:           make(map[string]*handler),
                eventSubscriberHandlers: make(map[string]*handler),
        }
        rr.serializeType = serialize.ParseAlgorithm(conf.SerializeType)
        rr.compressType = compress.ParseAlgorithm(conf.CompressType)

        return rr</span>
}

func (r *router) Handle(handlerName string, hdr any, opts ...utils.OptionExtender) <span class="cov6" title="24">{
        opt := utils.ApplyOptions[routerOption](opts...)
        if opt.isEventSubscriber || singleConsumerMQType.Contains(r.c.Type) </span><span class="cov5" title="16">{
                r.addHandler(handlerName, handlerName, hdr, opt)
                return
        }</span>
        <span class="cov4" title="8">for i := 0; i &lt; r.c.ConsumerConcurrency; i++ </span><span class="cov8" title="64">{
                consumerName := fmt.Sprintf("%s_%v", handlerName, i)
                r.addHandler(handlerName, consumerName, hdr, opt)
        }</span>
}

func (r *router) Serve() (err error) <span class="cov0" title="0">{
        if r.isHandlerConflict() </span><span class="cov0" title="0">{
                panic(ErrEventHandlerConflict)</span>
        }
        <span class="cov0" title="0">if len(r.eventHandlers) &gt; 0 </span><span class="cov0" title="0">{
                r.runEventHandlers()
        }</span>
        <span class="cov0" title="0">if err = r.run(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">&lt;-r.Router.ClosedCh
        return</span>
}

func (r *router) Start() <span class="cov5" title="16">{
        if r.isHandlerConflict() </span><span class="cov0" title="0">{
                panic(ErrEventHandlerConflict)</span>
        }
        <span class="cov5" title="16">if len(r.eventHandlers) &gt; 0 </span><span class="cov4" title="8">{
                r.runEventHandlers()
        }</span>
        <span class="cov5" title="16">routine.Go(r.run, routine.AppName(r.appName))</span>
}

func (r *router) Running() &lt;-chan struct{} <span class="cov6" title="24">{
        return r.Router.Running()
}</span>

func (r *router) run() (err error) <span class="cov6" title="24">{
        if r.Router.IsRunning() </span><span class="cov4" title="8">{
                return r.Router.RunHandlers(r.ctx)
        }</span>
        <span class="cov5" title="16">if err = r.Router.Run(r.ctx); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, mw.ErrRouterIsAlreadyRunning) </span><span class="cov0" title="0">{
                        return r.Router.RunHandlers(r.ctx)
                }</span>
        }
        <span class="cov5" title="16">return</span>
}

func (r *router) addHandler(handlerName, consumerName string, hdr any, opt *routerOption) <span class="cov8" title="80">{
        switch fn := hdr.(type) </span>{
        case HandlerFunc:<span class="cov0" title="0">
                r.Router.AddNoPublisherHandler(
                        consumerName,
                        r.sub.topic(),
                        r.sub.watermillSubscriber(),
                        func(wmsg *mw.Message) (err error) </span><span class="cov0" title="0">{
                                msg, err := messageConvertFrom(wmsg, r.serializeType, r.compressType)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">return fn(msg)</span>
                        },
                )
        case mw.NoPublishHandlerFunc:<span class="cov0" title="0">
                r.Router.AddNoPublisherHandler(
                        consumerName,
                        r.sub.topic(),
                        r.sub.watermillSubscriber(),
                        fn,
                )</span>
        case mw.HandlerFunc:<span class="cov0" title="0">
                r.Router.AddHandler(
                        consumerName,
                        r.sub.topic(),
                        r.sub.watermillSubscriber(),
                        r.pub.topic(),
                        r.pub.watermillPublisher(),
                        fn,
                )</span>
        default:<span class="cov8" title="80">
                fnVal := reflect.ValueOf(hdr)
                switch </span>{
                case fnVal.CanConvert(watermillHandlerFuncType):<span class="cov0" title="0">
                        r.Router.AddNoPublisherHandler(
                                consumerName,
                                r.sub.topic(),
                                r.sub.watermillSubscriber(),
                                func(msg *mw.Message) error </span><span class="cov0" title="0">{
                                        rets := fnVal.Convert(watermillHandlerFuncType).Call(
                                                []reflect.Value{reflect.ValueOf(rawMessageConvertFrom(msg))},
                                        )
                                        return utils.ParseVariadicFuncResult[error](rets, 0)
                                }</span>,
                        )
                case fnVal.CanConvert(watermillNoPublishHandlerFuncType):<span class="cov0" title="0">
                        r.Router.AddNoPublisherHandler(
                                consumerName,
                                r.sub.topic(),
                                r.sub.watermillSubscriber(),
                                func(msg *mw.Message) error </span><span class="cov0" title="0">{
                                        rets := fnVal.
                                                Convert(watermillNoPublishHandlerFuncType).
                                                Call([]reflect.Value{reflect.ValueOf(msg)})
                                        return utils.ParseVariadicFuncResult[error](rets, 0)
                                }</span>,
                        )
                case fnVal.CanConvert(handlerFuncType):<span class="cov7" title="36">
                        r.Router.AddHandler(
                                consumerName,
                                r.sub.topic(),
                                r.sub.watermillSubscriber(),
                                r.pub.topic(),
                                r.pub.watermillPublisher(),
                                func(wmsg *mw.Message) (msgs []*mw.Message, err error) </span><span class="cov7" title="40">{
                                        msg, err := messageConvertFrom(wmsg, r.serializeType, r.compressType)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov7" title="40">rets := fnVal.Convert(handlerFuncType).Call([]reflect.Value{reflect.ValueOf(msg)})
                                        msgs = utils.ParseVariadicFuncResult[[]*mw.Message](rets, 0)
                                        err = utils.ParseVariadicFuncResult[error](rets, 0)
                                        return</span>
                                },
                        )
                case isEventHandler(fnVal):<span class="cov7" title="44">
                        r.handleEvent(handlerName, fnVal, opt)</span>
                default:<span class="cov0" title="0">
                        r.Router.AddNoPublisherHandler(
                                consumerName,
                                r.sub.topic(),
                                r.sub.watermillSubscriber(),
                                r.handle(hdr),
                        )</span>
                }
        }
}

func (r *router) handleEvent(eventType string, fnVal reflect.Value, opt *routerOption) <span class="cov7" title="44">{
        // FIXME: Translating generics to corresponding implemented generic types like this is too hacky.
        //        If this set becomes invalid, switch to the implementation of event payload as any without generics,
        //        and the router can continue to provide it using the current method of storing reflect.Type.
        evtType := fnVal.Type().In(1)
        eventName := strings.Replace(evtType.Name(), "Event[", "event[", 1)
        eventTypeName := fmt.Sprintf(mqPackageSignFormat, eventName)
        et := inspect.TypeOf(eventTypeName)
        if et == nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("unknown event generic object type: %s", eventTypeName))</span>
        }
        <span class="cov7" title="44">eventPayloadName := strings.Replace(evtType.Name(), "Event[", "eventPayload[", 1)
        eventPayloadTypeName := fmt.Sprintf(mqPackageSignFormat, eventPayloadName)
        ept := inspect.TypeOf(eventPayloadTypeName)
        if ept == nil </span><span class="cov0" title="0">{
                panic(errors.Errorf("unknown event payload generic object type: %s", eventPayloadTypeName))</span>
        }

        <span class="cov7" title="44">hdr := &amp;handler{
                fn:             fnVal,
                evtType:        et,
                evtPayloadType: reflect.PtrTo(ept),
        }

        r.locker.Lock()
        defer r.locker.Unlock()
        if !opt.isEventSubscriber </span><span class="cov7" title="36">{
                r.eventHandlers[eventType] = hdr
        }</span> else<span class="cov4" title="8"> {
                r.eventSubscriberHandlers[eventType] = hdr
                r.addEventDispatchHandler(defaultRouterEventHandlerName + "_" + eventType)
                routine.Go(r.run, routine.AppName(r.appName))
        }</span>
}

func (r *router) handle(hdr any) mw.NoPublishHandlerFunc <span class="cov0" title="0">{
        typ := wrapParams(hdr)
        fn := utils.WrapFunc1[error](hdr)
        return func(msg *mw.Message) (err error) </span><span class="cov0" title="0">{
                _, data, _, err := pd.Unseal(msg.Payload,
                        pd.Serialize(r.serializeType), pd.Compress(r.compressType), pd.Type(typ))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">params := unwrapParams(typ, data)
                ctx := fmkCtx.New(fmkCtx.Watermill(msg.Metadata))
                return fn(append([]any{ctx}, params...)...)</span>
        }
}

func (r *router) runEventHandlers() <span class="cov4" title="8">{
        if singleConsumerMQType.Contains(r.c.Type) </span><span class="cov3" title="4">{
                r.addEventDispatchHandler(defaultRouterEventHandlerName)
                return
        }</span>
        <span class="cov3" title="4">for i := 0; i &lt; r.c.ConsumerConcurrency; i++ </span><span class="cov7" title="32">{
                consumerName := fmt.Sprintf("%s_%v", defaultRouterEventHandlerName, i)
                r.addEventDispatchHandler(consumerName)
        }</span>
}

func (r *router) addEventDispatchHandler(consumerName string) <span class="cov7" title="44">{
        r.Router.AddHandler(
                consumerName,
                r.sub.topic(),
                r.sub.watermillSubscriber(),
                r.pub.topic(),
                r.pub.watermillPublisher(),
                func(msg *mw.Message) (pubMsgs []*mw.Message, err error) </span><span class="cov8" title="80">{
                        eventType := msg.Metadata[keyEventType]
                        r.locker.RLock()
                        hdr, ok1 := r.eventHandlers[eventType]
                        subhdr, ok2 := r.eventSubscriberHandlers[eventType]
                        r.locker.RUnlock()
                        if !ok1 &amp;&amp; !ok2 </span><span class="cov0" title="0">{
                                rawID := "unknown"
                                if msg.Metadata != nil </span><span class="cov0" title="0">{
                                        rawID = msg.Metadata[watermill.ContextKeyRawMessageID]
                                }</span>
                                <span class="cov0" title="0">return nil, errors.Errorf(
                                        "handle unknown event message [type[%s] message_uuid[%s] message_raw_id[%s]]",
                                        eventType, msg.UUID, rawID)</span>
                        }
                        <span class="cov8" title="80">handlers := []*handler{hdr, subhdr}

                        wg := new(sync.WaitGroup)
                        futures := make([]*routine.Future, 0, len(handlers))
                        for _, hdr := range handlers </span><span class="cov10" title="160">{
                                if hdr == nil </span><span class="cov8" title="80">{
                                        continue</span>
                                }
                                <span class="cov8" title="80">wg.Add(1)
                                f := routine.Promise(
                                        func(hdr handler) (msgs any, err error) </span><span class="cov8" title="80">{
                                                _, data, _, err := pd.Unseal(msg.Payload,
                                                        pd.Serialize(r.serializeType), pd.Compress(r.compressType), pd.Type(hdr.evtPayloadType))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return
                                                }</span>
                                                <span class="cov8" title="80">event := reflect.New(hdr.evtType).Interface()
                                                inspect.SetField(event, "pd", data)

                                                ctx := fmkCtx.New(fmkCtx.Watermill(msg.Metadata))
                                                ctx = log.SetContextFields(ctx, log.Fields{
                                                        keyEntityID:  msg.Metadata[keyEntityID],
                                                        keyEventType: msg.Metadata[keyEventType],
                                                })
                                                inspect.SetField(event, "ctx", ctx)
                                                inspect.SetField(event, "ackfn", msg.Ack)
                                                inspect.SetField(event, "nackfn", msg.Nack)

                                                rets := hdr.fn.Call([]reflect.Value{reflect.ValueOf(ctx), reflect.ValueOf(event)})
                                                msgs = utils.ParseVariadicFuncResult[[]Message](rets, 0)
                                                err = utils.ParseVariadicFuncResult[error](rets, 0)
                                                return</span>
                                        },
                                        true,
                                        routine.Args(hdr),
                                        routine.WaitGroup(wg),
                                        routine.AppName(r.appName),
                                )
                                <span class="cov8" title="80">futures = append(futures, f)</span>
                        }
                        <span class="cov8" title="80">wg.Wait()

                        pubMsgs = make([]*mw.Message, 0, len(handlers))
                        for _, f := range futures </span><span class="cov8" title="80">{
                                msgsAny, msgErr := f.Get()
                                err = multierr.Append(err, msgErr)
                                if msgsAny != nil </span><span class="cov8" title="80">{
                                        msgs, _ := msgsAny.([]Message)
                                        for _, m := range msgs </span><span class="cov7" title="40">{
                                                pubMsgs = append(pubMsgs, messageConvertTo(m))
                                        }</span>
                                }
                        }
                        <span class="cov8" title="80">return</span>
                },
        )
}

func (r *router) isHandlerConflict() (conflict bool) <span class="cov5" title="16">{
        if len(r.eventHandlers) == 0 </span><span class="cov4" title="8">{
                return
        }</span>
        <span class="cov4" title="8">for name := range r.Handlers() </span><span class="cov4" title="8">{
                if !strings.Contains(name, defaultRouterEventHandlerName) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov4" title="8">return</span>
}

func (r *router) close() (err error) <span class="cov8" title="56">{
        return r.Close()
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">package mq

import (
        "context"
        "reflect"

        "github.com/Rican7/retry/strategy"

        "github.com/wfusion/gofusion/common/infra/watermill"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/log"

        mw "github.com/wfusion/gofusion/common/infra/watermill/message"
)

const (
        ErrDuplicatedSubscriberName utils.Error = "duplicated mq subscriber name"
        ErrDuplicatedPublisherName  utils.Error = "duplicated mq publisher name"
        ErrDuplicatedRouterName     utils.Error = "duplicated mq router name"
        ErrEventHandlerConflict     utils.Error = "conflict with event handler and message handler"
        ErrNotImplement             utils.Error = "mq not implement"
)

var (
        handlerFuncType                   = reflect.TypeOf((*HandlerFunc)(nil)).Elem()
        watermillHandlerFuncType          = reflect.TypeOf((*mw.HandlerFunc)(nil)).Elem()
        watermillNoPublishHandlerFuncType = reflect.TypeOf((*mw.NoPublishHandlerFunc)(nil)).Elem()
        watermillHandlerMiddlewareType    = reflect.TypeOf((*mw.HandlerMiddleware)(nil)).Elem()
        customLoggerType                  = reflect.TypeOf((*customLogger)(nil)).Elem()
        watermillLoggerType               = reflect.TypeOf((*watermill.LoggerAdapter)(nil)).Elem()

        newFn = map[mqType]func(context.Context, string, string, *Conf, watermill.LoggerAdapter) (Publisher, Subscriber){
                mqTypeGoChannel: newGoChannel,
                mqTypeAMQP:      newAMQP,
                mqTypeRabbitmq:  newAMQP,
                mqTypeKafka:     newKafka,
                mqTypePulsar:    newPulsar,
                mqTypeRedis:     newRedis,
                mqTypeMysql:     newMysql,
                mqTypePostgres:  newPostgres,
        }

        singleConsumerMQType = utils.NewSet(mqTypeGoChannel, mqTypeMysql, mqTypePostgres)
)

type Publisher interface {
        // Publish publishes provided messages to given topic.
        //
        // Publish can be synchronous or asynchronous - it depends on the implementation.
        //
        // Most publishers implementations don't support atomic publishing of messages.
        // This means that if publishing one of the messages fails, the next messages will not be published.
        //
        // Publish must be thread safe.
        Publish(ctx context.Context, opts ...utils.OptionExtender) error

        // PublishRaw publishes provided raw messages to given topic.
        //
        // PublishRaw can be synchronous or asynchronous - it depends on the implementation.
        //
        // Most publishers implementations don't support atomic publishing of messages.
        // This means that if publishing one of the messages fails, the next messages will not be published.
        //
        // PublishRaw must be thread safe.
        PublishRaw(ctx context.Context, opts ...utils.OptionExtender) error

        // close should flush unsent messages, if publisher is async.
        close() error
        topic() string
        watermillPublisher() mw.Publisher
}
type EventPublisher[T eventual] interface {
        // PublishEvent publishes provided messages to given topic.
        //
        // PublishEvent can be synchronous or asynchronous - it depends on the implementation.
        //
        // Most publishers implementations don't support atomic publishing of messages.
        // This means that if publishing one of the messages fails, the next messages will not be published.
        //
        // PublishEvent must be thread safe.
        PublishEvent(ctx context.Context, opts ...utils.OptionExtender) error
}

type IRouter interface {
        Handle(handlerName string, hdr any, opts ...utils.OptionExtender)
        Serve() error
        Start()
        Running() &lt;-chan struct{}
        close() error
}

type Subscriber interface {
        // Subscribe returns output channel with messages from provided topic.
        // Channel is closed, when Close() was called on the subscriber.
        //
        // When provided ctx is cancelled, subscriber will close subscribe and close output channel.
        // Provided ctx is set to all produced messages.
        Subscribe(ctx context.Context, opts ...utils.OptionExtender) (&lt;-chan Message, error)

        // SubscribeRaw returns output channel with original messages from provided topic.
        // Channel is closed, when Close() was called on the subscriber.
        //
        // When provided ctx is cancelled, subscriber will close subscribe and close output channel.
        // Provided ctx is set to all produced messages.
        SubscribeRaw(ctx context.Context, opts ...utils.OptionExtender) (&lt;-chan Message, error)

        // close closes all subscriptions with their output channels and flush offsets etc. when needed.
        close() error
        topic() string
        watermillLogger() watermill.LoggerAdapter
        watermillSubscriber() mw.Subscriber
}

type EventSubscriber[T eventual] interface {
        // SubscribeEvent returns output channel with events from provided topic.
        // Channel is closed, when Close() was called on the subscriber.
        //
        // When provided ctx is cancelled, subscriber will close subscribe and close output channel.
        // Provided ctx is set to all produced messages.
        SubscribeEvent(ctx context.Context, opts ...utils.OptionExtender) (&lt;-chan Event[T], error)
}

type HandlerFunc func(msg Message) error

type Message interface {
        ID() string
        Payload() []byte
        RawMessage() any
        Context() context.Context
        Object() any
        Ack() bool
        Nack() bool
}

type pubOption struct {
        messages          []Message
        watermillMessages mw.Messages

        async           bool
        asyncStrategies []strategy.Strategy

        objects           []any
        objectUUIDGenFunc reflect.Value
}
type eventPubOption[T eventual] struct {
        events []Event[T]
}

func Objects[T any](objectUUIDGenFunc func(T) string, objects ...any) utils.OptionFunc[pubOption] <span class="cov0" title="0">{
        return func(o *pubOption) </span><span class="cov0" title="0">{
                o.objects = objects
                if objectUUIDGenFunc != nil </span><span class="cov0" title="0">{
                        o.objectUUIDGenFunc = reflect.ValueOf(objectUUIDGenFunc)
                }</span>
        }
}
func Messages(messages ...Message) utils.OptionFunc[pubOption] <span class="cov7" title="80">{
        return func(o *pubOption) </span><span class="cov7" title="80">{ o.messages = messages }</span>
}
func messages(messages ...*mw.Message) utils.OptionFunc[pubOption] <span class="cov7" title="78">{
        return func(o *pubOption) </span><span class="cov7" title="80">{
                o.watermillMessages = messages
        }</span>
}
func Async(strategies ...strategy.Strategy) utils.OptionFunc[pubOption] <span class="cov0" title="0">{
        return func(o *pubOption) </span><span class="cov0" title="0">{
                o.async = true
                o.asyncStrategies = strategies
        }</span>
}
func Events[T eventual](events ...Event[T]) utils.OptionFunc[eventPubOption[T]] <span class="cov7" title="80">{
        return func(o *eventPubOption[T]) </span><span class="cov7" title="80">{
                o.events = events
        }</span>
}

type subOption struct {
        channelLength int
}

func ChannelLen(channelLength int) utils.OptionFunc[subOption] <span class="cov5" title="16">{
        return func(o *subOption) </span><span class="cov5" title="16">{
                o.channelLength = channelLength
        }</span>
}

type routerOption struct {
        isEventSubscriber bool
}

func handleEventSubscriber() utils.OptionFunc[routerOption] <span class="cov4" title="8">{
        return func(o *routerOption) </span><span class="cov4" title="8">{
                o.isEventSubscriber = true
        }</span>
}

type message struct {
        *mw.Message

        payload []byte
        obj     any
}

func NewMessage(uuid string, payload []byte) Message <span class="cov7" title="80">{
        return &amp;message{Message: mw.NewMessage(uuid, payload), payload: payload}
}</span>
func (m *message) ID() string      <span class="cov10" title="280">{ return m.Message.UUID }</span>
func (m *message) Payload() []byte <span class="cov9" title="160">{ return m.payload }</span>
func (m *message) RawMessage() any <span class="cov0" title="0">{ return m.Message }</span>
func (m *message) Object() any     <span class="cov0" title="0">{ return m.obj }</span>

// Conf mq config
//nolint: revive // struct tag too long issue
type Conf struct {
        Topic               string        `yaml:"topic" json:"topic" toml:"topic"`
        Type                mqType        `yaml:"type" json:"type" toml:"type"`
        Producer            bool          `yaml:"producer" json:"producer" toml:"producer" default:"true"`
        Consumer            bool          `yaml:"consumer" json:"consumer" toml:"consumer"`
        ConsumerGroup       string        `yaml:"consumer_group" json:"consumer_group" toml:"consumer_group"`
        ConsumerConcurrency int           `yaml:"consumer_concurrency" json:"consumer_concurrency" toml:"consumer_concurrency"`
        Endpoint            *endpointConf `yaml:"endpoint" json:"endpoint" toml:"endpoint"`
        Persistent          bool          `yaml:"persistent" json:"persistent" toml:"persistent"`
        SerializeType       string        `yaml:"serialize_type" json:"serialize_type" toml:"serialize_type"`
        CompressType        string        `yaml:"compress_type" json:"compress_type" toml:"compress_type"`

        EnableLogger bool   `yaml:"enable_logger" json:"enable_logger" toml:"enable_logger" default:"false"`
        Logger       string `yaml:"logger" json:"logger" toml:"logger" default:"github.com/wfusion/gofusion/log/customlogger.mqLogger"`
        LogInstance  string `yaml:"log_instance" json:"log_instance" toml:"log_instance" default:"default"`

        // mongo, mysql, mariadb option
        MessageScheme  string `yaml:"message_scheme" json:"message_scheme" toml:"message_scheme" default:"watermill_message"`
        SeriesScheme   string `yaml:"series_scheme" json:"series_scheme" toml:"series_scheme" default:"watermill_series"`
        ConsumerScheme string `yaml:"consumer_scheme" json:"consumer_scheme" toml:"consumer_scheme" default:"watermill_subscriber"`

        ConsumeMiddlewares []*middlewareConf `yaml:"consume_middlewares" json:"consume_middlewares" toml:"consume_middlewares"`
}

type endpointConf struct {
        Addresses    []string     `yaml:"addresses" json:"addresses" toml:"addresses"`
        User         string       `yaml:"user" json:"user" toml:"user"`
        Password     string       `yaml:"password" json:"password" toml:"password" encrypted:""`
        AuthType     string       `yaml:"auth_type" json:"auth_type" toml:"auth_type"`
        Instance     string       `yaml:"instance" json:"instance" toml:"instance"`
        InstanceType instanceType `yaml:"instance_type" json:"instance_type" toml:"instance_type"`
        Version      string       `yaml:"version" json:"version" toml:"version"`
}

// middlewareConf consume middleware config
//nolint: revive // struct tag too long issue
type middlewareConf struct {
        Type middlewareType `yaml:"type" json:"type" toml:"type"`

        // Throttle middleware
        // Example duration and count: NewThrottle(10, time.Second) for 10 messages per second
        ThrottleCount    int    `yaml:"throttle_count" json:"throttle_count" toml:"throttle_count"`
        ThrottleDuration string `yaml:"throttle_duration" json:"throttle_duration" toml:"throttle_duration"`

        // Retry middleware
        // MaxRetries is maximum number of times a retry will be attempted.
        RetryMaxRetries int `yaml:"retry_max_retries" json:"retry_max_retries" toml:"retry_max_retries"`
        // RetryInitialInterval is the first interval between retries. Subsequent intervals will be scaled by Multiplier.
        RetryInitialInterval string `yaml:"retry_initial_interval" json:"retry_initial_interval" toml:"retry_initial_interval"`
        // RetryMaxInterval sets the limit for the exponential backoff of retries. The interval will not be increased beyond MaxInterval.
        RetryMaxInterval string `yaml:"retry_max_interval" json:"retry_max_interval" toml:"retry_max_interval"`
        // RetryMultiplier is the factor by which the waiting interval will be multiplied between retries.
        RetryMultiplier float64 `yaml:"retry_multiplier" json:"retry_multiplier" toml:"retry_multiplier"`
        // RetryMaxElapsedTime sets the time limit of how long retries will be attempted. Disabled if 0.
        RetryMaxElapsedTime string `yaml:"retry_max_elapsed_time" json:"retry_max_elapsed_time" toml:"retry_max_elapsed_time"`
        // RetryRandomizationFactor randomizes the spread of the backoff times within the interval of:
        // [currentInterval * (1 - randomization_factor), currentInterval * (1 + randomization_factor)].
        RetryRandomizationFactor float64 `yaml:"retry_randomization_factor" json:"retry_randomization_factor" toml:"retry_randomization_factor"`

        // Poison middleware
        // PoisonTopic salvages unprocessable messages and published them on a separate topic
        PoisonTopic string `yaml:"poison_topic" json:"poison_topic" toml:"poison_topic"`

        // Timeout middleware
        Timeout string `yaml:"timeout" json:"timeout" toml:"timeout"`

        // CircuitBreaker middleware
        // CircuitBreakerMaxRequests is the maximum number of requests allowed to pass through
        // when the CircuitBreaker is half-open.
        // If CircuitBreakerMaxRequests is 0, the CircuitBreaker allows only 1 request.
        CircuitBreakerMaxRequests uint `yaml:"circuit_breaker_max_requests" json:"circuit_breaker_max_requests" toml:"circuit_breaker_max_requests"`
        // CircuitBreakerInterval is the cyclic period of the closed state
        // for the CircuitBreaker to clear the internal Counts.
        // If CircuitBreakerInterval is less than or equal to 0, the CircuitBreaker doesn't clear internal Counts during the closed state.
        CircuitBreakerInterval string `yaml:"circuit_breaker_interval" json:"circuit_breaker_interval" toml:"circuit_breaker_interval"`
        // CircuitBreakerTimeout is the period of the open state,
        // after which the state of the CircuitBreaker becomes half-open.
        // If CircuitBreakerTimeout is less than or equal to 0, the timeout value of the CircuitBreaker is set to 60 seconds.
        CircuitBreakerTimeout string `yaml:"circuit_breaker_timeout" json:"circuit_breaker_timeout" toml:"circuit_breaker_timeout"`
        // CircuitBreakerTripExpr ready to trip expression
        // support params: requests, total_successes, total_failures, consecutive_successes, consecutive_failures
        CircuitBreakerTripExpr string `yaml:"circuit_breaker_trip_expr" json:"circuit_breaker_trip_expr" toml:"circuit_breaker_trip_expr"`
}

type mqType string

const (
        mqTypeAMQP      mqType = "amqp"
        mqTypeRabbitmq  mqType = "rabbitmq"
        mqTypeGoChannel mqType = "gochannel"
        mqTypeKafka     mqType = "kafka"
        mqTypePulsar    mqType = "pulsar"
        mqTypeRedis     mqType = "redis"
        mqTypeRocketmq  mqType = "rocketmq"
        mqTypeMysql     mqType = "mysql"
        mqTypePostgres  mqType = "postgres"
)

type instanceType string

const (
        instanceTypeDB    instanceType = "db"
        instanceTypeRedis instanceType = "redis"
        instanceTypeMongo instanceType = "mongo"
)

type middlewareType string

const (
        middlewareTypeThrottle       middlewareType = "throttle"
        middlewareTypeRetry          middlewareType = "retry"
        middlewareTypeInstanceAck    middlewareType = "instance_ack"
        middlewareTypePoison         middlewareType = "poison"
        middlewareTypeTimeout        middlewareType = "timeout"
        middlewareTypeCircuitBreaker middlewareType = "circuit_breaker"
)

type customLogger interface {
        Init(log log.Logable, appName, name string)
}
</pre>
		
		<pre class="file" id="file185" style="display: none">package mq

import (
        "reflect"
)

func wrapParams(fn any) (argType reflect.Type) <span class="cov0" title="0">{
        typ := reflect.TypeOf(fn)

        inLength := typ.NumIn()
        if inLength == 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if inLength &gt;= 2 </span><span class="cov0" title="0">{
                return typ.In(1)
        }</span>

        <span class="cov0" title="0">return</span>
}

func unwrapParams(typ reflect.Type, arg any) (params []any) <span class="cov0" title="0">{
        if typ == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return []any{arg}</span>
}

func setParams(typ reflect.Type, embed bool, params ...any) (arg any) <span class="cov0" title="0">{
        if typ == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">argValPtr := reflect.New(typ)
        argVal := argValPtr.Elem()
        if !embed </span><span class="cov0" title="0">{
                if len(params) &gt; 0 </span><span class="cov0" title="0">{
                        argVal.Set(reflect.ValueOf(params[0]))
                }</span>
                <span class="cov0" title="0">return argValPtr.Interface()</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt; len(params); i++ </span><span class="cov0" title="0">{
                ft := argVal.Field(i)
                ft.Set(reflect.ValueOf(params[i]).Convert(ft.Type()))
        }</span>
        <span class="cov0" title="0">return argValPtr.Interface()</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">package redis

import (
        "context"
        "log"
        "reflect"
        "syscall"

        rdsDrv "github.com/redis/go-redis/v9"
        "github.com/wfusion/gofusion/common/di"
        "github.com/wfusion/gofusion/common/infra/drivers/redis"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/config"

        fmkLog "github.com/wfusion/gofusion/log"

        _ "github.com/wfusion/gofusion/log/customlogger"
)

func Construct(ctx context.Context, confs map[string]*Conf, opts ...utils.OptionExtender) func() <span class="cov10" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[useOption](opts...)
        if opt.AppName == "" </span><span class="cov5" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov10" title="34">for name, conf := range confs </span><span class="cov8" title="18">{
                addInstance(ctx, name, conf, opt)
        }</span>
        <span class="cov10" title="34">return func() </span><span class="cov10" title="34">{
                rwlock.Lock()
                defer rwlock.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                if appInstances != nil </span><span class="cov8" title="20">{
                        for name, instance := range appInstances[opt.AppName] </span><span class="cov8" title="18">{
                                if err := instance.GetProxy().Close(); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("%v [Gofusion] %s %s %s close error: %s",
                                                pid, app, config.ComponentRedis, name, err)
                                }</span>
                        }
                        <span class="cov8" title="20">delete(appInstances, opt.AppName)</span>
                }
        }
}

func addInstance(ctx context.Context, name string, conf *Conf, opt *config.InitOption) <span class="cov8" title="18">{
        var hooks []rdsDrv.Hook
        for _, hookLoc := range conf.Hooks </span><span class="cov8" title="18">{
                if hookType := inspect.TypeOf(hookLoc); hookType != nil </span><span class="cov8" title="18">{
                        hookValue := reflect.New(hookType)
                        if hookValue.Type().Implements(customLoggerType) </span><span class="cov8" title="18">{
                                logger := fmkLog.Use(conf.LogInstance, fmkLog.AppName(opt.AppName))
                                hookValue.Interface().(customLogger).Init(logger, opt.AppName, name)
                        }</span>

                        <span class="cov8" title="18">hooks = append(hooks, hookValue.Interface().(rdsDrv.Hook))</span>
                }
        }

        // conf.Option.Password = config.CryptoDecryptFunc()(conf.Option.Password)
        <span class="cov8" title="18">rdsCli, err := redis.Default.New(ctx, conf.Option, redis.WithHook(hooks))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="18">rwlock.Lock()
        defer rwlock.Unlock()
        if appInstances == nil </span><span class="cov5" title="7">{
                appInstances = make(map[string]map[string]*instance)
        }</span>
        <span class="cov8" title="18">if appInstances[opt.AppName] == nil </span><span class="cov8" title="18">{
                appInstances[opt.AppName] = make(map[string]*instance)
        }</span>
        <span class="cov8" title="18">if _, ok := appInstances[opt.AppName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedName)</span>
        }
        <span class="cov8" title="18">appInstances[opt.AppName][name] = &amp;instance{name: name, redis: rdsCli}

        if opt.DI != nil </span><span class="cov8" title="18">{
                opt.DI.MustProvide(func() rdsDrv.UniversalClient </span><span class="cov0" title="0">{ return Use(ctx, name, AppName(opt.AppName)) }</span>, di.Name(name))
        }

        <span class="cov8" title="18">go startDaemonRoutines(ctx, opt.AppName, name, conf)</span>
}

func init() <span class="cov7" title="14">{
        config.AddComponent(config.ComponentRedis, Construct)
}</span>
</pre>
		
		<pre class="file" id="file187" style="display: none">package redis

import (
        "context"
        "log"
        "syscall"
        "time"

        "github.com/spf13/cast"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/metrics"
)

var (
        metricsPoolIdleKey    = []string{"redis", "idle"}
        metricsPoolTotalKey   = []string{"redis", "total"}
        metricsPoolStaleKey   = []string{"redis", "stale"}
        metricsPoolHitsKey    = []string{"redis", "hits"}
        metricsPoolMissesKey  = []string{"redis", "misses"}
        metricsLatencyKey     = []string{"redis", "latency"}
        metricsLatencyBuckets = []float64{
                .1, .25, .5, .75, .90, .95, .99,
                1, 2.5, 5, 7.5, 9, 9.5, 9.9,
                10, 25, 50, 75, 90, 95, 99,
                100, 250, 500, 750, 900, 950, 990,
        }
)

func startDaemonRoutines(ctx context.Context, appName, name string, conf *Conf) <span class="cov7" title="18">{
        ticker := time.Tick(time.Second * 5)
        app := config.Use(appName).AppName()
        labels := []metrics.Label{
                {Key: "config", Value: name},
                {Key: "database", Value: cast.ToString(conf.DB)},
        }

        for </span><span class="cov10" title="76">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov7" title="18">
                        log.Printf("%v [Gofusion] %s %s %s metrics exited",
                                syscall.Getpid(), app, config.ComponentRedis, name)
                        return</span>
                case &lt;-ticker:<span class="cov9" title="58">
                        go metricRedisStats(ctx, appName, name, labels)
                        go metricRedisLatency(ctx, appName, name, labels)</span>
                }
        }
}

func metricRedisStats(ctx context.Context, appName, name string, labels []metrics.Label) <span class="cov9" title="58">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov9" title="58"></span>

        }

        <span class="cov9" title="58">_, _ = utils.Catch(func() </span><span class="cov9" title="58">{
                rwlock.RLock()
                defer rwlock.RUnlock()
                _ = appInstances[appName][name].GetProxy()
                instances, ok := appInstances[appName]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="58">instance, ok := instances[name]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov9" title="58">app := config.Use(appName).AppName()
                idleKey := append([]string{app}, metricsPoolIdleKey...)
                staleKey := append([]string{app}, metricsPoolStaleKey...)
                totalKey := append([]string{app}, metricsPoolTotalKey...)
                hitsKey := append([]string{app}, metricsPoolHitsKey...)
                missesKey := append([]string{app}, metricsPoolMissesKey...)

                rdsCli := instance.GetProxy()
                stats := rdsCli.PoolStats()
                for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                if m.IsEnableServiceLabel() </span><span class="cov0" title="0">{
                                        m.SetGauge(ctx, idleKey, float64(stats.IdleConns), metrics.Labels(labels))
                                        m.SetGauge(ctx, staleKey, float64(stats.StaleConns), metrics.Labels(labels))
                                        m.SetGauge(ctx, totalKey, float64(stats.TotalConns), metrics.Labels(labels))
                                        m.SetGauge(ctx, hitsKey, float64(stats.Hits), metrics.Labels(labels))
                                        m.SetGauge(ctx, missesKey, float64(stats.Misses), metrics.Labels(labels))
                                }</span> else<span class="cov0" title="0"> {
                                        m.SetGauge(ctx, metricsPoolIdleKey, float64(stats.IdleConns), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolStaleKey, float64(stats.StaleConns), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolTotalKey, float64(stats.TotalConns), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolHitsKey, float64(stats.Hits), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsPoolMissesKey, float64(stats.Misses), metrics.Labels(labels))
                                }</span>
                        }
                }
        })
}

func metricRedisLatency(ctx context.Context, appName, name string, labels []metrics.Label) <span class="cov9" title="58">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov9" title="58"></span>

        }

        <span class="cov9" title="58">_, _ = utils.Catch(func() </span><span class="cov9" title="58">{
                rwlock.RLock()
                defer rwlock.RUnlock()
                instances, ok := appInstances[appName]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov9" title="58">instance, ok := instances[name]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov9" title="58">rdsCli := instance.GetProxy()
                begin := time.Now()
                if err := rdsCli.Ping(ctx); err != nil </span><span class="cov9" title="58">{
                        return
                }</span>

                <span class="cov0" title="0">latency := float64(time.Since(begin)) / float64(time.Millisecond)
                latencyKey := append([]string{config.Use(appName).AppName()}, metricsLatencyKey...)
                for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                if m.IsEnableServiceLabel() </span><span class="cov0" title="0">{
                                        m.AddSample(ctx, latencyKey, latency,
                                                metrics.Labels(labels),
                                                metrics.PrometheusBuckets(metricsLatencyBuckets),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        m.AddSample(ctx, metricsLatencyKey, latency,
                                                metrics.Labels(labels),
                                                metrics.PrometheusBuckets(metricsLatencyBuckets),
                                        )
                                }</span>
                        }
                }
        })
}
</pre>
		
		<pre class="file" id="file188" style="display: none">package redis

import (
        "context"
        "sync"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/infra/drivers/redis"
        "github.com/wfusion/gofusion/common/utils"

        rdsDrv "github.com/redis/go-redis/v9"
)

var (
        rwlock       = new(sync.RWMutex)
        appInstances map[string]map[string]*instance
)

type instance struct {
        name  string
        redis *redis.Redis
}

func (i *instance) GetProxy() rdsDrv.UniversalClient <span class="cov10" title="8479">{
        return i.redis.GetProxy()
}</span>

type Redis struct {
        rdsDrv.UniversalClient
        Name string
}

type useOption struct {
        appName string
}

func AppName(name string) utils.OptionFunc[useOption] <span class="cov9" title="5563">{
        return func(o *useOption) </span><span class="cov9" title="5486">{
                o.appName = name
        }</span>
}

func Use(ctx context.Context, name string, opts ...utils.OptionExtender) rdsDrv.UniversalClient <span class="cov9" title="5566">{
        opt := utils.ApplyOptions[useOption](opts...)

        rwlock.RLock()
        defer rwlock.RUnlock()
        instances, ok := appInstances[opt.appName]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("redis instance not found for app: %s", opt.appName))</span>
        }
        <span class="cov9" title="5630">instance, ok := instances[name]
        if !ok </span><span class="cov0" title="0">{
                panic(errors.Errorf("redis instance not found for name: %s", name))</span>
        }
        <span class="cov9" title="5629">return &amp;Redis{UniversalClient: instance, Name: name}</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">package redis

import (
        "context"
        "time"

        rdsDrv "github.com/redis/go-redis/v9"
)

func (i *instance) Pipeline() rdsDrv.Pipeliner <span class="cov9" title="1509">{
        return i.GetProxy().Pipeline()
}</span>
func (i *instance) Pipelined(ctx context.Context, fn func(rdsDrv.Pipeliner) error) ([]rdsDrv.Cmder, error) <span class="cov0" title="0">{
        return i.GetProxy().Pipelined(ctx, fn)
}</span>
func (i *instance) TxPipelined(ctx context.Context, fn func(rdsDrv.Pipeliner) error) ([]rdsDrv.Cmder, error) <span class="cov0" title="0">{
        return i.GetProxy().TxPipelined(ctx, fn)
}</span>
func (i *instance) TxPipeline() rdsDrv.Pipeliner <span class="cov0" title="0">{
        return i.GetProxy().TxPipeline()
}</span>
func (i *instance) Command(ctx context.Context) *rdsDrv.CommandsInfoCmd <span class="cov0" title="0">{
        return i.GetProxy().Command(ctx)
}</span>
func (i *instance) CommandList(ctx context.Context, filter *rdsDrv.FilterBy) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().CommandList(ctx, filter)
}</span>
func (i *instance) CommandGetKeys(ctx context.Context, commands ...any) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().CommandGetKeys(ctx, commands...)
}</span>
func (i *instance) CommandGetKeysAndFlags(ctx context.Context, commands ...any) *rdsDrv.KeyFlagsCmd <span class="cov0" title="0">{
        return i.GetProxy().CommandGetKeysAndFlags(ctx, commands...)
}</span>
func (i *instance) ClientGetName(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientGetName(ctx)
}</span>
func (i *instance) Echo(ctx context.Context, message any) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().Echo(ctx, message)
}</span>
func (i *instance) Ping(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Ping(ctx)
}</span>
func (i *instance) Quit(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Quit(ctx)
}</span>
func (i *instance) Del(ctx context.Context, keys ...string) *rdsDrv.IntCmd <span class="cov6" title="132">{
        return i.GetProxy().Del(ctx, keys...)
}</span>
func (i *instance) Unlink(ctx context.Context, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Unlink(ctx, keys...)
}</span>
func (i *instance) Dump(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().Dump(ctx, key)
}</span>
func (i *instance) Exists(ctx context.Context, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Exists(ctx, keys...)
}</span>
func (i *instance) Expire(ctx context.Context, key string, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().Expire(ctx, key, expiration)
}</span>
func (i *instance) ExpireAt(ctx context.Context, key string, tm time.Time) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().ExpireAt(ctx, key, tm)
}</span>
func (i *instance) ExpireTime(ctx context.Context, key string) *rdsDrv.DurationCmd <span class="cov0" title="0">{
        return i.GetProxy().ExpireTime(ctx, key)
}</span>
func (i *instance) ExpireNX(ctx context.Context, key string, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().ExpireNX(ctx, key, expiration)
}</span>
func (i *instance) ExpireXX(ctx context.Context, key string, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().ExpireXX(ctx, key, expiration)
}</span>
func (i *instance) ExpireGT(ctx context.Context, key string, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().ExpireGT(ctx, key, expiration)
}</span>
func (i *instance) ExpireLT(ctx context.Context, key string, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().ExpireLT(ctx, key, expiration)
}</span>
func (i *instance) Keys(ctx context.Context, pattern string) *rdsDrv.StringSliceCmd <span class="cov3" title="8">{
        return i.GetProxy().Keys(ctx, pattern)
}</span>
func (i *instance) Migrate(ctx context.Context, host, port, key string, db int,
        timeout time.Duration) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Migrate(ctx, host, port, key, db, timeout)
}</span>
func (i *instance) Move(ctx context.Context, key string, db int) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().Move(ctx, key, db)
}</span>
func (i *instance) ObjectRefCount(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ObjectRefCount(ctx, key)
}</span>
func (i *instance) ObjectEncoding(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ObjectEncoding(ctx, key)
}</span>
func (i *instance) ObjectIdleTime(ctx context.Context, key string) *rdsDrv.DurationCmd <span class="cov0" title="0">{
        return i.GetProxy().ObjectIdleTime(ctx, key)
}</span>
func (i *instance) Persist(ctx context.Context, key string) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().Persist(ctx, key)
}</span>
func (i *instance) PExpire(ctx context.Context, key string, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().PExpire(ctx, key, expiration)
}</span>
func (i *instance) PExpireAt(ctx context.Context, key string, tm time.Time) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().PExpireAt(ctx, key, tm)
}</span>
func (i *instance) PExpireTime(ctx context.Context, key string) *rdsDrv.DurationCmd <span class="cov0" title="0">{
        return i.GetProxy().PExpireTime(ctx, key)
}</span>
func (i *instance) PTTL(ctx context.Context, key string) *rdsDrv.DurationCmd <span class="cov0" title="0">{
        return i.GetProxy().PTTL(ctx, key)
}</span>
func (i *instance) RandomKey(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().RandomKey(ctx)
}</span>
func (i *instance) Rename(ctx context.Context, key, newkey string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Rename(ctx, key, newkey)
}</span>
func (i *instance) RenameNX(ctx context.Context, key, newkey string) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().RenameNX(ctx, key, newkey)
}</span>
func (i *instance) Restore(ctx context.Context, key string, ttl time.Duration, value string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Restore(ctx, key, ttl, value)
}</span>
func (i *instance) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().RestoreReplace(ctx, key, ttl, value)
}</span>
func (i *instance) Sort(ctx context.Context, key string, sort *rdsDrv.Sort) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().Sort(ctx, key, sort)
}</span>
func (i *instance) SortRO(ctx context.Context, key string, sort *rdsDrv.Sort) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SortRO(ctx, key, sort)
}</span>
func (i *instance) SortStore(ctx context.Context, key, store string, sort *rdsDrv.Sort) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SortStore(ctx, key, store, sort)
}</span>
func (i *instance) SortInterfaces(ctx context.Context, key string, sort *rdsDrv.Sort) *rdsDrv.SliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SortInterfaces(ctx, key, sort)
}</span>
func (i *instance) Touch(ctx context.Context, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Touch(ctx, keys...)
}</span>
func (i *instance) TTL(ctx context.Context, key string) *rdsDrv.DurationCmd <span class="cov0" title="0">{
        return i.GetProxy().TTL(ctx, key)
}</span>
func (i *instance) Type(ctx context.Context, key string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Type(ctx, key)
}</span>
func (i *instance) Append(ctx context.Context, key, value string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Append(ctx, key, value)
}</span>
func (i *instance) Decr(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Decr(ctx, key)
}</span>
func (i *instance) DecrBy(ctx context.Context, key string, decrement int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().DecrBy(ctx, key, decrement)
}</span>
func (i *instance) Get(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov1" title="1">{
        return i.GetProxy().Get(ctx, key)
}</span>
func (i *instance) GetRange(ctx context.Context, key string, start, end int64) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().GetRange(ctx, key, start, end)
}</span>
func (i *instance) GetSet(ctx context.Context, key string, value any) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().GetSet(ctx, key, value)
}</span>
func (i *instance) GetEx(ctx context.Context, key string, expiration time.Duration) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().GetEx(ctx, key, expiration)
}</span>
func (i *instance) GetDel(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().GetDel(ctx, key)
}</span>
func (i *instance) Incr(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Incr(ctx, key)
}</span>
func (i *instance) IncrBy(ctx context.Context, key string, value int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().IncrBy(ctx, key, value)
}</span>
func (i *instance) IncrByFloat(ctx context.Context, key string, value float64) *rdsDrv.FloatCmd <span class="cov0" title="0">{
        return i.GetProxy().IncrByFloat(ctx, key, value)
}</span>
func (i *instance) MGet(ctx context.Context, keys ...string) *rdsDrv.SliceCmd <span class="cov9" title="1008">{
        return i.GetProxy().MGet(ctx, keys...)
}</span>
func (i *instance) MSet(ctx context.Context, values ...any) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().MSet(ctx, values...)
}</span>
func (i *instance) MSetNX(ctx context.Context, values ...any) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().MSetNX(ctx, values...)
}</span>
func (i *instance) Set(ctx context.Context, key string, value any, expiration time.Duration) *rdsDrv.StatusCmd <span class="cov1" title="1">{
        return i.GetProxy().Set(ctx, key, value, expiration)
}</span>
func (i *instance) SetArgs(ctx context.Context, key string, value any, a rdsDrv.SetArgs) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().SetArgs(ctx, key, value, a)
}</span>
func (i *instance) SetEx(ctx context.Context, key string, value any,
        expiration time.Duration) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().SetEx(ctx, key, value, expiration)
}</span>
func (i *instance) SetNX(ctx context.Context, key string, value any, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov9" title="1472">{
        return i.GetProxy().SetNX(ctx, key, value, expiration)
}</span>
func (i *instance) SetXX(ctx context.Context, key string, value any, expiration time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().SetXX(ctx, key, value, expiration)
}</span>
func (i *instance) SetRange(ctx context.Context, key string, offset int64, value string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SetRange(ctx, key, offset, value)
}</span>
func (i *instance) StrLen(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().StrLen(ctx, key)
}</span>
func (i *instance) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Copy(ctx, sourceKey, destKey, db, replace)
}</span>
func (i *instance) GetBit(ctx context.Context, key string, offset int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().GetBit(ctx, key, offset)
}</span>
func (i *instance) SetBit(ctx context.Context, key string, offset int64, value int) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SetBit(ctx, key, offset, value)
}</span>
func (i *instance) BitCount(ctx context.Context, key string, bitCount *rdsDrv.BitCount) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().BitCount(ctx, key, bitCount)
}</span>
func (i *instance) BitOpAnd(ctx context.Context, destKey string, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().BitOpAnd(ctx, destKey, keys...)
}</span>
func (i *instance) BitOpOr(ctx context.Context, destKey string, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().BitOpOr(ctx, destKey, keys...)
}</span>
func (i *instance) BitOpXor(ctx context.Context, destKey string, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().BitOpXor(ctx, destKey, keys...)
}</span>
func (i *instance) BitOpNot(ctx context.Context, destKey string, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().BitOpNot(ctx, destKey, key)
}</span>
func (i *instance) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().BitPos(ctx, key, bit, pos...)
}</span>
func (i *instance) BitPosSpan(ctx context.Context, key string, bit int8, start, end int64, span string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().BitPosSpan(ctx, key, bit, start, end, span)
}</span>
func (i *instance) BitField(ctx context.Context, key string, args ...any) *rdsDrv.IntSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().BitField(ctx, key, args...)
}</span>
func (i *instance) Scan(ctx context.Context, cursor uint64, match string, count int64) *rdsDrv.ScanCmd <span class="cov0" title="0">{
        return i.GetProxy().Scan(ctx, cursor, match, count)
}</span>
func (i *instance) ScanType(ctx context.Context, cursor uint64, match string, count int64,
        keyType string) *rdsDrv.ScanCmd <span class="cov0" title="0">{
        return i.GetProxy().ScanType(ctx, cursor, match, count, keyType)
}</span>
func (i *instance) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *rdsDrv.ScanCmd <span class="cov0" title="0">{
        return i.GetProxy().SScan(ctx, key, cursor, match, count)
}</span>
func (i *instance) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *rdsDrv.ScanCmd <span class="cov0" title="0">{
        return i.GetProxy().HScan(ctx, key, cursor, match, count)
}</span>
func (i *instance) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *rdsDrv.ScanCmd <span class="cov0" title="0">{
        return i.GetProxy().ZScan(ctx, key, cursor, match, count)
}</span>
func (i *instance) HDel(ctx context.Context, key string, fields ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().HDel(ctx, key, fields...)
}</span>
func (i *instance) HExists(ctx context.Context, key, field string) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().HExists(ctx, key, field)
}</span>
func (i *instance) HGet(ctx context.Context, key, field string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().HGet(ctx, key, field)
}</span>
func (i *instance) HGetAll(ctx context.Context, key string) *rdsDrv.MapStringStringCmd <span class="cov0" title="0">{
        return i.GetProxy().HGetAll(ctx, key)
}</span>
func (i *instance) HIncrBy(ctx context.Context, key, field string, incr int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().HIncrBy(ctx, key, field, incr)
}</span>
func (i *instance) HIncrByFloat(ctx context.Context, key, field string, incr float64) *rdsDrv.FloatCmd <span class="cov0" title="0">{
        return i.GetProxy().HIncrByFloat(ctx, key, field, incr)
}</span>
func (i *instance) HKeys(ctx context.Context, key string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().HKeys(ctx, key)
}</span>
func (i *instance) HLen(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().HLen(ctx, key)
}</span>
func (i *instance) HMGet(ctx context.Context, key string, fields ...string) *rdsDrv.SliceCmd <span class="cov0" title="0">{
        return i.GetProxy().HMGet(ctx, key, fields...)
}</span>
func (i *instance) HSet(ctx context.Context, key string, values ...any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().HSet(ctx, key, values...)
}</span>
func (i *instance) HMSet(ctx context.Context, key string, values ...any) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().HMSet(ctx, key, values...)
}</span>
func (i *instance) HSetNX(ctx context.Context, key, field string, value any) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().HSetNX(ctx, key, field, value)
}</span>
func (i *instance) HVals(ctx context.Context, key string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().HVals(ctx, key)
}</span>
func (i *instance) HRandField(ctx context.Context, key string, count int) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().HRandField(ctx, key, count)
}</span>
func (i *instance) HRandFieldWithValues(ctx context.Context, key string, count int) *rdsDrv.KeyValueSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().HRandFieldWithValues(ctx, key, count)
}</span>
func (i *instance) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().BLPop(ctx, timeout, keys...)
}</span>
func (i *instance) BLMPop(ctx context.Context, timeout time.Duration, direction string,
        count int64, keys ...string) *rdsDrv.KeyValuesCmd <span class="cov0" title="0">{
        return i.GetProxy().BLMPop(ctx, timeout, direction, count, keys...)
}</span>
func (i *instance) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().BRPop(ctx, timeout, keys...)
}</span>
func (i *instance) BRPopLPush(ctx context.Context, source, destination string,
        timeout time.Duration) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().BRPopLPush(ctx, source, destination, timeout)
}</span>
func (i *instance) LCS(ctx context.Context, q *rdsDrv.LCSQuery) *rdsDrv.LCSCmd <span class="cov0" title="0">{
        return i.GetProxy().LCS(ctx, q)
}</span>
func (i *instance) LIndex(ctx context.Context, key string, index int64) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().LIndex(ctx, key, index)
}</span>
func (i *instance) LMPop(ctx context.Context, direction string, count int64, keys ...string) *rdsDrv.KeyValuesCmd <span class="cov0" title="0">{
        return i.GetProxy().LMPop(ctx, direction, count, keys...)
}</span>
func (i *instance) LInsert(ctx context.Context, key, op string, pivot, value any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LInsert(ctx, key, op, pivot, value)
}</span>
func (i *instance) LInsertBefore(ctx context.Context, key string, pivot, value any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LInsertBefore(ctx, key, pivot, value)
}</span>
func (i *instance) LInsertAfter(ctx context.Context, key string, pivot, value any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LInsertAfter(ctx, key, pivot, value)
}</span>
func (i *instance) LLen(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LLen(ctx, key)
}</span>
func (i *instance) LPop(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().LPop(ctx, key)
}</span>
func (i *instance) LPopCount(ctx context.Context, key string, count int) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().LPopCount(ctx, key, count)
}</span>
func (i *instance) LPos(ctx context.Context, key string, value string, args rdsDrv.LPosArgs) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LPos(ctx, key, value, args)
}</span>
func (i *instance) LPosCount(ctx context.Context, key string, value string, count int64,
        args rdsDrv.LPosArgs) *rdsDrv.IntSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().LPosCount(ctx, key, value, count, args)
}</span>
func (i *instance) LPush(ctx context.Context, key string, values ...any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LPush(ctx, key, values...)
}</span>
func (i *instance) LPushX(ctx context.Context, key string, values ...any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LPushX(ctx, key, values...)
}</span>
func (i *instance) LRange(ctx context.Context, key string, start, stop int64) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().LRange(ctx, key, start, stop)
}</span>
func (i *instance) LRem(ctx context.Context, key string, count int64, value any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LRem(ctx, key, count, value)
}</span>
func (i *instance) LSet(ctx context.Context, key string, index int64, value any) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().LSet(ctx, key, index, value)
}</span>
func (i *instance) LTrim(ctx context.Context, key string, start, stop int64) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().LTrim(ctx, key, start, stop)
}</span>
func (i *instance) RPop(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().RPop(ctx, key)
}</span>
func (i *instance) RPopCount(ctx context.Context, key string, count int) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().RPopCount(ctx, key, count)
}</span>
func (i *instance) RPopLPush(ctx context.Context, source, destination string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().RPopLPush(ctx, source, destination)
}</span>
func (i *instance) RPush(ctx context.Context, key string, values ...any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().RPush(ctx, key, values...)
}</span>
func (i *instance) RPushX(ctx context.Context, key string, values ...any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().RPushX(ctx, key, values...)
}</span>
func (i *instance) LMove(ctx context.Context, source, destination, srcpos, destpos string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().LMove(ctx, source, destination, srcpos, destpos)
}</span>
func (i *instance) BLMove(ctx context.Context, source, destination, srcpos, destpos string,
        timeout time.Duration) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().BLMove(ctx, source, destination, srcpos, destpos, timeout)
}</span>
func (i *instance) SAdd(ctx context.Context, key string, members ...any) *rdsDrv.IntCmd <span class="cov5" title="46">{
        return i.GetProxy().SAdd(ctx, key, members...)
}</span>
func (i *instance) SCard(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SCard(ctx, key)
}</span>
func (i *instance) SDiff(ctx context.Context, keys ...string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SDiff(ctx, keys...)
}</span>
func (i *instance) SDiffStore(ctx context.Context, destination string, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SDiffStore(ctx, destination, keys...)
}</span>
func (i *instance) SInter(ctx context.Context, keys ...string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SInter(ctx, keys...)
}</span>
func (i *instance) SInterCard(ctx context.Context, limit int64, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SInterCard(ctx, limit, keys...)
}</span>
func (i *instance) SInterStore(ctx context.Context, destination string, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SInterStore(ctx, destination, keys...)
}</span>
func (i *instance) SIsMember(ctx context.Context, key string, member any) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().SIsMember(ctx, key, member)
}</span>
func (i *instance) SMIsMember(ctx context.Context, key string, members ...any) *rdsDrv.BoolSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SMIsMember(ctx, key, members...)
}</span>
func (i *instance) SMembers(ctx context.Context, key string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SMembers(ctx, key)
}</span>
func (i *instance) SMembersMap(ctx context.Context, key string) *rdsDrv.StringStructMapCmd <span class="cov0" title="0">{
        return i.GetProxy().SMembersMap(ctx, key)
}</span>
func (i *instance) SMove(ctx context.Context, source, destination string, member any) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().SMove(ctx, source, destination, member)
}</span>
func (i *instance) SPop(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().SPop(ctx, key)
}</span>
func (i *instance) SPopN(ctx context.Context, key string, count int64) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SPopN(ctx, key, count)
}</span>
func (i *instance) SRandMember(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().SRandMember(ctx, key)
}</span>
func (i *instance) SRandMemberN(ctx context.Context, key string, count int64) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SRandMemberN(ctx, key, count)
}</span>
func (i *instance) SRem(ctx context.Context, key string, members ...any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SRem(ctx, key, members...)
}</span>
func (i *instance) SUnion(ctx context.Context, keys ...string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().SUnion(ctx, keys...)
}</span>
func (i *instance) SUnionStore(ctx context.Context, destination string, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SUnionStore(ctx, destination, keys...)
}</span>
func (i *instance) XAdd(ctx context.Context, a *rdsDrv.XAddArgs) *rdsDrv.StringCmd <span class="cov4" title="20">{
        return i.GetProxy().XAdd(ctx, a)
}</span>
func (i *instance) XDel(ctx context.Context, stream string, ids ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XDel(ctx, stream, ids...)
}</span>
func (i *instance) XLen(ctx context.Context, stream string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XLen(ctx, stream)
}</span>
func (i *instance) XRange(ctx context.Context, stream, start, stop string) *rdsDrv.XMessageSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().XRange(ctx, stream, start, stop)
}</span>
func (i *instance) XRangeN(ctx context.Context, stream, start, stop string, count int64) *rdsDrv.XMessageSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().XRangeN(ctx, stream, start, stop, count)
}</span>
func (i *instance) XRevRange(ctx context.Context, stream string, start, stop string) *rdsDrv.XMessageSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().XRevRange(ctx, stream, start, stop)
}</span>
func (i *instance) XRevRangeN(ctx context.Context, stream string,
        start, stop string, count int64) *rdsDrv.XMessageSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().XRevRangeN(ctx, stream, start, stop, count)
}</span>
func (i *instance) XRead(ctx context.Context, a *rdsDrv.XReadArgs) *rdsDrv.XStreamSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().XRead(ctx, a)
}</span>
func (i *instance) XReadStreams(ctx context.Context, streams ...string) *rdsDrv.XStreamSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().XReadStreams(ctx, streams...)
}</span>
func (i *instance) XGroupCreate(ctx context.Context, stream, group, start string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().XGroupCreate(ctx, stream, group, start)
}</span>
func (i *instance) XGroupCreateMkStream(ctx context.Context, stream, group, start string) *rdsDrv.StatusCmd <span class="cov4" title="22">{
        return i.GetProxy().XGroupCreateMkStream(ctx, stream, group, start)
}</span>
func (i *instance) XGroupSetID(ctx context.Context, stream, group, start string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().XGroupSetID(ctx, stream, group, start)
}</span>
func (i *instance) XGroupDestroy(ctx context.Context, stream, group string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XGroupDestroy(ctx, stream, group)
}</span>
func (i *instance) XGroupCreateConsumer(ctx context.Context, stream, group, consumer string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XGroupCreateConsumer(ctx, stream, group, consumer)
}</span>
func (i *instance) XGroupDelConsumer(ctx context.Context, stream, group, consumer string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XGroupDelConsumer(ctx, stream, group, consumer)
}</span>
func (i *instance) XReadGroup(ctx context.Context, a *rdsDrv.XReadGroupArgs) *rdsDrv.XStreamSliceCmd <span class="cov9" title="1702">{
        return i.GetProxy().XReadGroup(ctx, a)
}</span>
func (i *instance) XAck(ctx context.Context, stream, group string, ids ...string) *rdsDrv.IntCmd <span class="cov4" title="20">{
        return i.GetProxy().XAck(ctx, stream, group, ids...)
}</span>
func (i *instance) XPending(ctx context.Context, stream, group string) *rdsDrv.XPendingCmd <span class="cov0" title="0">{
        return i.GetProxy().XPending(ctx, stream, group)
}</span>
func (i *instance) XPendingExt(ctx context.Context, a *rdsDrv.XPendingExtArgs) *rdsDrv.XPendingExtCmd <span class="cov6" title="152">{
        return i.GetProxy().XPendingExt(ctx, a)
}</span>
func (i *instance) XClaim(ctx context.Context, a *rdsDrv.XClaimArgs) *rdsDrv.XMessageSliceCmd <span class="cov1" title="1">{
        return i.GetProxy().XClaim(ctx, a)
}</span>
func (i *instance) XClaimJustID(ctx context.Context, a *rdsDrv.XClaimArgs) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().XClaimJustID(ctx, a)
}</span>
func (i *instance) XAutoClaim(ctx context.Context, a *rdsDrv.XAutoClaimArgs) *rdsDrv.XAutoClaimCmd <span class="cov0" title="0">{
        return i.GetProxy().XAutoClaim(ctx, a)
}</span>
func (i *instance) XAutoClaimJustID(ctx context.Context, a *rdsDrv.XAutoClaimArgs) *rdsDrv.XAutoClaimJustIDCmd <span class="cov0" title="0">{
        return i.GetProxy().XAutoClaimJustID(ctx, a)
}</span>
func (i *instance) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XTrimMaxLen(ctx, key, maxLen)
}</span>
func (i *instance) XTrimMaxLenApprox(ctx context.Context, key string, maxLen, limit int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XTrimMaxLenApprox(ctx, key, maxLen, limit)
}</span>
func (i *instance) XTrimMinID(ctx context.Context, key string, minID string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XTrimMinID(ctx, key, minID)
}</span>
func (i *instance) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().XTrimMinIDApprox(ctx, key, minID, limit)
}</span>
func (i *instance) XInfoGroups(ctx context.Context, key string) *rdsDrv.XInfoGroupsCmd <span class="cov0" title="0">{
        return i.GetProxy().XInfoGroups(ctx, key)
}</span>
func (i *instance) XInfoStream(ctx context.Context, key string) *rdsDrv.XInfoStreamCmd <span class="cov0" title="0">{
        return i.GetProxy().XInfoStream(ctx, key)
}</span>
func (i *instance) XInfoStreamFull(ctx context.Context, key string, count int) *rdsDrv.XInfoStreamFullCmd <span class="cov0" title="0">{
        return i.GetProxy().XInfoStreamFull(ctx, key, count)
}</span>
func (i *instance) XInfoConsumers(ctx context.Context, key string, group string) *rdsDrv.XInfoConsumersCmd <span class="cov0" title="0">{
        return i.GetProxy().XInfoConsumers(ctx, key, group)
}</span>
func (i *instance) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *rdsDrv.ZWithKeyCmd <span class="cov0" title="0">{
        return i.GetProxy().BZPopMax(ctx, timeout, keys...)
}</span>
func (i *instance) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *rdsDrv.ZWithKeyCmd <span class="cov0" title="0">{
        return i.GetProxy().BZPopMin(ctx, timeout, keys...)
}</span>
func (i *instance) BZMPop(ctx context.Context, timeout time.Duration, order string,
        count int64, keys ...string) *rdsDrv.ZSliceWithKeyCmd <span class="cov0" title="0">{
        return i.GetProxy().BZMPop(ctx, timeout, order, count, keys...)
}</span>
func (i *instance) ZAdd(ctx context.Context, key string, members ...rdsDrv.Z) *rdsDrv.IntCmd <span class="cov5" title="30">{
        return i.GetProxy().ZAdd(ctx, key, members...)
}</span>
func (i *instance) ZAddLT(ctx context.Context, key string, members ...rdsDrv.Z) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZAddLT(ctx, key, members...)
}</span>
func (i *instance) ZAddGT(ctx context.Context, key string, members ...rdsDrv.Z) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZAddGT(ctx, key, members...)
}</span>
func (i *instance) ZAddNX(ctx context.Context, key string, members ...rdsDrv.Z) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZAddNX(ctx, key, members...)
}</span>
func (i *instance) ZAddXX(ctx context.Context, key string, members ...rdsDrv.Z) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZAddXX(ctx, key, members...)
}</span>
func (i *instance) ZAddArgs(ctx context.Context, key string, args rdsDrv.ZAddArgs) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZAddArgs(ctx, key, args)
}</span>
func (i *instance) ZAddArgsIncr(ctx context.Context, key string, args rdsDrv.ZAddArgs) *rdsDrv.FloatCmd <span class="cov0" title="0">{
        return i.GetProxy().ZAddArgsIncr(ctx, key, args)
}</span>
func (i *instance) ZCard(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZCard(ctx, key)
}</span>
func (i *instance) ZCount(ctx context.Context, key, min, max string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZCount(ctx, key, min, max)
}</span>
func (i *instance) ZLexCount(ctx context.Context, key, min, max string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZLexCount(ctx, key, min, max)
}</span>
func (i *instance) ZIncrBy(ctx context.Context, key string, increment float64, member string) *rdsDrv.FloatCmd <span class="cov0" title="0">{
        return i.GetProxy().ZIncrBy(ctx, key, increment, member)
}</span>
func (i *instance) ZInter(ctx context.Context, store *rdsDrv.ZStore) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZInter(ctx, store)
}</span>
func (i *instance) ZInterWithScores(ctx context.Context, store *rdsDrv.ZStore) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZInterWithScores(ctx, store)
}</span>
func (i *instance) ZInterCard(ctx context.Context, limit int64, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZInterCard(ctx, limit, keys...)
}</span>
func (i *instance) ZInterStore(ctx context.Context, destination string, store *rdsDrv.ZStore) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZInterStore(ctx, destination, store)
}</span>
func (i *instance) ZMPop(ctx context.Context, order string, count int64, keys ...string) *rdsDrv.ZSliceWithKeyCmd <span class="cov0" title="0">{
        return i.GetProxy().ZMPop(ctx, order, count, keys...)
}</span>
func (i *instance) ZMScore(ctx context.Context, key string, members ...string) *rdsDrv.FloatSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZMScore(ctx, key, members...)
}</span>
func (i *instance) ZPopMax(ctx context.Context, key string, count ...int64) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZPopMax(ctx, key, count...)
}</span>
func (i *instance) ZPopMin(ctx context.Context, key string, count ...int64) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZPopMin(ctx, key, count...)
}</span>
func (i *instance) ZRange(ctx context.Context, key string, start, stop int64) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRange(ctx, key, start, stop)
}</span>
func (i *instance) ZRangeWithScores(ctx context.Context, key string, start, stop int64) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRangeWithScores(ctx, key, start, stop)
}</span>
func (i *instance) ZRangeByScore(ctx context.Context, key string, opt *rdsDrv.ZRangeBy) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRangeByScore(ctx, key, opt)
}</span>
func (i *instance) ZRangeByLex(ctx context.Context, key string, opt *rdsDrv.ZRangeBy) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRangeByLex(ctx, key, opt)
}</span>
func (i *instance) ZRangeByScoreWithScores(ctx context.Context, key string, opt *rdsDrv.ZRangeBy) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRangeByScoreWithScores(ctx, key, opt)
}</span>
func (i *instance) ZRangeArgs(ctx context.Context, z rdsDrv.ZRangeArgs) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRangeArgs(ctx, z)
}</span>
func (i *instance) ZRangeArgsWithScores(ctx context.Context, z rdsDrv.ZRangeArgs) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRangeArgsWithScores(ctx, z)
}</span>
func (i *instance) ZRangeStore(ctx context.Context, dst string, z rdsDrv.ZRangeArgs) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRangeStore(ctx, dst, z)
}</span>
func (i *instance) ZRank(ctx context.Context, key, member string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRank(ctx, key, member)
}</span>
func (i *instance) ZRankWithScore(ctx context.Context, key, member string) *rdsDrv.RankWithScoreCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRankWithScore(ctx, key, member)
}</span>

func (i *instance) ZRem(ctx context.Context, key string, members ...any) *rdsDrv.IntCmd <span class="cov4" title="16">{
        return i.GetProxy().ZRem(ctx, key, members...)
}</span>
func (i *instance) ZRemRangeByRank(ctx context.Context, key string, start, stop int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRemRangeByRank(ctx, key, start, stop)
}</span>
func (i *instance) ZRemRangeByScore(ctx context.Context, key, min, max string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRemRangeByScore(ctx, key, min, max)
}</span>
func (i *instance) ZRemRangeByLex(ctx context.Context, key, min, max string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRemRangeByLex(ctx, key, min, max)
}</span>
func (i *instance) ZRevRange(ctx context.Context, key string, start, stop int64) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRevRange(ctx, key, start, stop)
}</span>
func (i *instance) ZRevRangeWithScores(ctx context.Context, key string, start, stop int64) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRevRangeWithScores(ctx, key, start, stop)
}</span>
func (i *instance) ZRevRangeByScore(ctx context.Context, key string, opt *rdsDrv.ZRangeBy) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRevRangeByScore(ctx, key, opt)
}</span>
func (i *instance) ZRevRangeByLex(ctx context.Context, key string, opt *rdsDrv.ZRangeBy) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRevRangeByLex(ctx, key, opt)
}</span>
func (i *instance) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *rdsDrv.ZRangeBy) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRevRangeByScoreWithScores(ctx, key, opt)
}</span>
func (i *instance) ZRevRank(ctx context.Context, key, member string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRevRank(ctx, key, member)
}</span>
func (i *instance) ZRevRankWithScore(ctx context.Context, key, member string) *rdsDrv.RankWithScoreCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRevRankWithScore(ctx, key, member)
}</span>
func (i *instance) ZScore(ctx context.Context, key, member string) *rdsDrv.FloatCmd <span class="cov0" title="0">{
        return i.GetProxy().ZScore(ctx, key, member)
}</span>
func (i *instance) ZUnionStore(ctx context.Context, dest string, store *rdsDrv.ZStore) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZUnionStore(ctx, dest, store)
}</span>
func (i *instance) ZRandMember(ctx context.Context, key string, count int) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRandMember(ctx, key, count)
}</span>
func (i *instance) ZRandMemberWithScores(ctx context.Context, key string, count int) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZRandMemberWithScores(ctx, key, count)
}</span>
func (i *instance) ZUnion(ctx context.Context, store rdsDrv.ZStore) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZUnion(ctx, store)
}</span>
func (i *instance) ZUnionWithScores(ctx context.Context, store rdsDrv.ZStore) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZUnionWithScores(ctx, store)
}</span>
func (i *instance) ZDiff(ctx context.Context, keys ...string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZDiff(ctx, keys...)
}</span>
func (i *instance) ZDiffWithScores(ctx context.Context, keys ...string) *rdsDrv.ZSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ZDiffWithScores(ctx, keys...)
}</span>
func (i *instance) ZDiffStore(ctx context.Context, destination string, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ZDiffStore(ctx, destination, keys...)
}</span>
func (i *instance) PFAdd(ctx context.Context, key string, els ...any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().PFAdd(ctx, key, els...)
}</span>
func (i *instance) PFCount(ctx context.Context, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().PFCount(ctx, keys...)
}</span>
func (i *instance) PFMerge(ctx context.Context, dest string, keys ...string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().PFMerge(ctx, dest, keys...)
}</span>
func (i *instance) BgRewriteAOF(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().BgRewriteAOF(ctx)
}</span>
func (i *instance) BgSave(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().BgSave(ctx)
}</span>
func (i *instance) ClientKill(ctx context.Context, ipPort string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientKill(ctx, ipPort)
}</span>
func (i *instance) ClientKillByFilter(ctx context.Context, keys ...string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientKillByFilter(ctx, keys...)
}</span>
func (i *instance) ClientList(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientList(ctx)
}</span>
func (i *instance) ClientPause(ctx context.Context, dur time.Duration) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientPause(ctx, dur)
}</span>
func (i *instance) ClientUnpause(ctx context.Context) *rdsDrv.BoolCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientUnpause(ctx)
}</span>
func (i *instance) ClientID(ctx context.Context) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientID(ctx)
}</span>
func (i *instance) ClientUnblock(ctx context.Context, id int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientUnblock(ctx, id)
}</span>
func (i *instance) ClientUnblockWithError(ctx context.Context, id int64) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientUnblockWithError(ctx, id)
}</span>
func (i *instance) ClientInfo(ctx context.Context) *rdsDrv.ClientInfoCmd <span class="cov0" title="0">{
        return i.GetProxy().ClientInfo(ctx)
}</span>
func (i *instance) ConfigGet(ctx context.Context, parameter string) *rdsDrv.MapStringStringCmd <span class="cov0" title="0">{
        return i.GetProxy().ConfigGet(ctx, parameter)
}</span>
func (i *instance) ConfigResetStat(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ConfigResetStat(ctx)
}</span>
func (i *instance) ConfigSet(ctx context.Context, parameter, value string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ConfigSet(ctx, parameter, value)
}</span>
func (i *instance) ConfigRewrite(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ConfigRewrite(ctx)
}</span>
func (i *instance) DBSize(ctx context.Context) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().DBSize(ctx)
}</span>
func (i *instance) FlushAll(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().FlushAll(ctx)
}</span>
func (i *instance) FlushAllAsync(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().FlushAllAsync(ctx)
}</span>
func (i *instance) FlushDB(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().FlushDB(ctx)
}</span>
func (i *instance) FlushDBAsync(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().FlushDBAsync(ctx)
}</span>
func (i *instance) Info(ctx context.Context, section ...string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().Info(ctx, section...)
}</span>
func (i *instance) LastSave(ctx context.Context) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().LastSave(ctx)
}</span>
func (i *instance) Save(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Save(ctx)
}</span>
func (i *instance) Shutdown(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().Shutdown(ctx)
}</span>
func (i *instance) ShutdownSave(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ShutdownSave(ctx)
}</span>
func (i *instance) ShutdownNoSave(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ShutdownNoSave(ctx)
}</span>
func (i *instance) SlaveOf(ctx context.Context, host, port string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().SlaveOf(ctx, host, port)
}</span>
func (i *instance) SlowLogGet(ctx context.Context, num int64) *rdsDrv.SlowLogCmd <span class="cov0" title="0">{
        return i.GetProxy().SlowLogGet(ctx, num)
}</span>
func (i *instance) Time(ctx context.Context) *rdsDrv.TimeCmd <span class="cov0" title="0">{ return i.GetProxy().Time(ctx) }</span>
func (i *instance) DebugObject(ctx context.Context, key string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().DebugObject(ctx, key)
}</span>
func (i *instance) ReadOnly(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{ return i.GetProxy().ReadOnly(ctx) }</span>
func (i *instance) ReadWrite(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ReadWrite(ctx)
}</span>
func (i *instance) MemoryUsage(ctx context.Context, key string, samples ...int) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().MemoryUsage(ctx, key, samples...)
}</span>
func (i *instance) Eval(ctx context.Context, script string, keys []string, args ...any) *rdsDrv.Cmd <span class="cov10" title="1947">{
        return i.GetProxy().Eval(ctx, script, keys, args...)
}</span>
func (i *instance) EvalSha(ctx context.Context, sha1 string, keys []string, args ...any) *rdsDrv.Cmd <span class="cov7" title="253">{
        return i.GetProxy().EvalSha(ctx, sha1, keys, args...)
}</span>
func (i *instance) EvalRO(ctx context.Context, script string, keys []string, args ...any) *rdsDrv.Cmd <span class="cov0" title="0">{
        return i.GetProxy().EvalRO(ctx, script, keys, args...)
}</span>
func (i *instance) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...any) *rdsDrv.Cmd <span class="cov0" title="0">{
        return i.GetProxy().EvalShaRO(ctx, sha1, keys, args...)
}</span>
func (i *instance) ScriptExists(ctx context.Context, hashes ...string) *rdsDrv.BoolSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ScriptExists(ctx, hashes...)
}</span>
func (i *instance) ScriptFlush(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ScriptFlush(ctx)
}</span>
func (i *instance) ScriptKill(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ScriptKill(ctx)
}</span>
func (i *instance) ScriptLoad(ctx context.Context, script string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ScriptLoad(ctx, script)
}</span>
func (i *instance) FunctionLoad(ctx context.Context, code string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionLoad(ctx, code)
}</span>
func (i *instance) FunctionLoadReplace(ctx context.Context, code string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionLoadReplace(ctx, code)
}</span>
func (i *instance) FunctionDelete(ctx context.Context, libName string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionDelete(ctx, libName)
}</span>
func (i *instance) FunctionFlush(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionFlush(ctx)
}</span>
func (i *instance) FunctionKill(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionKill(ctx)
}</span>
func (i *instance) FunctionFlushAsync(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionFlushAsync(ctx)
}</span>
func (i *instance) FunctionList(ctx context.Context, q rdsDrv.FunctionListQuery) *rdsDrv.FunctionListCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionList(ctx, q)
}</span>
func (i *instance) FunctionDump(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionDump(ctx)
}</span>
func (i *instance) FunctionRestore(ctx context.Context, libDump string) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionRestore(ctx, libDump)
}</span>
func (i *instance) FunctionStats(ctx context.Context) *rdsDrv.FunctionStatsCmd <span class="cov0" title="0">{
        return i.GetProxy().FunctionStats(ctx)
}</span>
func (i *instance) FCall(ctx context.Context, function string, keys []string, args ...any) *rdsDrv.Cmd <span class="cov0" title="0">{
        return i.GetProxy().FCall(ctx, function, keys, args...)
}</span>
func (i *instance) FCallRo(ctx context.Context, function string, keys []string, args ...any) *rdsDrv.Cmd <span class="cov0" title="0">{
        return i.GetProxy().FCallRo(ctx, function, keys, args...)
}</span>
func (i *instance) FCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *rdsDrv.Cmd <span class="cov0" title="0">{
        return i.GetProxy().FCallRO(ctx, function, keys, args...)
}</span>
func (i *instance) Publish(ctx context.Context, channel string, message any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().Publish(ctx, channel, message)
}</span>
func (i *instance) SPublish(ctx context.Context, channel string, message any) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().SPublish(ctx, channel, message)
}</span>
func (i *instance) PubSubChannels(ctx context.Context, pattern string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().PubSubChannels(ctx, pattern)
}</span>
func (i *instance) PubSubNumSub(ctx context.Context, channels ...string) *rdsDrv.MapStringIntCmd <span class="cov0" title="0">{
        return i.GetProxy().PubSubNumSub(ctx, channels...)
}</span>
func (i *instance) PubSubNumPat(ctx context.Context) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().PubSubNumPat(ctx)
}</span>
func (i *instance) PubSubShardChannels(ctx context.Context, pattern string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().PubSubShardChannels(ctx, pattern)
}</span>
func (i *instance) PubSubShardNumSub(ctx context.Context, channels ...string) *rdsDrv.MapStringIntCmd <span class="cov0" title="0">{
        return i.GetProxy().PubSubShardNumSub(ctx, channels...)
}</span>
func (i *instance) ClusterMyShardID(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterMyShardID(ctx)
}</span>
func (i *instance) ClusterSlots(ctx context.Context) *rdsDrv.ClusterSlotsCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterSlots(ctx)
}</span>
func (i *instance) ClusterShards(ctx context.Context) *rdsDrv.ClusterShardsCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterShards(ctx)
}</span>
func (i *instance) ClusterLinks(ctx context.Context) *rdsDrv.ClusterLinksCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterLinks(ctx)
}</span>
func (i *instance) ClusterNodes(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterNodes(ctx)
}</span>
func (i *instance) ClusterMeet(ctx context.Context, host, port string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterMeet(ctx, host, port)
}</span>
func (i *instance) ClusterForget(ctx context.Context, nodeID string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterForget(ctx, nodeID)
}</span>
func (i *instance) ClusterReplicate(ctx context.Context, nodeID string) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterReplicate(ctx, nodeID)
}</span>
func (i *instance) ClusterResetSoft(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterResetSoft(ctx)
}</span>
func (i *instance) ClusterResetHard(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterResetHard(ctx)
}</span>
func (i *instance) ClusterInfo(ctx context.Context) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterInfo(ctx)
}</span>
func (i *instance) ClusterKeySlot(ctx context.Context, key string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterKeySlot(ctx, key)
}</span>
func (i *instance) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterGetKeysInSlot(ctx, slot, count)
}</span>
func (i *instance) ClusterCountFailureReports(ctx context.Context, nodeID string) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterCountFailureReports(ctx, nodeID)
}</span>
func (i *instance) ClusterCountKeysInSlot(ctx context.Context, slot int) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterCountKeysInSlot(ctx, slot)
}</span>
func (i *instance) ClusterDelSlots(ctx context.Context, slots ...int) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterDelSlots(ctx, slots...)
}</span>
func (i *instance) ClusterDelSlotsRange(ctx context.Context, min, max int) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterDelSlotsRange(ctx, min, max)
}</span>
func (i *instance) ClusterSaveConfig(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterSaveConfig(ctx)
}</span>
func (i *instance) ClusterSlaves(ctx context.Context, nodeID string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterSlaves(ctx, nodeID)
}</span>
func (i *instance) ClusterFailover(ctx context.Context) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterFailover(ctx)
}</span>
func (i *instance) ClusterAddSlots(ctx context.Context, slots ...int) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterAddSlots(ctx, slots...)
}</span>
func (i *instance) ClusterAddSlotsRange(ctx context.Context, min, max int) *rdsDrv.StatusCmd <span class="cov0" title="0">{
        return i.GetProxy().ClusterAddSlotsRange(ctx, min, max)
}</span>
func (i *instance) GeoAdd(ctx context.Context, key string, geoLocation ...*rdsDrv.GeoLocation) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoAdd(ctx, key, geoLocation...)
}</span>
func (i *instance) GeoPos(ctx context.Context, key string, members ...string) *rdsDrv.GeoPosCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoPos(ctx, key, members...)
}</span>
func (i *instance) GeoRadius(ctx context.Context, key string, longitude, latitude float64,
        query *rdsDrv.GeoRadiusQuery) *rdsDrv.GeoLocationCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoRadius(ctx, key, longitude, latitude, query)
}</span>
func (i *instance) GeoRadiusStore(ctx context.Context, key string, longitude, latitude float64,
        query *rdsDrv.GeoRadiusQuery) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoRadiusStore(ctx, key, longitude, latitude, query)
}</span>
func (i *instance) GeoRadiusByMember(ctx context.Context, key, member string,
        query *rdsDrv.GeoRadiusQuery) *rdsDrv.GeoLocationCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoRadiusByMember(ctx, key, member, query)
}</span>
func (i *instance) GeoRadiusByMemberStore(ctx context.Context, key, member string,
        query *rdsDrv.GeoRadiusQuery) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoRadiusByMemberStore(ctx, key, member, query)
}</span>
func (i *instance) GeoSearch(ctx context.Context, key string, q *rdsDrv.GeoSearchQuery) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoSearch(ctx, key, q)
}</span>
func (i *instance) GeoSearchLocation(ctx context.Context, key string,
        q *rdsDrv.GeoSearchLocationQuery) *rdsDrv.GeoSearchLocationCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoSearchLocation(ctx, key, q)
}</span>
func (i *instance) GeoSearchStore(ctx context.Context, key, store string,
        q *rdsDrv.GeoSearchStoreQuery) *rdsDrv.IntCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoSearchStore(ctx, key, store, q)
}</span>
func (i *instance) GeoDist(ctx context.Context, key string, member1, member2, unit string) *rdsDrv.FloatCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoDist(ctx, key, member1, member2, unit)
}</span>
func (i *instance) GeoHash(ctx context.Context, key string, members ...string) *rdsDrv.StringSliceCmd <span class="cov0" title="0">{
        return i.GetProxy().GeoHash(ctx, key, members...)
}</span>
func (i *instance) ACLDryRun(ctx context.Context, username string, command ...any) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ACLDryRun(ctx, username, command...)
}</span>
func (i *instance) ModuleLoadex(ctx context.Context, conf *rdsDrv.ModuleLoadexConfig) *rdsDrv.StringCmd <span class="cov0" title="0">{
        return i.GetProxy().ModuleLoadex(ctx, conf)
}</span>
func (i *instance) AddHook(hk rdsDrv.Hook) <span class="cov0" title="0">{
        i.GetProxy().AddHook(hk)
}</span>
func (i *instance) Watch(ctx context.Context, fn func(*rdsDrv.Tx) error, keys ...string) error <span class="cov0" title="0">{
        return i.GetProxy().Watch(ctx, fn, keys...)
}</span>
func (i *instance) Do(ctx context.Context, args ...any) *rdsDrv.Cmd <span class="cov0" title="0">{
        return i.GetProxy().Do(ctx, args...)
}</span>
func (i *instance) Process(ctx context.Context, cmd rdsDrv.Cmder) error <span class="cov0" title="0">{
        return i.GetProxy().Process(ctx, cmd)
}</span>
func (i *instance) Subscribe(ctx context.Context, channels ...string) *rdsDrv.PubSub <span class="cov3" title="7">{
        return i.GetProxy().Subscribe(ctx, channels...)
}</span>
func (i *instance) PSubscribe(ctx context.Context, channels ...string) *rdsDrv.PubSub <span class="cov0" title="0">{
        return i.GetProxy().PSubscribe(ctx, channels...)
}</span>
func (i *instance) SSubscribe(ctx context.Context, channels ...string) *rdsDrv.PubSub <span class="cov0" title="0">{
        return i.GetProxy().SSubscribe(ctx, channels...)
}</span>
func (i *instance) Close() error <span class="cov0" title="0">{
        return i.GetProxy().Close()
}</span>
func (i *instance) PoolStats() *rdsDrv.PoolStats <span class="cov0" title="0">{
        return i.GetProxy().PoolStats()
}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">package routine

import (
        "context"
        "log"
        "reflect"
        "sync"
        "sync/atomic"

        "github.com/pkg/errors"

        "github.com/wfusion/gofusion/common/constant"
        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
)

type candyOption struct {
        args    []any
        ch      chan&lt;- any
        wg      *sync.WaitGroup
        appName string
}

func Args(args ...any) utils.OptionFunc[candyOption] <span class="cov8" title="559">{
        return func(o *candyOption) </span><span class="cov9" title="1115">{
                o.args = append(o.args, args...)
        }</span>
}

func WaitGroup(wg *sync.WaitGroup) utils.OptionFunc[candyOption] <span class="cov8" title="392">{
        return func(o *candyOption) </span><span class="cov8" title="780">{
                o.wg = wg
        }</span>
}

func Channel(ch chan&lt;- any) utils.OptionFunc[candyOption] <span class="cov2" title="3">{
        return func(o *candyOption) </span><span class="cov3" title="6">{
                o.ch = ch
        }</span>
}

func AppName(name string) utils.OptionFunc[candyOption] <span class="cov9" title="1050">{
        return func(o *candyOption) </span><span class="cov10" title="2096">{
                o.appName = name
        }</span>
}

func Go(task any, opts ...utils.OptionExtender) <span class="cov8" title="571">{
        funcName := utils.GetFuncName(task)
        opt := utils.ApplyOptions[candyOption](opts...)
        allocate(opt.appName, 1, &amp;NewPoolOption{ApplyTimeout: -1})
        exec := func() </span><span class="cov8" title="567">{
                defer func() </span><span class="cov8" title="569">{
                        release(opt.appName, nil, nil)
                        delRoutine(opt.appName, funcName)
                        if opt.wg != nil </span><span class="cov7" title="309">{
                                opt.wg.Done()
                        }</span>
                        <span class="cov8" title="571">wg.Done()</span>
                }()

                <span class="cov8" title="566">addRoutine(opt.appName, funcName)
                wrapPromise(task, false, opts...).
                        OnFailure(func(v any) </span><span class="cov1" title="1">{
                                if opt.ch == nil </span><span class="cov0" title="0">{
                                        log.Printf("[Gofusion] %s catches an error in routine.Go function: \n"+
                                                "error: %s\nfunc: %s\nfunc signature: %T",
                                                config.ComponentGoroutinePool, v, utils.GetFuncName(task), task)
                                }</span>
                        }).
                        OnComplete(func(v any) <span class="cov8" title="568">{
                                if opt.ch != nil </span><span class="cov2" title="3">{
                                        opt.ch &lt;- v
                                }</span>
                        })
        }

        <span class="cov8" title="571">wg.Add(1)
        if forceSync(opt.appName) </span><span class="cov0" title="0">{
                exec()
        }</span> else<span class="cov8" title="571"> {
                go exec()
        }</span>
}

func Goc(ctx context.Context, task any, opts ...utils.OptionExtender) <span class="cov7" title="300">{
        funcName := utils.GetFuncName(task)
        opt := utils.ApplyOptions[candyOption](opts...)
        allocate(opt.appName, 1, &amp;NewPoolOption{ApplyTimeout: -1})
        exec := func() </span><span class="cov7" title="301">{
                defer func() </span><span class="cov7" title="301">{
                        release(opt.appName, nil, nil)
                        delRoutine(opt.appName, funcName)
                        if opt.wg != nil </span><span class="cov1" title="1">{
                                opt.wg.Done()
                        }</span>
                        <span class="cov7" title="301">wg.Done()</span>
                }()

                <span class="cov7" title="301">addRoutine(opt.appName, funcName)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                case &lt;-wrapPromise(task, false, opts...).
                        OnFailure(func(v any) <span class="cov1" title="1">{
                                if opt.ch == nil </span><span class="cov1" title="1">{
                                        log.Printf("[Gofusion] %s catches an error in routine.Goc function: \n"+
                                                "error: %s\nfunc: %s\nfunc signature: %T",
                                                config.ComponentGoroutinePool, v, utils.GetFuncName(task), task)
                                }</span>
                        }).
                        OnComplete(func(v any) <span class="cov7" title="301">{
                                if opt.ch != nil </span><span class="cov0" title="0">{
                                        opt.ch &lt;- v
                                }</span>
                        }).
                        GetChan():<span class="cov7" title="301"></span>
                }
        }

        <span class="cov7" title="299">wg.Add(1)
        if forceSync(opt.appName) </span><span class="cov0" title="0">{
                exec()
        }</span> else<span class="cov7" title="300"> {
                go exec()
        }</span>
}

func Loop(task any, opts ...utils.OptionExtender) <span class="cov6" title="102">{
        opt := utils.ApplyOptions[candyOption](opts...)
        allocate(opt.appName, 1, &amp;NewPoolOption{ApplyTimeout: -1}, ignoreRecycled())
        exec := func() </span><span class="cov6" title="102">{
                defer func() </span><span class="cov6" title="102">{
                        release(opt.appName, nil, ignoreRecycled())
                        if opt.wg != nil </span><span class="cov1" title="2">{
                                opt.wg.Done()
                        }</span>
                }()
                <span class="cov6" title="102">wrapPromise(task, false, opts...).
                        OnFailure(func(v any) </span><span class="cov0" title="0">{
                                if opt.ch == nil </span><span class="cov0" title="0">{
                                        log.Printf("[Gofusion] %s catches an error in routine.Loop function: \n"+
                                                "error: %s\nfunc: %s\nfunc signature: %T",
                                                config.ComponentGoroutinePool, v, utils.GetFuncName(task), task)
                                }</span>
                        }).
                        OnComplete(func(v any) <span class="cov6" title="102">{
                                if opt.ch != nil </span><span class="cov0" title="0">{
                                        opt.ch &lt;- v
                                }</span>
                        })
        }

        <span class="cov6" title="102">go exec()</span>
}

func Loopc(ctx context.Context, task any, opts ...utils.OptionExtender) <span class="cov0" title="0">{
        opt := utils.ApplyOptions[candyOption](opts...)
        allocate(opt.appName, 1, &amp;NewPoolOption{ApplyTimeout: -1}, ignoreRecycled())
        exec := func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        release(opt.appName, nil, ignoreRecycled())
                        if opt.wg != nil </span><span class="cov0" title="0">{
                                opt.wg.Done()
                        }</span>
                }()
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                case &lt;-wrapPromise(task, false, opts...).
                        OnFailure(func(v any) <span class="cov0" title="0">{
                                if opt.ch == nil </span><span class="cov0" title="0">{
                                        log.Printf("[Gofusion] %s catches an error in routine.Loopc function: \n"+
                                                "error: %s\nfunc: %s\nfunc signature: %T",
                                                config.ComponentGoroutinePool, v, utils.GetFuncName(task), task)
                                }</span>
                        }).
                        OnComplete(func(v any) <span class="cov0" title="0">{
                                if opt.ch != nil </span><span class="cov0" title="0">{
                                        opt.ch &lt;- v
                                }</span>
                        }).
                        GetChan():<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">go exec()</span>
}

func Promise(fn any, async bool, opts ...utils.OptionExtender) *Future <span class="cov6" title="80">{
        opt := utils.ApplyOptions[candyOption](opts...)
        funcName := utils.GetFuncName(fn)
        allocate(opt.appName, 1, &amp;NewPoolOption{ApplyTimeout: -1}, ignoreRecycled())
        defer func() </span><span class="cov6" title="80">{
                release(opt.appName, nil, ignoreRecycled())
                delRoutine(opt.appName, funcName)
                if opt.wg != nil </span><span class="cov6" title="80">{
                        opt.wg.Done()
                }</span>
        }()

        <span class="cov6" title="80">addRoutine(opt.appName, funcName)
        return wrapPromise(fn, async &amp;&amp; !forceSync(opt.appName), opts...).
                OnFailure(func(v any) </span><span class="cov0" title="0">{
                        if opt.ch == nil </span><span class="cov0" title="0">{
                                log.Printf("[Gofusion] %s catches an error in routine.Loop function: \n"+
                                        "error: %s\nfunc: %s\nfunc signature: %T",
                                        config.ComponentGoroutinePool, v, utils.GetFuncName(fn), fn)
                        }</span>
                }).
                OnComplete(func(v any) <span class="cov6" title="80">{
                        if opt.ch != nil </span><span class="cov0" title="0">{
                                opt.ch &lt;- v
                        }</span>
                })
}

// wrapPromise support function:
// func() error
// func() (any, error)
// func(Canceller)
// func(Canceller) error
// func(Canceller) (any, error)
// func(t1 T1, t2 T2, t3 T3, tx ...Tx)
// func(t1 T1, t2 T2, t3 T3, tx ...Tx) error
// func(t1 T1, t2 T2, t3 T3, tx ...Tx) (any, error)
func wrapPromise(fn any, async bool, opts ...utils.OptionExtender) *Future <span class="cov9" title="1053">{
        // check supported function
        switch fn.(type) </span>{
        case func(),
                func() error,
                func() (any, error),
                func(Canceller),
                func(Canceller) error,
                func(Canceller) (any, error):<span class="cov8" title="495">

                return start(fn, async, opts...)</span>

        default:<span class="cov8" title="559">
                typ := reflect.TypeOf(fn)
                if typ.Kind() != reflect.Func </span><span class="cov0" title="0">{
                        return WrapFuture(errors.Errorf("unsupported function type %T", fn), opts...)
                }</span>
                <span class="cov8" title="559">if typ.NumOut() &gt; 0 &amp;&amp; (typ.NumOut() &gt; 2 ||
                        typ.Out(typ.NumOut()-1) != constant.ErrorType ||
                        (typ.NumOut() == 2 &amp;&amp; typ.Out(0) != constant.AnyType)) </span><span class="cov0" title="0">{
                        return WrapFuture(errors.Errorf("unsupported function signature %T", fn), opts...)
                }</span>

                <span class="cov8" title="559">return start(fn, async, opts...)</span>
        }
}

// WrapFuture return a Future that presents the wrapped value
func WrapFuture(value any, opts ...utils.OptionExtender) *Future <span class="cov0" title="0">{
        opt := utils.ApplyOptions[candyOption](opts...)
        p := NewPromise()
        p.AppName = opt.appName
        if e, ok := value.(error); !ok </span><span class="cov0" title="0">{
                _ = p.Resolve(value)
        }</span> else<span class="cov0" title="0"> {
                _ = p.Reject(e)
        }</span>

        <span class="cov0" title="0">return p.Future</span>
}

// WhenAny returns a Future.
// If any Future is resolved, this Future will be resolved and return result of resolved Future.
// Otherwise, it will be rejected with results slice returned by all Futures
// Legit types of act are same with Start function
func WhenAny(acts ...any) *Future <span class="cov0" title="0">{
        return WhenAnyMatched(nil, acts...)
}</span>

type anyPromiseResult struct {
        result any
        i      int
}

// WhenAnyMatched returns a Future.
// If any Future is resolved and match the predicate, this Future will be resolved and return result of resolved Future.
// If all Futures are cancelled, this Future will be cancelled.
// Otherwise, it will be rejected with a NoMatchedError included results slice returned by all Futures
// Legit types of act are same with Start function
func WhenAnyMatched(predicate func(any) bool, acts ...any) *Future <span class="cov0" title="0">{
        if predicate == nil </span><span class="cov0" title="0">{
                predicate = func(v any) bool </span><span class="cov0" title="0">{ return true }</span>
        }

        <span class="cov0" title="0">opts := make([]utils.OptionExtender, 0, len(acts))
        for i, act := range acts </span><span class="cov0" title="0">{
                if opt, ok := act.(utils.OptionExtender); ok </span><span class="cov0" title="0">{
                        opts = append(opts, opt)
                        acts = append(acts[:i], acts[i+1:]...)
                }</span>
        }
        <span class="cov0" title="0">opt := utils.ApplyOptions[candyOption](opts...)
        fs := make([]*Future, len(acts))
        for i, act := range acts </span><span class="cov0" title="0">{
                fs[i] = Promise(act, true, opts...)
        }</span>

        <span class="cov0" title="0">nf, rs := NewPromise(), make([]any, len(fs))
        if len(acts) == 0 </span><span class="cov0" title="0">{
                _ = nf.Resolve(nil)
        }</span>

        <span class="cov0" title="0">chFails, chDones := make(chan anyPromiseResult), make(chan anyPromiseResult)

        Go(func() </span><span class="cov0" title="0">{
                for i, f := range fs </span><span class="cov0" title="0">{
                        k := i
                        f.OnSuccess(func(v any) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ _ = recover() }</span>()
                                <span class="cov0" title="0">chDones &lt;- anyPromiseResult{result: v, i: k}</span>
                        }).OnFailure(func(v any) <span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ _ = recover() }</span>()
                                <span class="cov0" title="0">chFails &lt;- anyPromiseResult{result: v, i: k}</span>
                        }).OnCancel(func() <span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ _ = recover() }</span>()
                                <span class="cov0" title="0">chFails &lt;- anyPromiseResult{result: ErrCancelled, i: k}</span>
                        })
                }
        }, AppName(opt.appName))

        <span class="cov0" title="0">if len(fs) == 1 </span><span class="cov0" title="0">{
                select </span>{
                case r := &lt;-chFails:<span class="cov0" title="0">
                        if _, ok := r.result.(CancelledError); ok </span><span class="cov0" title="0">{
                                _ = nf.Cancel()
                        }</span> else<span class="cov0" title="0"> {
                                _ = nf.Reject(newNoMatchedError1(r.result))
                        }</span>
                case r := &lt;-chDones:<span class="cov0" title="0">
                        if predicate(r.result) </span><span class="cov0" title="0">{
                                _ = nf.Resolve(r.result)
                        }</span> else<span class="cov0" title="0"> {
                                _ = nf.Reject(newNoMatchedError1(r.result))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                Go(func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if e := recover(); e != nil </span><span class="cov0" title="0">{
                                        _ = nf.Reject(newErrorWithStacks(e))
                                }</span>
                        }()

                        <span class="cov0" title="0">j := 0
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case r := &lt;-chFails:<span class="cov0" title="0">
                                        rs[r.i] = getError(r.result)</span>
                                case r := &lt;-chDones:<span class="cov0" title="0">
                                        if predicate(r.result) </span><span class="cov0" title="0">{
                                                // try to cancel other futures
                                                for _, f := range fs </span><span class="cov0" title="0">{
                                                        _ = f.Cancel()
                                                }</span>

                                                // close the channel for avoid the sender be blocked
                                                <span class="cov0" title="0">closeChan := func(c chan anyPromiseResult) </span><span class="cov0" title="0">{
                                                        defer func() </span><span class="cov0" title="0">{ _ = recover() }</span>()
                                                        <span class="cov0" title="0">close(c)</span>
                                                }
                                                <span class="cov0" title="0">closeChan(chDones)
                                                closeChan(chFails)

                                                // resolve the future and return result
                                                _ = nf.Resolve(r.result)
                                                return</span>
                                        } else<span class="cov0" title="0"> {
                                                rs[r.i] = r.result
                                        }</span>
                                }

                                <span class="cov0" title="0">if j++; j == len(fs) </span><span class="cov0" title="0">{
                                        m := 0
                                        for _, r := range rs </span><span class="cov0" title="0">{
                                                switch val := r.(type) </span>{
                                                case CancelledError:<span class="cov0" title="0"></span>
                                                default:<span class="cov0" title="0">
                                                        m++
                                                        _ = val</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if m &gt; 0 </span><span class="cov0" title="0">{
                                                _ = nf.Reject(newNoMatchedError(rs))
                                        }</span> else<span class="cov0" title="0"> {
                                                _ = nf.Cancel()
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }, AppName(opt.appName))
        }
        <span class="cov0" title="0">return nf.Future</span>
}

// WhenAll receives function slice and returns a Future.
// If all Futures are resolved, this Future will be resolved and return results slice.
// Otherwise, it will be rejected with results slice returned by all Futures
// Legit types of act are same with Start function
func WhenAll(acts ...any) (fu *Future) <span class="cov0" title="0">{
        p := NewPromise()
        fu = p.Future

        opts := make([]utils.OptionExtender, 0, len(acts))
        for i, act := range acts </span><span class="cov0" title="0">{
                if opt, ok := act.(utils.OptionExtender); ok </span><span class="cov0" title="0">{
                        opts = append(opts, opt)
                        acts = append(acts[:i], acts[i+1:]...)
                }</span>
        }
        <span class="cov0" title="0">opt := utils.ApplyOptions[candyOption](opts...)
        p.AppName = opt.appName
        if len(acts) == 0 </span><span class="cov0" title="0">{
                _ = p.Resolve([]any{})
                return
        }</span>

        <span class="cov0" title="0">fs := make([]*Future, len(acts))
        for i, act := range acts </span><span class="cov0" title="0">{
                fs[i] = Promise(act, true, opts...)
        }</span>
        <span class="cov0" title="0">fu = whenAllFuture(fs, opts...)
        return</span>
}

// WhenAll receives Futures slice and returns a Future.
// If all Futures are resolved, this Future will be resolved and return results slice.
// If any Future is cancelled, this Future will be cancelled.
// Otherwise, it will be rejected with results slice returned by all Futures.
// Legit types of act are same with Start function
func whenAllFuture(fs []*Future, opts ...utils.OptionExtender) *Future <span class="cov0" title="0">{
        opt := utils.ApplyOptions[candyOption](opts...)
        wf := NewPromise()
        wf.AppName = opt.appName
        rs := make([]any, len(fs))

        if len(fs) == 0 </span><span class="cov0" title="0">{
                _ = wf.Resolve([]any{})
        }</span> else<span class="cov0" title="0"> {
                n := int32(len(fs))
                cancelOthers := func(j int) </span><span class="cov0" title="0">{
                        for k, f1 := range fs </span><span class="cov0" title="0">{
                                if k != j </span><span class="cov0" title="0">{
                                        _ = f1.Cancel()
                                }</span>
                        }
                }

                <span class="cov0" title="0">Go(func() </span><span class="cov0" title="0">{
                        isCancelled := int32(0)
                        for i, f := range fs </span><span class="cov0" title="0">{
                                j := i

                                f.OnSuccess(func(v any) </span><span class="cov0" title="0">{
                                        rs[j] = v
                                        if atomic.AddInt32(&amp;n, -1) == 0 </span><span class="cov0" title="0">{
                                                _ = wf.Resolve(rs)
                                        }</span>
                                }).OnFailure(func(v any) <span class="cov0" title="0">{
                                        if atomic.CompareAndSwapInt32(&amp;isCancelled, 0, 1) </span><span class="cov0" title="0">{
                                                // try to cancel all futures
                                                cancelOthers(j)

                                                // errs := make([]error, 0, 1)
                                                // errs = append(errs, v.(error))
                                                e := newAggregateError1("error appears in WhenAll:", v)
                                                _ = wf.Reject(e)
                                        }</span>
                                }).OnCancel(func() <span class="cov0" title="0">{
                                        if atomic.CompareAndSwapInt32(&amp;isCancelled, 0, 1) </span><span class="cov0" title="0">{
                                                // try to cancel all futures
                                                cancelOthers(j)

                                                _ = wf.Cancel()
                                        }</span>
                                })
                        }
                }, AppName(opt.appName))
        }

        <span class="cov0" title="0">return wf.Future</span>
}

// start a goroutines to execute task function
// and return a Future that presents the result.
// If option parameter is true, the act function will be sync called.
// Type of act can be any of below four types:
//
//        func() (r any, err error):
//           if err returned by act != nil or panic error, then Future will be rejected with error,
//           otherwise be resolved with r.
//        func():
//           if act panic error, then Future will be rejected, otherwise be resolved with nil.
//        func(c promise.Canceller) (r any, err error):
//           if err returned by act != nil or panic error,
//           then Future will be rejected with err, otherwise be resolved with r.
//           We can check c.IsCancelled() to decide whether we need to exit act function
//        func(promise.Canceller):
//           if act panic error, then Future will be rejected with error, otherwise be resolved with nil.
//           We can check c.IsCancelled() to decide whether we need to exit act function.
//        error:
//           Future will be rejected with error immediately
//        other value:
//           Future will be resolved with value immediately
func start(act any, async bool, opts ...utils.OptionExtender) *Future <span class="cov9" title="1054">{
        p := NewPromise()
        if f, ok := act.(*Future); ok </span><span class="cov0" title="0">{
                return f
        }</span>

        <span class="cov9" title="1050">opt := utils.ApplyOptions[candyOption](opts...)
        p.AppName = opt.appName
        if action := getAct(p, act); action != nil </span><span class="cov9" title="1050">{
                if !async </span><span class="cov9" title="970">{
                        // sync call
                        r, err := action(opt)
                        if p.IsCancelled() </span><span class="cov0" title="0">{
                                _ = p.Cancel()
                        }</span> else<span class="cov9" title="968"> {
                                if err == nil </span><span class="cov9" title="966">{
                                        _ = p.Resolve(r)
                                }</span> else<span class="cov1" title="2"> {
                                        _ = p.Reject(err)
                                }</span>
                        }
                } else<span class="cov6" title="80"> {
                        // async call
                        Go(func() </span><span class="cov6" title="80">{
                                r, err := action(opt)
                                if p.IsCancelled() </span><span class="cov0" title="0">{
                                        _ = p.Cancel()
                                }</span> else<span class="cov6" title="80"> {
                                        if err == nil </span><span class="cov6" title="80">{
                                                _ = p.Resolve(r)
                                        }</span> else<span class="cov0" title="0"> {
                                                _ = p.Reject(err)
                                        }</span>
                                }
                        }, AppName(opt.appName))
                }
        }

        <span class="cov9" title="1053">return p.Future</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">package routine

import (
        "bytes"
        "errors"
        "fmt"
        "reflect"
        "runtime"
        "strconv"

        "github.com/wfusion/gofusion/common/utils"
)

// NoMatchedError presents no future that returns matched result in WhenAnyTrue function.
type NoMatchedError struct {
        Results []any
}

func (e *NoMatchedError) Error() string <span class="cov0" title="0">{
        return "No matched future"
}</span>

func (e *NoMatchedError) HasError() bool <span class="cov0" title="0">{
        for _, ie := range e.Results </span><span class="cov0" title="0">{
                if _, ok1 := ie.(error); ok1 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func newNoMatchedError(results []any) *NoMatchedError <span class="cov0" title="0">{
        return &amp;NoMatchedError{results}
}</span>

func newNoMatchedError1(e any) *NoMatchedError <span class="cov0" title="0">{
        return &amp;NoMatchedError{[]any{e}}
}</span>

// AggregateError aggregate multi errors into an error
type AggregateError struct {
        s         string
        InnerErrs []error
}

func (e *AggregateError) Error() string <span class="cov0" title="0">{
        if e.InnerErrs == nil </span><span class="cov0" title="0">{
                return e.s
        }</span> else<span class="cov0" title="0"> {
                buf := bytes.NewBufferString(e.s)
                buf.WriteString("\n\n")
                for i, ie := range e.InnerErrs </span><span class="cov0" title="0">{
                        if ie == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">buf.WriteString("error appears in Future ")
                        buf.WriteString(strconv.Itoa(i))
                        buf.WriteString(": ")
                        buf.WriteString(ie.Error())
                        buf.WriteString("\n")</span>
                }
                <span class="cov0" title="0">buf.WriteString("\n")
                return buf.String()</span>
        }
}

func newAggregateError1(s string, e any) *AggregateError <span class="cov0" title="0">{
        return &amp;AggregateError{newErrorWithStacks(s).Error(), []error{getError(e)}}
}</span>

func newErrorWithStacks(i any) (e error) <span class="cov0" title="0">{
        err := getError(i)
        buf := bytes.NewBufferString(err.Error())
        buf.WriteString("\n")

        pcs := make([]uintptr, 50)
        num := runtime.Callers(2, pcs)
        for _, v := range pcs[0:num] </span><span class="cov0" title="0">{
                fun := runtime.FuncForPC(v)
                file, line := fun.FileLine(v)
                name := fun.Name()
                writeStrings(buf, []string{name, " ", file, ":", strconv.Itoa(line), "\n"})
        }</span>
        <span class="cov0" title="0">return errors.New(buf.String())</span>
}

func getAct(p *promise, act any) (f func(opt *candyOption) (r any, err error)) <span class="cov9" title="1047">{
        var (
                act1 func(...any) (any, error)
                act2 func(Canceller, ...any) (any, error)
        )
        canCancel := false

        // convert the act to the function that has return value and error if act function haven't return value and error
        switch v := act.(type) </span>{
        case func():<span class="cov8" title="469">
                act1 = func(...any) (any, error) </span><span class="cov8" title="471">{ v(); return nil, nil }</span>
        case func() error:<span class="cov5" title="24">
                act1 = func(...any) (any, error) </span><span class="cov5" title="24">{ e := v(); return nil, e }</span>
        case func() (any, error):<span class="cov0" title="0">
                act1 = func(a ...any) (any, error) </span><span class="cov0" title="0">{ return v() }</span>
        case func(Canceller):<span class="cov0" title="0">
                canCancel = true
                act2 = func(canceller Canceller, a ...any) (any, error) </span><span class="cov0" title="0">{ v(canceller); return nil, nil }</span>
        case func(Canceller) error:<span class="cov0" title="0">
                canCancel = true
                act2 = func(canceller Canceller, a ...any) (any, error) </span><span class="cov0" title="0">{ e := v(canceller); return nil, e }</span>
        case func(Canceller) (any, error):<span class="cov0" title="0">
                canCancel = true
                act2 = func(canceller Canceller, a ...any) (any, error) </span><span class="cov0" title="0">{ return v(canceller) }</span>
        default:<span class="cov9" title="557">
                typ := reflect.TypeOf(v)
                if typ.Kind() == reflect.Func </span><span class="cov9" title="558">{
                        act1 = utils.WrapFunc2[any, error](v)
                }</span> else<span class="cov0" title="0"> {
                        if e, ok := v.(error); !ok </span><span class="cov0" title="0">{
                                _ = p.Resolve(v)
                        }</span> else<span class="cov0" title="0"> {
                                _ = p.Reject(e)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // If parameters of act function has a Canceller interface, the Future will be cancelled.
        <span class="cov9" title="1047">var canceller Canceller = nil
        if p != nil &amp;&amp; canCancel </span><span class="cov0" title="0">{
                canceller = p.Canceller()
        }</span>

        // return proxy function of act function
        <span class="cov9" title="1047">f = func(opt *candyOption) (r any, err error) </span><span class="cov9" title="1048">{
                defer func() </span><span class="cov10" title="1054">{
                        if e := recover(); e != nil </span><span class="cov0" title="0">{
                                err = newErrorWithStacks(e)
                        }</span>
                }()

                <span class="cov9" title="1048">if canCancel </span><span class="cov0" title="0">{
                        r, err = act2(canceller, opt.args...)
                }</span> else<span class="cov9" title="1048"> {
                        r, err = act1(opt.args...)
                }</span>

                <span class="cov9" title="1053">return</span>
        }
        <span class="cov9" title="1051">return</span>
}

// Error handling struct and functions------------------------------
type stringer interface {
        String() string
}

func getError(i any) (e error) <span class="cov9" title="1053">{
        if i != nil </span><span class="cov0" title="0">{
                switch v := i.(type) </span>{
                case error:<span class="cov0" title="0">
                        e = v</span>
                case string:<span class="cov0" title="0">
                        e = errors.New(v)</span>
                default:<span class="cov0" title="0">
                        if s, ok := i.(stringer); ok </span><span class="cov0" title="0">{
                                e = errors.New(s.String())
                        }</span> else<span class="cov0" title="0"> {
                                e = errors.New(fmt.Sprintf("%v", i))
                        }</span>
                }
        }
        <span class="cov9" title="1053">return</span>
}

func writeStrings(buf *bytes.Buffer, strings []string) <span class="cov0" title="0">{
        for _, s := range strings </span><span class="cov0" title="0">{
                buf.WriteString(s)
        }</span>
}

func startPipe(r *Result, pipeTask func(v any) *Future, pipePromise *promise) <span class="cov0" title="0">{
        if pipeTask != nil </span><span class="cov0" title="0">{
                f := pipeTask(r.Result)
                f.OnSuccess(func(v any) </span><span class="cov0" title="0">{
                        _ = pipePromise.Resolve(v)
                }</span>).OnFailure(func(v any) <span class="cov0" title="0">{
                        _ = pipePromise.Reject(getError(v))
                }</span>)
        }

}

func getFutureReturnVal(r *Result) (any, error) <span class="cov6" title="80">{
        if r.Typ == ResultSuccess </span><span class="cov6" title="80">{
                return r.Result, nil
        }</span> else<span class="cov0" title="0"> if r.Typ == ResultFailure </span><span class="cov0" title="0">{
                return nil, getError(r.Result)
        }</span> else<span class="cov0" title="0"> {
                return nil, getError(r.Result) //&amp;CancelledError{}
        }</span>
}

func execCallback(r *Result,
        dones []func(v any),
        fails []func(v any),
        always []func(v any),
        cancels []func()) <span class="cov6" title="80">{

        if r.Typ == ResultCancelled </span><span class="cov0" title="0">{
                for _, f := range cancels </span><span class="cov0" title="0">{
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if e := recover(); e != nil </span><span class="cov0" title="0">{
                                                err := newErrorWithStacks(e)
                                                fmt.Println("error happens:\n ", err)
                                        }</span>
                                }()
                                <span class="cov0" title="0">f()</span>
                        }()
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov6" title="80">var callbacks []func(v any)
        if r.Typ == ResultSuccess </span><span class="cov6" title="80">{
                callbacks = dones
        }</span> else<span class="cov0" title="0"> {
                callbacks = fails
        }</span>

        <span class="cov6" title="80">forFs := func(s []func(v any)) </span><span class="cov7" title="160">{
                forSlice(s, func(f func(v any)) </span><span class="cov6" title="80">{ f(r.Result) }</span>)
        }

        <span class="cov6" title="80">forFs(callbacks)
        forFs(always)</span>

}

func forSlice(s []func(v any), f func(func(v any))) <span class="cov7" title="160">{
        for _, e := range s </span><span class="cov6" title="80">{
                func() </span><span class="cov6" title="80">{
                        defer func() </span><span class="cov6" title="80">{
                                if e := recover(); e != nil </span><span class="cov0" title="0">{
                                        err := newErrorWithStacks(e)
                                        fmt.Println("error happens:\n ", err)
                                }</span>
                        }()
                        <span class="cov6" title="80">f(e)</span>
                }()
        }
}
</pre>
		
		<pre class="file" id="file192" style="display: none">package routine

import (
        "context"
        "log"
        "reflect"
        "syscall"
        "time"

        "github.com/panjf2000/ants/v2"
        "go.uber.org/atomic"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/common/utils/inspect"
        "github.com/wfusion/gofusion/config"

        fmkLog "github.com/wfusion/gofusion/log"

        _ "github.com/wfusion/gofusion/log/customlogger"
)

const (
        defaultMaxPoolSize = 10000000
)

func Construct(ctx context.Context, conf Conf, opts ...utils.OptionExtender) func() <span class="cov5" title="34">{
        opt := utils.ApplyOptions[config.InitOption](opts...)
        optU := utils.ApplyOptions[candyOption](opts...)
        if opt.AppName == "" </span><span class="cov3" title="5">{
                opt.AppName = optU.appName
        }</span>

        <span class="cov5" title="34">if conf.MaxRoutineAmount &lt;= 0 </span><span class="cov5" title="34">{
                conf.MaxRoutineAmount = defaultMaxPoolSize
        }</span>

        <span class="cov5" title="34">rwlock.Lock()
        defer rwlock.Unlock()
        if pools == nil </span><span class="cov4" title="12">{
                pools = make(map[string]map[string]Pool)
        }</span>
        <span class="cov5" title="34">if pools[opt.AppName] == nil </span><span class="cov5" title="25">{
                pools[opt.AppName] = make(map[string]Pool)
        }</span>
        <span class="cov5" title="34">if ignored == nil </span><span class="cov4" title="12">{
                ignored = make(map[string]*atomic.Int64)
        }</span>
        <span class="cov5" title="34">if ignored[opt.AppName] == nil </span><span class="cov5" title="34">{
                ignored[opt.AppName] = atomic.NewInt64(0)
        }</span>
        <span class="cov5" title="34">if idle == nil </span><span class="cov4" title="12">{
                idle = make(map[string]*atomic.Int64)
        }</span>
        <span class="cov5" title="34">if idle[opt.AppName] == nil </span><span class="cov5" title="34">{
                idle[opt.AppName] = atomic.NewInt64(int64(conf.MaxRoutineAmount))
        }</span>
        <span class="cov5" title="34">if utils.IsStrNotBlank(conf.Logger) </span><span class="cov5" title="34">{
                if defaultLogger == nil </span><span class="cov4" title="12">{
                        defaultLogger = make(map[string]ants.Logger)
                }</span>
                <span class="cov5" title="34">if defaultLogger[opt.AppName] == nil </span><span class="cov5" title="25">{
                        logger := reflect.New(inspect.TypeOf(conf.Logger)).Interface().(ants.Logger)
                        defaultLogger[opt.AppName] = logger
                        if custom, ok := logger.(customLogger); ok </span><span class="cov5" title="25">{
                                l := fmkLog.Use(conf.LogInstance, fmkLog.AppName(opt.AppName))
                                custom.Init(l, opt.AppName)
                        }</span>
                }
        }
        <span class="cov5" title="34">maxReleaseTime := utils.Must(time.ParseDuration(conf.MaxReleaseTimePerPool))

        go startDaemonRoutines(ctx, opt.AppName, &amp;conf)

        return func() </span><span class="cov5" title="34">{
                rwlock.Lock()
                defer rwlock.Unlock()

                pid := syscall.Getpid()
                app := config.Use(opt.AppName).AppName()
                allExited := func() bool </span><span class="cov5" title="34">{
                        return idle[opt.AppName].Load() == int64(conf.MaxRoutineAmount)-ignored[opt.AppName].Load()
                }</span>

                // waiting for pool
                <span class="cov5" title="34">if pools != nil </span><span class="cov5" title="34">{
                        for name, pool := range pools[opt.AppName] </span><span class="cov0" title="0">{
                                if err := pool.ReleaseTimeout(maxReleaseTime, ignoreMutex()); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("%v [Gofusion] %s %s exit with releasing pool %s failed because %s",
                                                pid, app, config.ComponentGoroutinePool, name, err)
                                }</span>
                                <span class="cov0" title="0">delete(pools[opt.AppName], name)</span>
                        }
                }

                <span class="cov5" title="34">log.Printf("%v [Gofusion] %s %s pool routines are recycled", pid, app, config.ComponentGoroutinePool)

                // waiting for go
                utils.Timeout(maxReleaseTime, utils.TimeoutWg(&amp;wg))
                log.Printf("%v [Gofusion] %s %s go routines are recycled", pid, app, config.ComponentGoroutinePool)

                if !allExited() </span><span class="cov0" title="0">{
                        log.Printf("%v [Gofusion] %s %s exit without all goroutines recycled [exists%v]",
                                pid, app, config.ComponentGoroutinePool, showRoutine(opt.AppName))
                }</span>

                <span class="cov5" title="34">delete(ignored, opt.AppName)
                delete(idle, opt.AppName)
                delete(routines, opt.AppName)</span>
        }
}

func configs(appName string) (conf Conf) <span class="cov10" title="948">{
        _ = config.Use(appName).LoadComponentConfig(config.ComponentGoroutinePool, &amp;conf)
        return
}</span>

func forceSync(appName string) bool <span class="cov9" title="947">{
        return configs(appName).ForceSync
}</span>

func init() <span class="cov4" title="14">{
        config.AddComponent(config.ComponentGoroutinePool, Construct)
}</span>
</pre>
		
		<pre class="file" id="file193" style="display: none">package routine

import (
        "errors"
        "fmt"
        "runtime/debug"
        "sync/atomic"
        "time"
        "unsafe"
)

type callbackType int

const (
        CallbackDone callbackType = 1 + iota
        CallbackFail
        CallbackAlways
        CallbackCancel
)

// pipe presents a promise that will be chain call
type pipe struct {
        pipeDoneTask, pipeFailTask func(v any) *Future
        pipePromise                *promise
}

// getPipe returns piped Future task function and pipe promise by the status of current promise.
func (p *pipe) getPipe(isResolved bool) (func(v any) *Future, *promise) <span class="cov0" title="0">{
        if isResolved </span><span class="cov0" title="0">{
                return p.pipeDoneTask, p.pipePromise
        }</span> else<span class="cov0" title="0"> {
                return p.pipeFailTask, p.pipePromise
        }</span>
}

// Canceller is used to check if the future is cancelled
// It be usually passed to the future task function
// for future task function can check if the future is cancelled.
type Canceller interface {
        IsCancelled() bool
        Cancel()
}

// canceller provides an implement of Canceller interface.
// It will be passed to future task function as parameter
type canceller struct {
        f *Future
}

// Cancel sets Future task to CANCELLED status
func (c *canceller) Cancel() <span class="cov0" title="0">{
        _ = c.f.Cancel()
}</span>

// IsCancelled returns true if Future task is cancelled, otherwise false.
func (c *canceller) IsCancelled() (r bool) <span class="cov0" title="0">{
        return c.f.IsCancelled()
}</span>

// futureVal stores the internal state of Future.
type futureVal struct {
        dones, fails, always []func(v any)
        cancels              []func()
        pipes                []*pipe
        r                    *Result
}

// Future provides a read-only view of promise,
// the value is set by using Resolve, Reject and Cancel methods of related promise
type Future struct {
        Id      int // ID can be used as identity of Future
        AppName string

        final chan struct{}
        // val point to futureVal that stores status of future
        // if we need to change the status of future, must copy a new futureVal and modify it,
        // then use CAS to put the pointer of new futureVal
        val unsafe.Pointer
}

// Canceller returns a canceller object related to future.
func (f *Future) Canceller() Canceller <span class="cov0" title="0">{
        return &amp;canceller{f}
}</span>

// IsCancelled returns true if the promise is cancelled, otherwise false
func (f *Future) IsCancelled() bool <span class="cov8" title="1052">{
        val := f.loadVal()

        if val != nil &amp;&amp; val.r != nil &amp;&amp; val.r.Typ == ResultCancelled </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov8" title="1048"> {
                return false
        }</span>
}

// SetTimeout sets the future task will be cancelled
// if future is not complete before time out
func (f *Future) SetTimeout(mm int) *Future <span class="cov0" title="0">{
        if mm == 0 </span><span class="cov0" title="0">{
                mm = 10
        }</span> else<span class="cov0" title="0"> {
                mm = mm * 1000 * 1000
        }</span>

        <span class="cov0" title="0">Go(func() </span><span class="cov0" title="0">{
                &lt;-time.After((time.Duration)(mm) * time.Nanosecond)
                _ = f.Cancel()
        }</span>, AppName(f.AppName))
        <span class="cov0" title="0">return f</span>
}

// GetChan returns a channel than can be used to receive result of promise
func (f *Future) GetChan() &lt;-chan *Result <span class="cov7" title="301">{
        c := make(chan *Result, 1)
        f.OnComplete(func(v any) </span><span class="cov7" title="301">{
                c &lt;- f.loadResult()
        }</span>).OnCancel(func() <span class="cov0" title="0">{
                c &lt;- f.loadResult()
        }</span>)
        <span class="cov7" title="301">return c</span>
}

// Get will block current goroutines until the Future is resolved/rejected/cancelled.
// If Future is resolved, value and nil will be returned
// If Future is rejected, nil and error will be returned.
// If Future is cancelled, nil and CANCELLED error will be returned.
func (f *Future) Get() (val any, err error) <span class="cov5" title="80">{
        &lt;-f.final
        return getFutureReturnVal(f.loadResult())
}</span>

// GetOrTimeout is similar to Get(), but GetOrTimeout will not block after timeout.
// If GetOrTimeout returns with a timeout, timeout value will be true in return values.
// The unit of parameter is millisecond.
func (f *Future) GetOrTimeout(mm uint) (val any, err error, timout bool) <span class="cov0" title="0">{
        if mm == 0 </span><span class="cov0" title="0">{
                mm = 10
        }</span> else<span class="cov0" title="0"> {
                mm = mm * 1000 * 1000
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-time.After((time.Duration)(mm) * time.Nanosecond):<span class="cov0" title="0">
                return nil, nil, true</span>
        case &lt;-f.final:<span class="cov0" title="0">
                r, err := getFutureReturnVal(f.loadResult())
                return r, err, false</span>
        }
}

// Cancel sets the status of promise to ResultCancelled.
// If promise is cancelled, Get() will return nil and CANCELLED error.
// All callback functions will be not called if promise is cancelled.
func (f *Future) Cancel() (e error) <span class="cov0" title="0">{
        return f.setResult(&amp;Result{ErrCancelled, ResultCancelled})
}</span>

// OnSuccess registers a callback function that will be called when promise is resolved.
// If promise is already resolved, the callback will immediately be called.
// The value of promise will be parameter of Done callback function.
func (f *Future) OnSuccess(callback func(v any)) *Future <span class="cov0" title="0">{
        f.addCallback(callback, CallbackDone)
        return f
}</span>

// OnFailure registers a callback function that will be called when promise is rejected.
// If promise is already rejected, the callback will immediately be called.
// The error of promise will be parameter of Fail callback function.
func (f *Future) OnFailure(callback func(v any)) *Future <span class="cov8" title="1052">{
        f.addCallback(callback, CallbackFail)
        return f
}</span>

// OnComplete register a callback function that will be called when promise is rejected or resolved.
// If promise is already rejected or resolved, the callback will immediately be called.
// According to the status of promise, value or error will be parameter of Always callback function.
// Value is the parameter if promise is resolved, or error is the parameter if promise is rejected.
// Always callback will be not called if promise be called.
func (f *Future) OnComplete(callback func(v any)) *Future <span class="cov8" title="1352">{
        f.addCallback(callback, CallbackAlways)
        return f
}</span>

// OnCancel registers a callback function that will be called when promise is cancelled.
// If promise is already cancelled, the callback will immediately be called.
func (f *Future) OnCancel(callback func()) *Future <span class="cov7" title="301">{
        f.addCallback(callback, CallbackCancel)
        return f
}</span>

// Pipe registers one or two functions that returns a Future, and returns a proxy of pipeline Future.
// First function will be called when Future is resolved, the returned Future will be as pipeline Future.
// Secondary function will be called when Future is rejected, the returned Future will be as pipeline Future.
func (f *Future) Pipe(callbacks ...any) (result *Future, ok bool) <span class="cov0" title="0">{
        if len(callbacks) == 0 ||
                (len(callbacks) == 1 &amp;&amp; callbacks[0] == nil) ||
                (len(callbacks) &gt; 1 &amp;&amp; callbacks[0] == nil &amp;&amp; callbacks[1] == nil) </span><span class="cov0" title="0">{
                result = f
                return
        }</span>

        // ensure all callback functions match the spec "func(v any) *Future"
        <span class="cov0" title="0">cs := make([]func(v any) *Future, len(callbacks), len(callbacks))
        for i, callback := range callbacks </span><span class="cov0" title="0">{
                switch c := callback.(type) </span>{
                case func(v any) *Future:<span class="cov0" title="0">
                        cs[i] = c</span>
                case func() *Future:<span class="cov0" title="0">
                        cs[i] = func(v any) *Future </span><span class="cov0" title="0">{
                                return c()
                        }</span>
                case func(v any):<span class="cov0" title="0">
                        cs[i] = func(v any) *Future </span><span class="cov0" title="0">{
                                return start(func() </span><span class="cov0" title="0">{
                                        c(v)
                                }</span>, true)
                        }
                case func(v any) (r any, err error):<span class="cov0" title="0">
                        cs[i] = func(v any) *Future </span><span class="cov0" title="0">{
                                return start(func() (r any, err error) </span><span class="cov0" title="0">{
                                        r, err = c(v)
                                        return
                                }</span>, true)
                        }
                case func():<span class="cov0" title="0">
                        cs[i] = func(v any) *Future </span><span class="cov0" title="0">{
                                return start(func() </span><span class="cov0" title="0">{
                                        c()
                                }</span>, true)
                        }
                case func() (r any, err error):<span class="cov0" title="0">
                        cs[i] = func(v any) *Future </span><span class="cov0" title="0">{
                                return start(func() (r any, err error) </span><span class="cov0" title="0">{
                                        r, err = c()
                                        return
                                }</span>, true)
                        }
                default:<span class="cov0" title="0">
                        ok = false
                        return</span>
                }
        }

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                v := f.loadVal()
                r := v.r
                if r != nil </span><span class="cov0" title="0">{
                        result = f
                        if r.Typ == ResultSuccess &amp;&amp; cs[0] != nil </span><span class="cov0" title="0">{
                                result = cs[0](r.Result)
                        }</span> else<span class="cov0" title="0"> if r.Typ == ResultFailure &amp;&amp; len(cs) &gt; 1 &amp;&amp; cs[1] != nil </span><span class="cov0" title="0">{
                                result = cs[1](r.Result)
                        }</span>
                } else<span class="cov0" title="0"> {
                        newPipe := &amp;pipe{}
                        newPipe.pipeDoneTask = cs[0]
                        if len(cs) &gt; 1 </span><span class="cov0" title="0">{
                                newPipe.pipeFailTask = cs[1]
                        }</span>
                        <span class="cov0" title="0">newPipe.pipePromise = NewPromise()

                        newVal := *v
                        newVal.pipes = append(newVal.pipes, newPipe)

                        //use CAS to ensure that the state of Future is not changed,
                        //if the state is changed, will retry CAS operation.
                        if atomic.CompareAndSwapPointer(&amp;f.val, unsafe.Pointer(v), unsafe.Pointer(&amp;newVal)) </span><span class="cov0" title="0">{
                                result = newPipe.pipePromise.Future
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">ok = true
        return</span>
}

// result uses Atomic load to return result of the Future
func (f *Future) loadResult() *Result <span class="cov7" title="381">{
        val := f.loadVal()
        return val.r
}</span>

// val uses Atomic load to return state value of the Future
func (f *Future) loadVal() *futureVal <span class="cov10" title="5191">{
        r := atomic.LoadPointer(&amp;f.val)
        return (*futureVal)(r)
}</span>

// setResult sets the value and final status of promise, it will only be executed for once
func (f *Future) setResult(r *Result) (e error) <span class="cov8" title="1052">{
        defer func() </span><span class="cov8" title="1053">{
                if err := getError(recover()); err != nil </span><span class="cov0" title="0">{
                        e = err
                        fmt.Printf("\nerror in setResult(): %s\n%s\n", err, debug.Stack())
                }</span>
        }()

        <span class="cov8" title="1052">e = errors.New("cannot resolve/reject/cancel more than once")

        for </span><span class="cov8" title="1049">{
                v := f.loadVal()
                if v.r != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1049">newVal := *v
                newVal.r = r

                // Use CAS operation to ensure that the state of promise isn't changed.
                // If the state is changed, must get the latest state and try to call CAS again.
                // No ABA issue in this case because address of all objects are different.
                if atomic.CompareAndSwapPointer(&amp;f.val, unsafe.Pointer(v), unsafe.Pointer(&amp;newVal)) </span><span class="cov8" title="1051">{
                        //Close chEnd then all Get() and GetOrTimeout() will be unblocked
                        close(f.final)

                        //call callback functions and start the promise pipeline
                        if len(v.dones) &gt; 0 || len(v.fails) &gt; 0 || len(v.always) &gt; 0 || len(v.cancels) &gt; 0 </span><span class="cov5" title="80">{
                                Go(func() </span><span class="cov5" title="80">{
                                        execCallback(r, v.dones, v.fails, v.always, v.cancels)
                                }</span>, AppName(f.AppName))
                        }

                        //start the pipeline
                        <span class="cov8" title="1054">if len(v.pipes) &gt; 0 </span><span class="cov0" title="0">{
                                Go(func() </span><span class="cov0" title="0">{
                                        for _, pipe := range v.pipes </span><span class="cov0" title="0">{
                                                pipeTask, pipePromise := pipe.getPipe(r.Typ == ResultSuccess)
                                                startPipe(r, pipeTask, pipePromise)
                                        }</span>
                                }, AppName(f.AppName))
                        }
                        <span class="cov8" title="1054">e = nil
                        break</span>
                }
        }
        <span class="cov8" title="1054">return</span>
}

// handleOneCallback registers a callback function
func (f *Future) addCallback(callback any, t callbackType) <span class="cov9" title="2704">{
        if callback == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="2704">if (t == CallbackDone) ||
                (t == CallbackFail) ||
                (t == CallbackAlways) </span><span class="cov9" title="2404">{
                if _, ok := callback.(func(v any)); !ok </span><span class="cov0" title="0">{
                        panic(errors.New("callback function spec must be func(v any)"))</span>
                }
        } else<span class="cov7" title="301"> if t == CallbackCancel </span><span class="cov7" title="301">{
                if _, ok := callback.(func()); !ok </span><span class="cov0" title="0">{
                        panic(errors.New("callback function spec must be func()"))</span>
                }
        }

        <span class="cov9" title="2705">for </span><span class="cov9" title="2705">{
                v := f.loadVal()
                r := v.r
                if r == nil </span><span class="cov6" title="160">{
                        newVal := *v
                        switch t </span>{
                        case CallbackDone:<span class="cov0" title="0">
                                newVal.dones = append(newVal.dones, callback.(func(v any)))</span>
                        case CallbackFail:<span class="cov5" title="80">
                                newVal.fails = append(newVal.fails, callback.(func(v any)))</span>
                        case CallbackAlways:<span class="cov5" title="80">
                                newVal.always = append(newVal.always, callback.(func(v any)))</span>
                        case CallbackCancel:<span class="cov0" title="0">
                                newVal.cancels = append(newVal.cancels, callback.(func()))</span>
                        }

                        //use CAS to ensure that the state of Future is not changed,
                        //if the state is changed, will retry CAS operation.
                        <span class="cov6" title="160">if atomic.CompareAndSwapPointer(&amp;f.val, unsafe.Pointer(v), unsafe.Pointer(&amp;newVal)) </span><span class="cov6" title="160">{
                                break</span>
                        }
                } else<span class="cov9" title="2542"> {
                        if (t == CallbackDone &amp;&amp; r.Typ == ResultSuccess) ||
                                (t == CallbackFail &amp;&amp; r.Typ == ResultFailure) ||
                                (t == CallbackAlways &amp;&amp; r.Typ != ResultCancelled) </span><span class="cov8" title="1271">{
                                callbackFunc := callback.(func(v any))
                                callbackFunc(r.Result)
                        }</span> else<span class="cov8" title="1272"> if t == CallbackCancel &amp;&amp; r.Typ == ResultCancelled </span><span class="cov0" title="0">{
                                callbackFunc := callback.(func())
                                callbackFunc()
                        }</span>
                        <span class="cov9" title="2546">break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file194" style="display: none">package routine

import (
        "context"
        "log"
        "runtime"
        "syscall"
        "time"

        "go.uber.org/atomic"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/config"
        "github.com/wfusion/gofusion/metrics"
)

var (
        metricsRuntimeTotalGoroutinesKey     = []string{"runtime", "total_goroutines"}
        metricsRuntimeGoroutinesKey          = []string{"runtime", "fus_goroutines"}
        metricsRuntimeAllocBytesKey          = []string{"runtime", "alloc_bytes"}
        metricsRuntimeSysBytesKey            = []string{"runtime", "sys_bytes"}
        metricsRuntimeMallocCountKey         = []string{"runtime", "malloc_count"}
        metricsRuntimeFreeCountKey           = []string{"runtime", "free_count"}
        metricsRuntimeHeapObjectsKey         = []string{"runtime", "heap_objects"}
        metricsRuntimeGCRunsKey              = []string{"runtime", "total_gc_runs"}
        metricsRuntimeTotalSTWLatencyKey     = []string{"runtime", "total_gc_pause_ns"}
        metricsRuntimeTotalSTWLatencyBuckets = []float64{
                .1, .25, .5, .75, .90, .95, .99,
                1, 2.5, 5, 7.5, 9, 9.5, 9.9,
                10, 25, 50, 75, 90, 95, 99,
                100, 250, 500, 750, 900, 950, 990,
        }
)

func startDaemonRoutines(ctx context.Context, appName string, conf *Conf) <span class="cov7" title="34">{
        ticker := time.Tick(time.Second * 5)
        app := config.Use(appName).AppName()
        labels := []metrics.Label{}
        lastNumGc := atomic.NewUint32(0)
        for </span><span class="cov10" title="100">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov7" title="34">
                        log.Printf("%v [Gofusion] %s %s metrics exited",
                                syscall.Getpid(), app, config.ComponentGoroutinePool)
                        return</span>
                case &lt;-ticker:<span class="cov9" title="66">
                        go metricsRuntime(ctx, appName, lastNumGc, conf, labels)</span>
                }
        }
}

func metricsRuntime(ctx context.Context, appName string, lastNumGc *atomic.Uint32, conf *Conf, labels []metrics.Label) <span class="cov9" title="66">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov9" title="66"></span>

        }

        <span class="cov9" title="66">_, _ = utils.Catch(func() </span><span class="cov9" title="66">{
                var routineNum int64
                if idle != nil &amp;&amp; idle[appName] != nil </span><span class="cov9" title="66">{
                        routineNum = int64(conf.MaxRoutineAmount) - idle[appName].Load()
                }</span>

                // export number of Goroutines
                <span class="cov9" title="66">totalRoutineNum := runtime.NumGoroutine()

                // export memory stats
                var stats runtime.MemStats
                runtime.ReadMemStats(&amp;stats)

                // export info about the last few GC runs
                // handle wrap around
                if stats.NumGC &lt; lastNumGc.Load() </span><span class="cov0" title="0">{
                        lastNumGc.Store(0)
                }</span>

                // ensure we don't scan more than 256
                <span class="cov9" title="66">if stats.NumGC-lastNumGc.Load() &gt;= 256 </span><span class="cov0" title="0">{
                        lastNumGc.Store(stats.NumGC - 255)
                }</span>
                <span class="cov9" title="66">lastNumGc.Store(stats.NumGC)

                totalGoRoutinesKey := append([]string{appName}, metricsRuntimeTotalGoroutinesKey...)
                goroutineKey := append([]string{appName}, metricsRuntimeGoroutinesKey...)
                allocBytesKey := append([]string{appName}, metricsRuntimeAllocBytesKey...)
                sysBytesKey := append([]string{appName}, metricsRuntimeSysBytesKey...)
                mallocCountKey := append([]string{appName}, metricsRuntimeMallocCountKey...)
                freeCountKey := append([]string{appName}, metricsRuntimeFreeCountKey...)
                heapObjectsKey := append([]string{appName}, metricsRuntimeHeapObjectsKey...)
                gcRunsKey := append([]string{appName}, metricsRuntimeGCRunsKey...)
                totalSTWLatencyKey := append([]string{appName}, metricsRuntimeTotalSTWLatencyKey...)

                for _, m := range metrics.Internal(metrics.AppName(appName)) </span><span class="cov5" title="9">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov5" title="9">
                                if m.IsEnableServiceLabel() </span><span class="cov5" title="9">{
                                        m.SetGauge(ctx, totalGoRoutinesKey, float64(totalRoutineNum), metrics.Labels(labels))
                                        m.SetGauge(ctx, goroutineKey, float64(routineNum), metrics.Labels(labels))
                                        m.SetGauge(ctx, allocBytesKey, float64(stats.Alloc), metrics.Labels(labels))
                                        m.SetGauge(ctx, sysBytesKey, float64(stats.Sys), metrics.Labels(labels))
                                        m.SetGauge(ctx, mallocCountKey, float64(stats.Mallocs), metrics.Labels(labels))
                                        m.SetGauge(ctx, freeCountKey, float64(stats.Frees), metrics.Labels(labels))
                                        m.SetGauge(ctx, heapObjectsKey, float64(stats.HeapObjects), metrics.Labels(labels))
                                        m.SetGauge(ctx, gcRunsKey, float64(stats.NumGC), metrics.Labels(labels))
                                        for i := lastNumGc.Load(); i &lt; stats.NumGC; i++ </span><span class="cov0" title="0">{
                                                m.AddSample(ctx, totalSTWLatencyKey, float64(stats.PauseNs[i%256]), metrics.Labels(labels))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        m.SetGauge(ctx, metricsRuntimeTotalGoroutinesKey, float64(totalRoutineNum), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsRuntimeGoroutinesKey, float64(routineNum), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsRuntimeAllocBytesKey, float64(stats.Alloc), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsRuntimeSysBytesKey, float64(stats.Sys), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsRuntimeMallocCountKey, float64(stats.Mallocs), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsRuntimeFreeCountKey, float64(stats.Frees), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsRuntimeHeapObjectsKey, float64(stats.HeapObjects), metrics.Labels(labels))
                                        m.SetGauge(ctx, metricsRuntimeGCRunsKey, float64(stats.NumGC), metrics.Labels(labels))
                                        for i := lastNumGc.Load(); i &lt; stats.NumGC; i++ </span><span class="cov0" title="0">{
                                                m.AddSample(ctx, metricsRuntimeTotalSTWLatencyKey, float64(stats.PauseNs[i%256]),
                                                        metrics.Labels(labels),
                                                        metrics.PrometheusBuckets(metricsRuntimeTotalSTWLatencyBuckets),
                                                )
                                        }</span>
                                }
                        }
                }

        })
}
</pre>
		
		<pre class="file" id="file195" style="display: none">package routine

import (
        "math"
        "sync"
        "time"

        "github.com/panjf2000/ants/v2"
        "go.uber.org/atomic"

        "github.com/wfusion/gofusion/common/utils"
)

var (
        // pools is a global map of goroutine pools, managing multiple goroutine pools,
        // with total service instance quantity controlled by allocated
        // TODO: Issue with nested goroutine pool allocation;
        //       if a task executed in a goroutine pool nests a new goroutine pool allocation,
        //       it might cause a deadlock, and errors cannot be quickly thrown.
        pools         map[string]map[string]Pool
        rwlock        sync.RWMutex
        ignored       map[string]*atomic.Int64
        idle          map[string]*atomic.Int64
        defaultLogger map[string]ants.Logger
)

type pool struct {
        appName string
        name    string
        pool    *ants.Pool
        option  *NewPoolOption
}

func (p *pool) Submit(task any, opts ...utils.OptionExtender) (e error) <span class="cov1" title="2">{
        opt := utils.ApplyOptions[candyOption](opts...)
        wrapFn := utils.WrapFunc1[error](task)
        if !forceSync(p.appName) </span><span class="cov1" title="2">{
                return p.pool.Submit(func() </span><span class="cov1" title="2">{ e = wrapFn(opt.args...) }</span>)
        }

        <span class="cov0" title="0">return wrapFn(opt.args...)</span>
}
func (p *pool) Running() int   <span class="cov0" title="0">{ return p.pool.Running() }</span>
func (p *pool) Free() int      <span class="cov0" title="0">{ return p.pool.Free() }</span>
func (p *pool) Waiting() int   <span class="cov0" title="0">{ return p.pool.Waiting() }</span>
func (p *pool) Cap() int       <span class="cov0" title="0">{ return p.pool.Cap() }</span>
func (p *pool) IsClosed() bool <span class="cov0" title="0">{ return p.pool.IsClosed() }</span>
func (p *pool) Release(opts ...utils.OptionExtender) <span class="cov1" title="2">{
        defer release(p.appName, p, opts...)
        p.pool.Release()
}</span>
func (p *pool) ReleaseTimeout(timeout time.Duration, opts ...utils.OptionExtender) error <span class="cov0" title="0">{
        defer release(p.appName, p, opts...)
        return p.pool.ReleaseTimeout(timeout)
}</span>

func NewPool(name string, size int, opts ...utils.OptionExtender) (p Pool) <span class="cov1" title="2">{
        o := utils.ApplyOptions[NewPoolOption](opts...)
        opt := utils.ApplyOptions[candyOption](opts...)
        if o.Logger == nil </span><span class="cov1" title="2">{
                o.Logger = defaultLogger[opt.appName]
        }</span>

        <span class="cov1" title="2">validate(opt.appName, name)
        allocate(opt.appName, size, o)

        antsPool, err := ants.NewPool(size, ants.WithOptions(ants.Options{
                ExpiryDuration:   o.ExpiryDuration,
                PreAlloc:         o.PreAlloc,
                MaxBlockingTasks: o.MaxBlockingTasks,
                Nonblocking:      o.Nonblocking,
                PanicHandler:     o.PanicHandler,
                Logger:           o.Logger,
                DisablePurge:     o.DisablePurge,
        }))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov1" title="2">p = &amp;pool{appName: opt.appName, name: name, pool: antsPool, option: o}
        addPool(opt.appName, name, p)
        return</span>
}

type internalOption struct {
        // ignoreRecycled does not account for unrecycled successes during graceful exit,
        // only used when calling the loop method
        ignoreRecycled bool
        // ignoreMutex does not lock on map operations,
        // considering replacing with reentrant lock github.com/sasha-s/go-deadlock,
        // but introduction will increase comprehension cost, also goes against go design
        ignoreMutex bool
}

func ignoreRecycled() utils.OptionFunc[internalOption] <span class="cov8" title="364">{
        return func(o *internalOption) </span><span class="cov8" title="364">{
                o.ignoreRecycled = true
        }</span>
}

func ignoreMutex() utils.OptionFunc[internalOption] <span class="cov0" title="0">{
        return func(o *internalOption) </span><span class="cov0" title="0">{
                o.ignoreMutex = true
        }</span>
}

func allocate(appName string, size int, o *NewPoolOption, opts ...utils.OptionExtender) <span class="cov9" title="1053">{
        oo := utils.ApplyOptions[internalOption](opts...)
        demands := int64(size)
        rwlock.RLock()
        defer rwlock.RUnlock()
        if idle[appName].Load()-demands &lt; 0 &amp;&amp; o.ApplyTimeout == 0 </span><span class="cov0" title="0">{
                panic(ErrPoolOverload)</span>
        }

        <span class="cov9" title="1054">if o.ApplyTimeout &lt; 0 </span><span class="cov9" title="1053">{
                o.ApplyTimeout = math.MaxInt64
        }</span>

        <span class="cov9" title="1054">t := time.NewTimer(o.ApplyTimeout)
        for </span><span class="cov10" title="1060">{
                select </span>{
                case &lt;-t.C:<span class="cov0" title="0">
                        panic(ErrTimeout)</span>
                default:<span class="cov9" title="1059">
                        minuend := idle[appName].Load()
                        diff := minuend - demands
                        // main thread is a goroutine as well, so diff should be greater than 0
                        if diff &lt;= 0 || !idle[appName].CompareAndSwap(minuend, diff) </span><span class="cov2" title="4">{
                                continue</span>
                        }
                        <span class="cov9" title="1056">if oo.ignoreRecycled </span><span class="cov7" title="182">{
                                ignored[appName].Add(demands)
                        }</span>

                        <span class="cov9" title="1056">return</span>
                }
        }
}

func release(appName string, p *pool, opts ...utils.OptionExtender) <span class="cov9" title="1052">{
        o := utils.ApplyOptions[internalOption](opts...)
        capacity := int64(1)
        if pools == nil || pools[appName] == nil || idle == nil || idle[appName] == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="1051">if p != nil </span><span class="cov1" title="2">{
                if !o.ignoreMutex </span><span class="cov1" title="2">{
                        rwlock.Lock()
                        defer rwlock.Unlock()
                }</span>
                <span class="cov1" title="2">delete(pools[appName], p.name)
                capacity = int64(p.pool.Cap())</span>
        }

        <span class="cov9" title="1051">alloc := idle[appName]
        if alloc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov9" title="1053">alloc.Add(capacity)
        if o != nil &amp;&amp; o.ignoreRecycled </span><span class="cov7" title="182">{
                alloc.Sub(capacity)
        }</span>
}

func addPool(appName, name string, pool Pool) <span class="cov1" title="2">{
        rwlock.Lock()
        defer rwlock.Unlock()
        pools[appName][name] = pool
}</span>

func validate(appName, name string) <span class="cov1" title="2">{
        rwlock.RLock()
        defer rwlock.RUnlock()
        if _, ok := pools[appName][name]; ok </span><span class="cov0" title="0">{
                panic(ErrDuplicatedName)</span>
        }
}

type PoolOption struct {
        // ExpiryDuration is a period for the scavenger goroutine to clean up those expired workers,
        // the scavenger scans all workers every `ExpiryDuration` and clean up those workers that haven't been
        // used for more than `ExpiryDuration`.
        ExpiryDuration time.Duration

        // PreAlloc indicates whether to make memory pre-allocation when initializing Pool.
        PreAlloc bool

        // Max number of goroutine blocking on pool.Submit.
        // 0 (default value) means no such limit.
        MaxBlockingTasks int

        // When Nonblocking is true, Pool.Submit will never be blocked.
        // ErrPoolOverload will be returned when Pool.Submit cannot be done at once.
        // When Nonblocking is true, MaxBlockingTasks is inoperative.
        Nonblocking bool

        // PanicHandler is used to handle panics from each worker goroutine.
        // if nil, panics will be thrown out again from worker goroutines.
        PanicHandler func(any)

        // Logger is the customized logger for logging info, if it is not set,
        // default standard logger from log package is used.
        Logger ants.Logger

        // When DisablePurge is true, workers are not purged and are resident.
        DisablePurge bool
}

type NewPoolOption struct {
        PoolOption
        // ApplyTimeout is the timeout duration for applying a goroutine pool
        // Default = 0 means non-blocking and directly panic;
        // &lt; 0 means blocking and wait;
        // &gt; 0 means block and panic after timeout
        ApplyTimeout time.Duration
}

func Timeout(t time.Duration) utils.OptionFunc[NewPoolOption] <span class="cov0" title="0">{
        return func(o *NewPoolOption) </span><span class="cov0" title="0">{
                o.ApplyTimeout = t
        }</span>
}

func WithoutTimeout() utils.OptionFunc[NewPoolOption] <span class="cov1" title="2">{
        return func(o *NewPoolOption) </span><span class="cov1" title="2">{
                o.ApplyTimeout = -1
        }</span>
}

func Options(in *NewPoolOption) utils.OptionFunc[NewPoolOption] <span class="cov0" title="0">{
        return func(o *NewPoolOption) </span><span class="cov0" title="0">{
                o.ApplyTimeout = in.ApplyTimeout
                o.ExpiryDuration = in.PoolOption.ExpiryDuration
                o.PreAlloc = in.PreAlloc
                o.MaxBlockingTasks = in.MaxBlockingTasks
                o.Nonblocking = in.Nonblocking
                o.PanicHandler = in.PanicHandler
                o.Logger = in.Logger
                o.DisablePurge = in.DisablePurge
        }</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">package routine

import (
        "math/rand"
        "unsafe"
)

var (
        ErrCancelled error = &amp;CancelledError{}
)

// CancelledError present the Future object is cancelled.
type CancelledError struct {
}

func (e *CancelledError) Error() string <span class="cov0" title="0">{
        return "Task be cancelled"
}</span>

// resultType present the type of Future final status.
type resultType int

const (
        ResultSuccess resultType = iota
        ResultFailure
        ResultCancelled
)

// Result presents the result of a promise.
// If Typ is ResultSuccess, Result field will present the returned value of Future task.
// If Typ is ResultFailure, Result field will present a related error .
// If Typ is ResultCancelled, Result field will be null.
type Result struct {
        Result any        //result of the promise
        Typ    resultType //success, failure, or cancelled?
}

// promise presents an object that acts as a proxy for a result.
// that is initially unknown, usually because the computation of its
// value is yet incomplete (refer to wikipedia).
// You can use Resolve/Reject/Cancel to set the final result of promise.
// Future can return a read-only placeholder view of result.
type promise struct {
        *Future
}

// Cancel sets the status of promise to ResultCancelled.
// If promise is cancelled, Get() will return nil and CANCELLED error.
// All callback functions will be not called if promise is cancelled.
func (p *promise) Cancel() (e error) <span class="cov0" title="0">{
        return p.Future.Cancel()
}</span>

// Resolve sets the value for promise, and the status will be changed to ResultSuccess.
// if promise is resolved, Get() will return the value and nil error.
func (p *promise) Resolve(v any) (e error) <span class="cov9" title="1049">{
        return p.setResult(&amp;Result{v, ResultSuccess})
}</span>

// Reject sets the error for promise, and the status will be changed to ResultFailure.
// if promise is rejected, Get() will return nil and the related error value.
func (p *promise) Reject(err error) (e error) <span class="cov1" title="2">{
        return p.setResult(&amp;Result{err, ResultFailure})
}</span>

// OnSuccess registers a callback function that will be called when promise is resolved.
// If promise is already resolved, the callback will immediately be called.
// The value of promise will be parameter of Done callback function.
func (p *promise) OnSuccess(callback func(v any)) *promise <span class="cov0" title="0">{
        p.Future.OnSuccess(callback)
        return p
}</span>

// OnFailure registers a callback function that will be called when promise is rejected.
// If promise is already rejected, the callback will immediately be called.
// The error of promise will be parameter of Fail callback function.
func (p *promise) OnFailure(callback func(v any)) *promise <span class="cov0" title="0">{
        p.Future.OnFailure(callback)
        return p
}</span>

// OnComplete register a callback function that will be called when promise is rejected or resolved.
// If promise is already rejected or resolved, the callback will immediately be called.
// According to the status of promise, value or error will be parameter of Always callback function.
// Value is the parameter if promise is resolved, or error is the parameter if promise is rejected.
// Always callback will be not called if promise be called.
func (p *promise) OnComplete(callback func(v any)) *promise <span class="cov0" title="0">{
        p.Future.OnComplete(callback)
        return p
}</span>

// OnCancel registers a callback function that will be called when promise is cancelled.
// If promise is already cancelled, the callback will immediately be called.
func (p *promise) OnCancel(callback func()) *promise <span class="cov0" title="0">{
        p.Future.OnCancel(callback)
        return p
}</span>

// NewPromise is factory function for promise
func NewPromise() *promise <span class="cov10" title="1054">{
        val := &amp;futureVal{
                dones:   make([]func(v any), 0, 8),
                fails:   make([]func(v any), 0, 8),
                always:  make([]func(v any), 0, 4),
                cancels: make([]func(), 0, 2),
                pipes:   make([]*pipe, 0, 4),
        }
        f := &amp;promise{
                Future: &amp;Future{
                        Id:    rand.Int(),
                        final: make(chan struct{}),
                        val:   unsafe.Pointer(val),
                },
        }
        return f
}</span>
</pre>
		
		<pre class="file" id="file197" style="display: none">package routine

import (
        "strconv"
        "sync"
        "time"

        "github.com/wfusion/gofusion/common/utils"
        "github.com/wfusion/gofusion/log"
)

const (
        ErrTimeout        utils.Error = "operation timed out"
        ErrPoolOverload   utils.Error = "too many goroutines blocked on submit or Nonblocking is set"
        ErrDuplicatedName utils.Error = "duplicated goroutine pool name"
)

var (
        // wg 
        wg       sync.WaitGroup
        locker   sync.RWMutex
        routines = map[string]map[string]int{}
)

type Pool interface {
        Submit(task any, opts ...utils.OptionExtender) error
        Running() int
        Free() int
        Waiting() int
        Cap() int
        IsClosed() bool
        Release(opts ...utils.OptionExtender)
        ReleaseTimeout(timeout time.Duration, opts ...utils.OptionExtender) error
}

// Conf routine configure
//nolint: revive // struct tag too long issue
type Conf struct {
        // MaxGoroutineAmount 
        MaxRoutineAmount int `yaml:"max_routine_amount" json:"max_routine_amount" toml:"max_routine_amount" default:"-1"`

        // MaxReleaseTimePerPool  pool 
        MaxReleaseTimePerPool string `yaml:"max_release_time_per_pool" json:"max_release_time_per_pool" toml:"max_release_time_per_pool" default:"30s"`

        // ForceSync will synchronously execute Go, promise function if true
        ForceSync bool `yaml:"force_sync" json:"force_sync" toml:"force_sync" default:"false"`

        // Logger is the customized logger for logging info, if it is not set,
        // default standard logger from log package is used.
        EnabledLogger bool   `yaml:"enabled_logger" json:"enabled_logger" toml:"enabled_logger" default:"false"`
        Logger        string `yaml:"logger" json:"logger" toml:"logger" default:"github.com/wfusion/gofusion/log/customlogger.routineLogger"`
        LogInstance   string `yaml:"log_instance" json:"log_instance" toml:"log_instance" default:"default"`
}

func addRoutine(appName, name string) <span class="cov9" title="940">{
        locker.Lock()
        defer locker.Unlock()

        if _, ok := routines[appName]; !ok </span><span class="cov3" title="7">{
                routines[appName] = make(map[string]int)
        }</span>
        <span class="cov10" title="952">routines[appName][name]++</span>
}

func delRoutine(appName, name string) <span class="cov10" title="952">{
        locker.Lock()
        defer locker.Unlock()
        if routines == nil || routines[appName] == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="952">if routines[appName][name]--; routines[appName][name] &lt;= 0 </span><span class="cov8" title="294">{
                delete(routines, name)
        }</span>
}

func showRoutine(appName string) (r []string) <span class="cov0" title="0">{
        locker.RLock()
        defer locker.RUnlock()
        r = make([]string, 0, len(routines[appName]))
        for n, c := range routines[appName] </span><span class="cov0" title="0">{
                r = append(r, n+":"+strconv.Itoa(c))
        }</span>
        <span class="cov0" title="0">return</span>
}

type customLogger interface {
        Init(log log.Logable, appName string)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
